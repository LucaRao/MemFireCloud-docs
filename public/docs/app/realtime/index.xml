<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>realtime on My New Hugo Site</title>
    <link>https://github.com/docs/app/realtime/</link>
    <description>Recent content in realtime on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://github.com/docs/app/realtime/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>概述</title>
      <link>https://github.com/docs/app/realtime/realtime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/docs/app/realtime/realtime/</guid>
      <description>Supabase提供一个全球分布的实时服务器集群，实现了以下功能：&#xA;广播：以低延迟的方式从客户端向客户端发送短暂的信息。 Presence：跟踪和同步客户端之间的共享状态。 Postgres CDC：听取Postgres数据库的变化，并将其发送给授权客户。 频道 是实时的基本构建块，它缩小了订阅客户端的数据流范围。 你可以把一个频道想象成一个聊天室，参与者可以看到谁在网上，并发送和接收消息；类似于Discord或Slack频道。&#xA;所有客户端都可以连接到一个频道，并利用内置的广播和呈现功能，而扩展功能（如PostgresCDC）必须在使用前启用。&#xA;广播 link广播遵循发布-订阅模式，客户将消息发布到具有唯一标识符的频道。例如，一个用户可以向一个id为room-1的频道发送消息。&#xA;其他客户可以通过订阅id为`room-1&amp;rsquo;的频道来选择实时接收该消息。如果这些客户在线并订阅了，那么他们将收到该消息。&#xA;广播的工作原理是将你的客户端连接到最近的实时服务器，该服务器将与其他服务器通信，将消息转发给其他客户端。&#xA;一个常见的用例是在网络游戏中与其他客户端分享用户的光标位置。&#xA;Presence linkPresence利用内存中无冲突的复制数据类型（CRDT），以最终一致的方式跟踪和同步共享状态。它计算现有状态和新的状态变化之间的差异，并通过广播向客户端发送必要的更新。&#xA;当一个新客户端订阅了一个频道时，它将立即在一条消息中接收该频道的最新状态，而不是等待所有其他客户端发送各自的状态。&#xA;客户可以随心所欲地来来去去，只要他们都订阅了同一频道，那么他们都将拥有彼此相同的状态。&#xA;Presence的好处是，如果一个客户突然断开连接（例如，他们下线了），他们的状态将自动从共享状态中删除。如果你曾经试图建立一个处理意外断开连接的 &amp;ldquo;我在线 &amp;ldquo;功能，你就会体会到这是多么有用。&#xA;Postgres CDC linkPostgres变化数据捕获（CDC）使你能够监听数据库的变化，并根据行级安全(RLS)策略将其广播给授权客户。&#xA;这是由实时轮询你的数据库的逻辑复制槽的变化，将这些变化传递给apply_rlsSQL函数以确定哪些客户端有权限，然后使用广播将这些变化发送给客户端。&#xA;实时需要一个名为supabase_realtime的发布来确定哪些表需要轮询。你必须在客户端订阅想要监听数据库变化的频道之前，将表添加到这个发布中。&#xA;我们强烈建议你在你的数据库表上启用RLS，并制定RLS策略以防止未经授权的人访问你的数据。&#xA;参考资源 link 快速快速入门 实时：多人版本 blog post </description>
    </item>
    <item>
      <title>实时快速入门</title>
      <link>https://github.com/docs/app/realtime/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/docs/app/realtime/quickstart/</guid>
      <description>学习如何构建multiplayer.dev，这是一个合作应用，它展示了使用实时的广播、Presence和Postgres CDC。&#xA;安装supabase-js 客户端 link&#xD;npm install @supabase/supabase-js&#xD;光标位置 link广播允许一个客户端发送消息，多个客户端接收消息。广播的消息是短暂的。它们不会被持久化到数据库中，而是直接通过实时服务器转发。这对于发送像光标位置这样的信息是很理想的，因为最小的延迟是很重要的，但持久化则不是。&#xA;在multiplayer.dev中，客户端的光标位置被发送到房间里的其他客户端。然而，在这个例子中，光标位置将是随机生成的。&#xA;你需要从你的项目的API设置中获得公共的anon访问令牌。然后你就可以设置Supabase客户端，并开始发送一个客户端的光标位置到通道room1中的其他客户端。&#xA;const { createClient } = require(&amp;#39;@supabase/supabase-js&amp;#39;)&#xD;const supabase = createClient(&amp;#39;https://your-project-ref.supabase.co&amp;#39;, &amp;#39;anon-key&amp;#39;, {&#xD;realtime: {&#xD;params: {&#xD;eventsPerSecond: 10,&#xD;},&#xD;},&#xD;})&#xD;// Channel name can be any string.&#xD;// Create channels with the same name for both the broadcasting and receiving clients.&#xD;const channel = supabase.channel(&amp;#39;room1&amp;#39;)&#xD;// Subscribe registers your client with the server&#xD;channel.subscribe((status) =&amp;gt; {&#xD;if (status === &amp;#39;SUBSCRIBED&amp;#39;) {&#xD;// now you can start broadcasting cursor positions&#xD;setInterval(() =&amp;gt; {&#xD;channel.</description>
    </item>
    <item>
      <title>Postgres CDC</title>
      <link>https://github.com/docs/app/realtime/postgres-cdc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/docs/app/realtime/postgres-cdc/</guid>
      <description>实时的Postgres变更数据捕获（CDC）功能监听数据库的变更，并将其发送给客户端。客户端需要通过JWT订阅，该JWT决定了他们可以根据数据库的行级安全接收哪些变化。&#xA;任何能够访问用项目的JWT秘密签名的有效JWT的人都能够监听你的数据库的变化，除非表启用了行级安全并制定了策略。&#xA;客户端可以选择接收 INSERT、UPDATE、DELETE或 *（all）的变化，用于接收模式中的所有变化、模式中的一个表或表中的一个列的值。你的客户应该只监听public模式中的表，你必须首先启用你希望客户监听的表。&#xA;Postgres CDC对 public模式中的表是开箱即用的。你可以通过给访问令牌中的数据库角色授予表 SELECT的权限来监听你的私有模式中的表。你可以运行一个类似于以下的查询。&#xA;GRANT SELECT ON &amp;#34;private_schema&amp;#34;.&amp;#34;table&amp;#34; TO authenticated;&#xD;info&#xD;我们强烈建议你启用RLS并为私有模式中的表创建策略。否则，你所授予的任何角色都将拥有对表的不受限制的读取权限。&#xA;你可以在仪表板的Replication部分或用SQL editor来做这个。&#xA;begin;&#xD;-- remove the supabase_realtime publication&#xD;drop publication if exists supabase_realtime;&#xD;-- re-create the supabase_realtime publication with no tables&#xD;create publication supabase_realtime;&#xD;commit;&#xD;-- add a table to the publication&#xD;alter publication supabase_realtime add table messages;&#xD;默认情况下，只发送 新的记录变化，但如果你想在每次 UPDATE或 DELETE一个记录时接收 旧的记录（以前的值）。 你可以将你的表的replica identity 设置为 full。&#xA;alter table messages replica identity full;&#xD;监听public模式中的所有变化：</description>
    </item>
    <item>
      <title>实时速率限制</title>
      <link>https://github.com/docs/app/realtime/rate-limits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/docs/app/realtime/rate-limits/</guid>
      <description>Supabase Realtime是一个全球集群。我们已经实施了一些速率限制，以帮助确保所有客户的高可用性。&#xA;速率限制可按项目配置，我们的集群支持数百万的并发连接。联系支持如果这些限制造成了问题。&#xA;按计划限制 link免费计划和专业计划都有相应的限制。更多信息见我们的定价页。&#xA;企业计划是按使用量计费的。我们仍然对企业计划采用限制措施。如果你使用企业计划，只需联系支持，我们将根据需要增加你的限额。&#xA;企业计划的限制从以下几点开始。&#xA;500个并发客户 每秒1,000条信息 500个并发的频道 系统限制 link以下限制适用于所有项目:&#xA;每秒有500个频道加入 每个连接的客户端有100个频道 客户端限制 link一些基本的WebSocket消息速率限制在客户端实现。&#xA;例如，multiplayer.dev demo实例化了带有eventsPerSecond参数的Supabase客户端。&#xA;速率限制错误 link速率限制错误可能出现在WebSocket连接的后端日志和消息中。&#xA;info&#xD;使用Realtime Inspector来重现错误，并与Supabase支持部门分享这些连接细节。&#xA;后端日志 link如果你的项目被限制了速率，请检查你的Realtime logs。&#xA;WebSocket错误 link tenant_events。如果你的项目每秒产生太多的消息，客户将被断开连接。supabase-js应该在消息率降低到你的计划限制以下时自动重新连接。 一些限制会导致通道加入被拒绝。Realtime将以下列WebSocket消息之一作为答复：&#xA;too_many_channels：目前有太多的频道加入到一个客户端。 too_many_connections: 一个项目有太多的并发连接。 too_many_joins: 每秒有太多的频道加入。 info&#xD;使用浏览器的开发工具查找WebSocket启动请求并查看单个消息。&#xA;有效载荷的限制 link实时的信息字节大小限制为1兆字节。&#xA;Presence的局限性 link实时Presence是一个基于Phoenix Presence的CRDT支持的内存键值存储。更新一个Presence比广播一个消息更昂贵。&#xA;以下限制适用于Presence消息：&#xA;每个对象有10个键 消息速率限制是你的实时消息速率限制的10%。 </description>
    </item>
  </channel>
</rss>
