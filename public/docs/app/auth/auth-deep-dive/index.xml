<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>深层探索 on My New Hugo Site</title>
    <link>https://github.com/docs/app/auth/auth-deep-dive/</link>
    <description>Recent content in 深层探索 on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Dec 2023 17:39:49 +0800</lastBuildDate>
    <atom:link href="https://github.com/docs/app/auth/auth-deep-dive/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>第一部分:JWTS</title>
      <link>https://github.com/docs/app/auth/auth-deep-dive/auth-deep-dive-jwts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/docs/app/auth/auth-deep-dive/auth-deep-dive-jwts/</guid>
      <description>关于 link对JWTs的介绍以及它们在Supabase Auth中的使用方法&#xA;观察 link 什么是JSON网络令牌（JWTs）？ linkJWT是JSON对象，经过编码和签名，以字符串的形式发送。它们被分发给服务或网站的用户，用户随后可以向网站或服务展示JWT，作为他们有权访问某些内容的证明。&#xA;当我们说 编码和 签名时，到底是什么意思？&#xA;JSON对象开始时看起来像这样。&#xA;{ &amp;#34;sub&amp;#34;: &amp;#34;0001&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Sam Vimes&amp;#34;, &amp;#34;iat&amp;#34;: 1516239022, &amp;#34;exp&amp;#34;: 1518239022 } sub是 主题，通常是用户的UUID。name是不言自明的，iat是创建令牌的Unix时间戳。许多JWT也会有一个exp，这是该令牌被设定为过期而不能再使用的日期。这些是你可能在JWT中发现的一些标准字段，但你几乎可以在其中存储任何你想要的东西，例如。&#xA;{ &amp;#34;sub&amp;#34;: &amp;#34;0002&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;Věra Hrabánková&amp;#34;, &amp;#34;iat&amp;#34;: 1516239022, &amp;#34;exp&amp;#34;: 1518239022, &amp;#34;theme&amp;#34;: { &amp;#34;primary&amp;#34; : &amp;#34;#D80C14&amp;#34;, &amp;#34;secondary&amp;#34; : &amp;#34;#FFFFFF&amp;#34; } } 只需注意，你在令牌中存储的数据越多，编码后的字符串就越长。&#xA;当我们想把JWT发送给用户时，我们首先用一种算法对数据进行编码，如HS256。有许多库（和几种不同的算法）可以用来做这种编码/解码，例如jsonwebtoken。我做了一个副本这里，所以你可以自己试试。签名的方法很简单。&#xA;// from https://replit.com/@awalias/jsonwebtokens#index.js let token = jwt.sign({ name: &amp;#39;Sam Vimes&amp;#39; }, &amp;#39;some-secret&amp;#39;) 而产生的字符串将看起来像这样。&#xA;eyJhbGciOiJIUzI1NiJ9 .eyJzdWIiOiIwMDAxIiwibmFtZSI6IlNhbSBWaW1lcyIsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjoxNTE4MjM5MDIyfQ .zMcHjKlkGhuVsiPIkyAkB2rjXzyzJsMMgpvEGvGtjvA 你会注意到，这个字符串实际上是由三个部分组成的，我们将逐一解决这个问题。&#xA;第一段eyJhbGciOiJIUzI1NiJ9被称为 头，在解码时只是告诉我们用哪种算法来做编码。&#xA;{ &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34; } 第二段eyJzdWIiOiIwMDAxIiwibmFtZSI6IlNhbSBWaW1lcyIsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjoxNTE4MjM5MDIyfQ包含我们的原始有效载荷。</description>
    </item>
    <item>
      <title>第二部分:行级安全</title>
      <link>https://github.com/docs/app/auth/auth-deep-dive/auth-row-level-security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/docs/app/auth/auth-deep-dive/auth-row-level-security/</guid>
      <description>关于 link了解如何通过启用行级安全和在Supabase仪表板中编写Postgres策略来限制对数据库表的访问。&#xA;观察 link 确保你的数据表安全 link在Supabase中，你可以直接从客户端（通常是网络浏览器）访问你的数据，你可以这样做，把你的Supabase URL和Anon密钥传递给supabase-js：&#xA;const supabase = createClient( &amp;#39;https://qwertyuiop.supabase.co&amp;#39;, &amp;#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c&amp;#39; ) 然而，这引起了一个有趣的问题：&amp;ldquo;如果我的匿名密钥在客户端，那么就不会有人阅读我的javascript并窃取我的密钥吗？&amp;quot;，答案是肯定的。而这正是Postgres策略的作用所在。&#xA;使用Postgres的 行级安全策略，我们可以对匿名钥匙默认允许或不允许访问的数据设置规则。&#xA;例如，我们可以说匿名钥匙只能从一个特定的表中读取，但不能写入、更新或删除。&#xA;而且这些规则可以随我们的意愿而复杂。我们可以说，匿名键只能删除在星期四下午4点到6点之间插入的行，并且id列是偶数。很奇怪，但它显示了策略的力量。&#xA;比方说，我们创建了一个排行榜表。我们希望网站上的人能够阅读排行榜，但不能写入、更新或删除它。我们首先在SQL中定义我们的表并添加一些假数据：&#xA;create table leaderboard ( name text, score int ); insert into leaderboard(name, score) values (&amp;#39;Paul&amp;#39;, 100), (&amp;#39;Leto&amp;#39;, 50), (&amp;#39;Chani&amp;#39;, 200); 现在让我们设置一个客户端来读取数据，我在这里创建了一个副本来展示一个活生生的例子。https://replit.com/@awalias/supabase-leaderboard-demo#index.js。如果你复制这个片段，你可以插入你自己的Supabase URL和anon key。&#xA;你可以看到，通过使用，可以自由地从表中读取和写入。&#xA;// Writing let { data, error } = await supabase.from(&amp;#39;leaderboard&amp;#39;).insert({ name: &amp;#39;Bob&amp;#39;, score: 99999 }) // Reading let { data, error } = await supabase .from(&amp;#39;leaderboard&amp;#39;) .</description>
    </item>
    <item>
      <title>第三部分:政策</title>
      <link>https://github.com/docs/app/auth/auth-deep-dive/auth-policies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/docs/app/auth/auth-deep-dive/auth-policies/</guid>
      <description>关于 link如何将表的访问限制在认证用户、行级策略和基于电子邮件域的访问。&#xA;观察 link 基于用户的行级策略 link现在我们知道了如何根据JWT角色来限制对表的访问，我们可以把它和用户管理结合起来，让我们更多地控制你的用户可以从你的数据库中读取和写入哪些数据。&#xA;我们将从用户会话在Supabase中的工作方式开始，然后转到编写以用户为中心的策略。&#xA;比方说，我们要把一个用户第一次注册到我们的服务中。典型的方法是在supabase-js中调用以下方法：&#xA;// see full api reference here: /docs/app/sdkdocs/javascript/auth-signup supabase.auth.signUp({ email, password }) 默认情况下，这将向用户发送一封确认电子邮件。当用户点击电子邮件中的链接时，他们将被重定向到你的网站（你需要在仪表板上的授权&amp;gt;设置中提供你的网站网址。默认情况下，这是http://localhost:3000），包括查询参数的完整URL将看起来像这样:&#xA;http://localhost:3000/#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjE2NDI5MDY0LCJzdWIiOiI1YTQzNjVlNy03YzdkLTRlYWYtYThlZS05ZWM5NDMyOTE3Y2EiLCJlbWFpbCI6ImFudEBzdXBhYmFzZS5pbyIsImFwcF9tZXRhZGF0YSI6eyJwcm92aWRlciI6ImVtYWlsIn0sInVzZXJfbWV0YWRhdGEiOnt9LCJyb2xlIjoiYXV0aGVudGljYXRlZCJ9.4IFzn4eymqUNYYo2AHLxNRL8m08G93Qcg3_fblGqDjo&amp;amp;expires_in=3600&amp;amp;refresh_token=RuioJv2eLV05lgH5AlJwTw&amp;amp;token_type=bearer&amp;amp;type=signup 让我们把这个问题拆开，以便更容易阅读。&#xA;// 基本网址 - 你在app.supabase.com仪表板的授权设置中设置的任何网址 http://localhost:3000/ // 注意我们使用&amp;#39;#&amp;#39;（片段）而不是&amp;#39;?&amp;#39;查询参数 // 访问令牌是发给用户的JWT。 #access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjE2NDI5MDY0LCJzdWIiOiI1YTQzNjVlNy03YzdkLTRlYWYtYThlZS05ZWM5NDMyOTE3Y2EiLCJlbWFpbCI6ImFudEBzdXBhYmFzZS5pbyIsImFwcF9tZXRhZGF0YSI6eyJwcm92aWRlciI6ImVtYWlsIn0sInVzZXJfbWV0YWRhdGEiOnt9LCJyb2xlIjoiYXV0aGVudGljYXRlZCJ9.4IFzn4eymqUNYYo2AHLxNRL8m08G93Qcg3_fblGqDjo // 默认情况下，60分钟内有效 &amp;amp;expires_in=3600 // 用来在60分钟到期前获得新的访问令牌 &amp;amp;refresh_token=RuioJv2eLV05lgH5AlJwTw // 可以作为授权:在对你的API的请求中使用Bearer header &amp;amp;token_type=bearer // 这是一个注册、登录、密码重置或magic link? &amp;amp;type=signup 如果我们把access_token放入https://jwt.io，我们会看到它被解码为:&#xA;{ &amp;#34;aud&amp;#34;: &amp;#34;authenticated&amp;#34;, &amp;#34;exp&amp;#34;: 1616429064, &amp;#34;sub&amp;#34;: &amp;#34;5a4365e7-7c7d-4eaf-a8ee-9ec9432917ca&amp;#34;, &amp;#34;email&amp;#34;: &amp;#34;ant@supabase.io&amp;#34;, &amp;#34;app_metadata&amp;#34;: { &amp;#34;provider&amp;#34;: &amp;#34;email&amp;#34; }, &amp;#34;user_metadata&amp;#34;: {}, &amp;#34;role&amp;#34;: &amp;#34;authenticated&amp;#34; } authenticated角色在Supabase中很特别，它告诉API这是一个已认证的用户，并知道将JWT与你添加到请求的资源（表或行）的任何策略进行比较。&#xA;sub声称通常是我们用来将JWT与你数据库中的行相匹配的，因为默认情况下它是auth.users表中用户的唯一标识符（作为附带说明&amp;ndash;一般不建议以任何方式改变你Supabase数据库中的auth模式，因为Auth API依靠它来正常运行）。&#xA;对于好奇心强的人来说，可以尝试进入SQL编辑器并进行查询：</description>
    </item>
    <item>
      <title>第四部分: GoTrue</title>
      <link>https://github.com/docs/app/auth/auth-deep-dive/auth-gotrue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/docs/app/auth/auth-deep-dive/auth-gotrue/</guid>
      <description>关于 link如何将表的访问限制在认证用户、行级策略和基于电子邮件域的访问。&#xA;观察 link Gotrue Server linkGotrue是一个由Netlify团队用Go编写的认证API服务器，在这里可以找到Supabase的分叉：https://github.com/supabase/gotrue 可用的API端点列表可在这里。&#xA;当你部署一个新的Supabase项目时，我们会在你的数据库旁边部署一个新的服务器实例，同时也为你的数据库注入所需的auth模式。&#xA;这使得它非常容易，例如，发送神奇的链接电子邮件，你的用户可以用它来登录:&#xA;# replace &amp;lt;project-ref&amp;gt; with your own project reference # and SUPABASE_KEY with your anon api key curl -X POST &amp;#39;https://&amp;lt;project-ref&amp;gt;.supabase.co/auth/v1/magiclink&amp;#39; \ -H &amp;#34;apikey: SUPABASE_KEY&amp;#34; \ -H &amp;#34;Content-Type: application/json&amp;#34; \ -d &amp;#39;{ &amp;#34;email&amp;#34;: &amp;#34;someone@email.com&amp;#34; }&amp;#39; Gotrue负责为你的用户发放访问令牌，发送确认邮件、魔法链接和密码恢复邮件（默认情况下，我们从Supabase的SMTP服务器发送这些邮件，但你可以在仪表板的Auth &amp;gt; Settings中轻松插入你自己的邮件），也可以与第三方OAuth提供商进行交易，获得基本的用户数据。&#xA;如果你的用户需要与供应商进行更密切的互动，社区最近甚至还内置了请求自定义OAuth范围的功能。请看这里的scopes参数。https://github.com/supabase/gotrue#get-authorize。&#xA;因此，假设你想通过gmail代表用户发送电子邮件，你可能会请求gmail.send范围，把他们引导到：&#xA;https://sjvwsaokcugktsdaxxze.supabase.co/auth/v1/authorize?provider=google&amp;amp;https://www.googleapis.com/auth/gmail.send 当然，你必须确保你的谷歌应用经过验证，以便申请这些高级范围。&#xA;Gotrue-js (还有 gotrue-csharp, gotrue-py, gotrue-kt, 和 gotrue-dart) 都是对Getrue API端点的封装，使你的客户端更容易进行会话管理。&#xA;但是gotrue-js的所有功能在supabase-js中也是可用的，当你做一些事情时，supabase-js在内部使用gotrue-js。&#xA;const { user, session, error } = await supabase.auth.signIn({ email: &amp;#39;example@email.</description>
    </item>
    <item>
      <title>第五部分: Google Oauth</title>
      <link>https://github.com/docs/app/auth/auth-deep-dive/auth-google-oauth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/docs/app/auth/auth-deep-dive/auth-google-oauth/</guid>
      <description>About link如何在 Supabase 应用程序中添加 Google OAuth 登录。&#xA;Watch link 使用外部 OAuth 提供商登录 link连接社交登录（如 Google、GitHub 或 Facebook）再简单不过了。在本指南中，我们将指导你完成连接 Google 的过程，但这一过程对所有提供商都基本相同，其中包括：Azure、Bitbucket、Github、Gitlab、Facebook 和 Google。&#xA;首先，你需要在他们的云控制台中创建一个谷歌项目，在其他提供商中，他们可能将此称为 &amp;ldquo;应用程序&amp;rdquo;，通常可在公司的开发人员门户网站上获得。&#xA;有了项目后，在搜索栏中输入 &amp;ldquo;OAuth&amp;rdquo;，然后打开 &amp;ldquo;OAuth 同意界面&amp;rdquo;。&#xA;选择 &amp;ldquo;外部&amp;rdquo;，然后填写其余表格字段&#xA;接下来打开左侧的证书页面&#xA;然后点击 &amp;ldquo;创建一组新凭证&amp;rdquo;，选择 &amp;ldquo;OAuth 客户端 ID &amp;ldquo;作为选项。n&#xA;现在选择 Web 应用程序（假设您创建的是 Web 应用程序），然后在授权重定向 URI 部分添加：https://&amp;lt;your-ref&amp;gt;.supabase.co/auth/v1/callback。你可以在 Supabase 面板内的设置 &amp;gt; API 中找到你的 Supabase URL。&#xA;现在，您可以从弹出窗口获取客户 ID 和秘密，并将它们插入 Supabase 面板中的 &amp;ldquo;认证&amp;rdquo;&amp;gt;&amp;ldquo;设置 &amp;ldquo;的谷歌部分：&#xA;点击保存。现在你应该可以在浏览器中导航到&#xA;https://&amp;lt;your-ref&amp;gt;.supabase.co/auth/v1/authorize?provider=google 然后使用任何谷歌或 Gmail 账户登录您的服务。&#xA;例如，您还可以在 URL 末尾添加查询参数 redirect_to= ：&#xA;https://&amp;lt;your-ref&amp;gt;.supabase.co/auth/v1/authorize?provider=google&amp;amp;redirect_to=http://localhost:3000/welcome 但请确保您在此输入的 URL 与您在 Supabase 面板上的 &amp;ldquo;认证&amp;rdquo;&amp;gt;&amp;ldquo;设置 &amp;ldquo;页面中输入的网站 URL 位于同一主机上。(即将推出其他功能，您可以在允许列表中添加其他 URL）。</description>
    </item>
  </channel>
</rss>
