<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Dec 2023 17:39:49 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>文档中心</title>
      <link>http://localhost:1313/docs/overview/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/overview/</guid>
      <description>欢迎来到MemFire Cloud文档中心！我们为您提供丰富的操作指南和详细的参考资料，帮助您轻松上手MemFire Cloud产品，顺利完成基于数据库的应用开发～&#xA;MemFire Cloud云数据库 linkMemFire Cloud致力于提供一站式数据库自助服务，隐藏复杂、专业的工作（比如：复杂的配置、数据库扩展、备份、运维等），实现开箱即用、按需使用、动态扩容、运维托管。&#xA;云数据库文档&#xA;查看MemFire Cloud云数据库产品的全部文档&#xA;云数据库快速上手&#xA;快速了解和使用MemFire Cloud云数据库&#xA;各种开发语言样例&#xA;使用MemFire Cloud云数据库和各种开发语言来构建一个简单的CURD应用程序&#xA;MemFire Cloud应用开发 linkMemFire Cloud推出的基于Supabase与MemFireDB打造的一站式后端服务，为应用开发者提供云数据库、云存储、自动生成API、用户认证与授权、静态托管等功能，加速移动/Web/IoT/游戏等应用的开发，并降低运维成本。&#xA;应用开发文档&#xA;查看MemFire Cloud应用开发产品的全部文档&#xA;应用开发快速上手&#xA;快速体验和上手MemFire Cloud应用开发&#xA;开发应用样例&#xA;学习应用样例，快速构建一个应用</description>
    </item>
    <item>
      <title>产品介绍</title>
      <link>http://localhost:1313/docs/app/overview/productintro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/overview/productintro/</guid>
      <description>MemFire Cloud应用是一个后端即服务平台，采用开源的Supabase。它旨在帮助开发人员更轻松地构建小程序、移动应用、WEB网站。能够缩短开发周期，降低开发和运维成本。&#xA;用户 linkMemFire Cloud的期望用户是开发工程师、创业IT团队、中小企业、以及编程爱好者。我们希望您熟悉一门前端框架，以便更好地体验到我们产品的便利性。如果您不熟悉前端及后端的编程业务，我们也提供了详细的文档说明和简单易实现的案例供您参考，以便更好地体验到我们产品的闭环业务。&#xA;适用场景 linkMemFire Cloud提供了丰富的功能和易于使用的接口，有着广泛的应用场景。&#xA;购物平台 ：电商小程序、团购小程序等，商品信息对象存储，用户互动拼团，下单支付、客服聊天等场景 实用类工具 ：投票工具、网盘、文件共享、团队协作工具、各种创意插件等 互动小游戏 ：基于数据库、实时数据库、自动生成API等能力，实现在线棋牌、角色扮演、益智类等小游戏 社交类应用 ：聊天、交友、相亲类型的APP/网站/小程序，支持用户互动，存储文字、图片、视频、聊天信息等 全栈网站 ：结合云数据库、云函数等能力+静态托管托管，实现带有后台服务端的全栈网站 管理后台 ：采用MemFire Cloud应用开发+refine实现管理后台 产品价值 link 简化开发 ：Memfire Cloud提供了提供了数据库和身份验证、云函数、自动api等核心功能，使开发人员能够轻松构建出功能丰富的应用程序，从而缩短开发周期。 实时性能 ：Memfire Cloud利用PG数据库的逻辑复制功能，实现了实时数据同步，确保应用程序可以实时响应数据库的变化。 开放性和灵活性 ：基于开源项目supabase，Memfire Cloud有JavaScript、flutter、微信小程序SDK可供使用，以适应不同的业务需求。 可扩展性和可靠性 ：Memfire Cloud的基础设施构建在阿里云平台之上，具有高度的可扩展性和可靠性，可以满足各种规模的应用程序需求。 功能 linkMemFire Cloud提供了丰富的功能，帮助程序开发者快速构建应用程序。&#xA;Postgre数据库&amp;amp;自动API生成 对象存储 实时数据库 云函数 认证授权 静态托管 表编辑器&amp;amp;SQL编辑器 权限管理 适用框架 linkMemFire Cloud是基于Postgres数据库，这使得它兼容许多前端框架。&#xA;Angular Vue Flutter React 微信小程序 </description>
    </item>
    <item>
      <title>前端框架的脚手架</title>
      <link>http://localhost:1313/docs/app/example/scaffold/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/example/scaffold/</guid>
      <description>MemFire Cloud提供了全面的前端框架的脚手架，包括vue/react/uni-app微信小程序/taro微信小程序/微信原生小程序。脚手架的功能和页面包括登录注册、个人中心、备忘录、聊天室、文件管理中心，也分别代表了MemFire Cloud不同的特性，其中包括用户认证、自动生成API、实时数据库、对象存储。&#xA;脚手架提供一套基础的MemFire Cloud项目结构和配置，旨在以加快和简化项目的开发过程，不仅可以帮助用户快速启动项目、规范开发流程，集成常用工具和底层框架，并具有一定的定制性和扩展性，提高开发效率和代码质量，为用户提供全面的服务。&#xA;不同前端框架的项目代码&#xA;React link&#xD;npx create-react-app --template memfire-react-template &amp;lt;your_project_name&amp;gt;&#xD;Vue link&#xD;vue create --preset memfire-cloud/memfire-vue-tempalte &amp;lt;your_project_name&amp;gt;&#xD;原生微信小程序模版 link&#xD;npx degit MemFire-Cloud/wechat-template &amp;lt;my-project&amp;gt;&#xD;uni-app微信小程序模版 link&#xD;npx degit MemFire-Cloud/uni-app-template &amp;lt;my-project&amp;gt;&#xD;taro微信小程序模版 link&#xD;npx degit MemFire-Cloud/memfire-taro-template &amp;lt;my-project&amp;gt;&#xD;根据项目的readme文件里的提示，在MemFire Cloud创建应用后，将提供的sql脚本在该应用的SQL执行器里执行。&#xA;再将应用的anon_key和URL添加到对应项目的supabaseClient.js文件里，最后查看项目是否有node_modules包管理器文件夹，如果没有就执行npm install，最后就可以运行项目了。</description>
    </item>
    <item>
      <title>JavaScript库</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/start/javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/start/javascript/</guid>
      <description>@supabase/supabase-js 是 Supabase 官方提供的一个同构 JavaScript 库，MemFire Cloud采用了开源了 Supabase 项目。&#xA;这里详细记录了该库中的所有对象和方法。&#xA;通过使用 supabase-js，你可以实现如下功能：&#xA;与你的 Postgres 数据库进行交互 监听数据库变化 调用 Postgres 函数 构建登录和用户管理功能 管理大文件 相关链接 link 源代码 TypeDoc NPM 已知的错误和问题 </description>
    </item>
    <item>
      <title>初始化客户端</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/start/initializing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/start/initializing/</guid>
      <description>你可以使用 createClient() 方法初始化一个新的 Supabase 客户端。&#xA;Supabase 客户端是你访问 Supabase 其他功能的入口是与我们在 Supabase 生态系统中提供的所有功能进行交互的最简单方法。&#xA;案例教程 link案例1 （createClient()） link&#xD;使用方法&#xD;如果密码超过72个字符，它将被截断为前72个字符。&#xA;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;// Create a single supabase client for interacting with your database&#xD;const supabase = createClient(&amp;#39;https://xyzcompany.supabase.co&amp;#39;, &amp;#39;public-anon-key&amp;#39;)&#xD;使用自定义域名：&#xA;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;// Use a custom domain as the supabase URL&#xD;const supabase = createClient(&amp;#39;https://my-custom-domain.com&amp;#39;, &amp;#39;public-anon-key&amp;#39;)&#xD;案例2 （带附加参数的情况） link&#xD;使用方法&#xD;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;const options = {&#xD;db: {&#xD;schema: &amp;#39;public&amp;#39;,&#xD;},&#xD;auth: {&#xD;autoRefreshToken: true,&#xD;persistSession: true,&#xD;detectSessionInUrl: true&#xD;},&#xD;global: {&#xD;headers: { &amp;#39;x-my-custom-header&amp;#39;: &amp;#39;my-app-name&amp;#39; },&#xD;},&#xD;}&#xD;const supabase = createClient(&amp;#34;https://xyzcompany.</description>
    </item>
    <item>
      <title>初始化客户端</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/initializing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/initializing/</guid>
      <description>你可以使用 createClient() 方法初始化一个新的 Supabase 客户端。&#xA;Supabase 客户端是你访问 Supabase 其他功能的入口是与我们在 Supabase 生态系统中提供的所有功能进行交互的最简单方法。&#xA;案例教程 link案例1 （createClient()） link&#xD;使用方法&#xD;如果密码超过72个字符，它将被截断为前72个字符。&#xA;import { createClient } from &amp;#39;supabase-wechat-stable-v2&amp;#39;&#xD;// Create a single supabase client for interacting with your database&#xD;const supabase = createClient(&amp;#39;https://xyzcompany.supabase.co&amp;#39;, &amp;#39;public-anon-key&amp;#39;)&#xD;使用自定义域名：&#xA;import { createClient } from &amp;#39;supabase-wechat-stable-v2&amp;#39;&#xD;// Use a custom domain as the supabase URL&#xD;const supabase = createClient(&amp;#39;https://my-custom-domain.com&amp;#39;, &amp;#39;public-anon-key&amp;#39;)&#xD;案例2 （带附加参数的情况） link&#xD;使用方法&#xD;import { createClient } from &amp;#39;supabase-wechat-stable-v2&amp;#39;&#xD;const options = {&#xD;db: {&#xD;schema: &amp;#39;public&amp;#39;,&#xD;},&#xD;auth: {&#xD;autoRefreshToken: true,&#xD;persistSession: true,&#xD;detectSessionInUrl: true&#xD;},&#xD;global: {&#xD;headers: { &amp;#39;x-my-custom-header&amp;#39;: &amp;#39;my-app-name&amp;#39; },&#xD;},&#xD;}&#xD;const supabase = createClient(&amp;#34;https://xyzcompany.</description>
    </item>
    <item>
      <title>安装</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/start/installing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/start/installing/</guid>
      <description>所有的 JavaScript 库都是由 Supabase 团队直接建立的。其他语言由社区构建，并由 Supabase 支持。&#xA;通过终端安装 link你可以通过在终端中执行相应的安装命令来完成@supabase/supabase-js库的安装。&#xA;为你提供两种终端安装的方式（NPM 和 Yarn）：&#xA;@supabase/supabase-js link使用NPM安装&#xA;npm install @supabase/supabase-js&#xD;使用Yarn安装&#xA;yarn add @supabase/supabase-js&#xD;通过CDN安装 link您可以通过 CDN 链接安装 @supabase/supabase-js。&#xA;&amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&#xD;//or&#xD;&amp;lt;script src=&amp;#34;https://unpkg.com/@supabase/supabase-js@2&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&#xD;CDN是内容分发网络（Content Delivery Network）的缩写。它是一种用于加速网络资源传输的系统，通过将数据和文件分布在全球各地的多个服务器节点上，使用户可以从离自己地理位置较近的服务器获取所需的内容，从而提高网页加载速度和响应时间。&#xA;Supabase提供了一个通过CDN链接安装 @supabase/supabase-js 的选项。这意味着你可以通过在你的HTML文件中引入相关的CDN链接，来直接使用Supabase的JavaScript客户端库，而无需通过npm或其他包管理工具进行安装。这样做的好处是，当用户访问你的网页时，他们可以从离他们最近的CDN服务器加载Supabase的库，从而更快地获得响应。&#xA;相关链接 link在GitHub上查找源代码。</description>
    </item>
    <item>
      <title>微信小程序库</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/javascript/</guid>
      <description>supabase-wechat-stable-v2 是 MemFire Cloud 官方提供的一个同构微信小程序库库，MemFire Cloud采用了开源了 Supabase 项目的JavaScript库改造而成。&#xA;这里详细记录了该库中的所有对象和方法。&#xA;通过使用 supabase-js，你可以实现如下功能：&#xA;与你的 Postgres 数据库进行交互 监听数据库变化 调用 Postgres 函数 构建登录和用户管理功能 管理大文件 相关链接 link 源代码 NPM 已知的错误和问题 </description>
    </item>
    <item>
      <title>版本说明</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/start/release-notes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/start/release-notes/</guid>
      <description>Supabase.js是Supabase数据库服务的官方JavaScript客户端库，用于与Supabase API进行交互。 最新版本Supabase.js v2带来了一系列令人振奋的新特性、更新和改进，使开发者在构建现代Web应用程序时拥有更加强大和灵活的工具。&#xA;让我们深入了解这些新功能，并看看它们如何改进您的Supabase体验！接下来，我们将逐步探索Supabase.js v2的亮点和特性，帮助您更好地了解这个新版本。&#xA;首先需要用npm install @supabase/supabase-js安装最新版本。&#xA;明确的构造器选项 link构造函数中的所有客户端特定选项都是键入库的。&#xA;const supabase = createClient(apiURL, apiKey, {&#xD;db: {&#xD;schema: &amp;#39;public&amp;#39;,&#xD;},&#xD;auth: {&#xD;storage: AsyncStorage,&#xD;autoRefreshToken: true,&#xD;persistSession: true,&#xD;detectSessionInUrl: true,&#xD;},&#xD;realtime: {&#xD;channels,&#xD;endpoint,&#xD;},&#xD;global: {&#xD;fetch: customFetch,&#xD;headers: DEFAULT_HEADERS,&#xD;},&#xD;})&#xD;支持typescript link这些库现在支持typescript。&#xA;// v2 - definitions are injected in `createClient()`&#xD;import type { Database } from &amp;#39;./DatabaseDefinitions&amp;#39;&#xD;const supabase = createClient&amp;lt;Database&amp;gt;(SUPABASE_URL, ANON_KEY)&#xD;const { data } = await supabase.</description>
    </item>
    <item>
      <title>支持Typescript</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/start/typescript-support/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/start/typescript-support/</guid>
      <description>supabase-js支持Typescript。&#xA;生成类型 link你可以使用我们的CLI来生成类型。&#xA;supabase start&#xD;supabase gen types typescript --local &amp;gt; lib/database.types.ts&#xD;这些类型是直接从你的数据库中生成的。给定一个表public.movies，该定义将提供以下数据。&#xA;interface Database {&#xD;public: {&#xD;Tables: {&#xD;movies: {&#xD;Row: {} // The data expected to be returned from a &amp;#34;select&amp;#34; statement.&#xD;Insert: {} // The data expected passed to an &amp;#34;insert&amp;#34; statement.&#xD;Update: {} // The data expected passed to an &amp;#34;update&amp;#34; statement.&#xD;}&#xD;}&#xD;}&#xD;}&#xD;在 &amp;ldquo;选择&amp;rdquo;、&amp;ldquo;插入 &amp;ldquo;和 &amp;ldquo;更新 &amp;ldquo;之间是有区别的，因为通常你会在数据库中为特定的列设置默认值。 有了默认值，你就不需要通过网络发送任何数据，即使该列是一个 &amp;ldquo;必填 &amp;ldquo;字段。我们的类型系统是精细的 足以处理这些情况。</description>
    </item>
    <item>
      <title>signUp()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signup/</guid>
      <description>创建一个新的用户。&#xA;默认情况下，用户在登录之前需要验证他们的电子邮件地址。要关闭此功能，请在您的项目中禁用 确认电子邮 选项。&#xA;确认电子邮件 决定用户在注册后是否需要确认他们的电子邮件地址。&#xA;如果启用了 确认电子邮件 ，将返回一个用户对象，但会话 (session) 为空。&#xA;如果禁用了 确认电子邮 ，将返回一个用户对象和一个会话 (session)。&#xA;当用户确认他们的电子邮件地址时，默认情况下会重定向到 SITE_URL。您可以在项目中修改 SITE_URL 或在你的项目中添加其他重定向 URL。&#xA;如果对已确认的现有用户调用 signUp()：&#xA;如果您的项目中启用了 确认电子邮件 ，将返回一个混淆的（假的）的用户对象。 如果禁用了 确认电子邮件 ，将返回错误消息用户已注册。 要获取当前已登录的用户，请参阅 getUser() 方法。 案例教程 link案例1 （注册） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signUp({&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;})&#xD;如果密码超过72个字符，它将被截断为前72个字符。&#xA;案例2 （使用附加用户元数据进行注册） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.signUp(&#xD;{&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;options: {&#xD;data: {&#xD;first_name: &amp;#39;John&amp;#39;,&#xD;age: 27,&#xD;}&#xD;}&#xD;}&#xD;)&#xD;案例3 （使用重定向URL进行注册） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>signInWithOtp()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signinwithotp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signinwithotp/</guid>
      <description>使用魔法链接（Magiclink）或一次性密码（OTP）登录用户，需要提供电子邮件或手机号码中的任意一种。&#xA;这个方法用于无需密码的登录，其中一次性密码（OTP）将发送到用户的电子邮件或手机号码。 如果用户不存在，signInWithOtp() 将代替其进行用户注册。要限制此行为，您可以将 SignInWithPasswordlessCredentials.options 中的 shouldCreateUser 设置为 false。&#xA;如果您使用电子邮件，您可以配置是否要向用户发送魔法链接或一次性密码（OTP）。&#xA;如果您使用手机号码，您可以配置是否要向用户发送一次性密码（OTP）。&#xA;魔法链接的目标URL由 SITE_URL 决定。请查看重定向URL和通配符以向您的项目添加其他重定向URL。&#xA;魔法链接和OTP共享相同的实现。若要向用户发送一次性密码（OTP）而不是魔法链接，请修改魔法链接的电子邮件模板，将 {{ .ConfirmationURL }} 替换为 {{ .Token }}。&#xA;案例教程 link案例1 （使用电子邮件登录） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signInWithOtp({&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;options: {&#xD;emailRedirectTo: &amp;#39;https://example.com/welcome&amp;#39;&#xD;}&#xD;})&#xD;用户将收到一封电子邮件，其中包含魔法链接或者一次性密码（OTP）亦或是两者都有。默认情况下，同一用户在60秒内只能请求一次一次性密码（OTP）。&#xA;案例2 （使用短信OTP登陆） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signInWithOtp({&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;})&#xD;用户将收到一条包含一次性密码（OTP）的短信。默认情况下，同一用户在60秒内只能请求一次一次性密码（OTP）。&#xA;案例3 （使用WhatsApp OTP登录） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>通过 OTP 进行验证和登录</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-verifyotp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-verifyotp/</guid>
      <description>用户通过手机接收到的 OTP（一次性密码） 来登录。&#xA;verifyOtp 方法接受不同的验证类型。如果使用手机号码，类型可以是 sms 或 phone_change。 如果使用电子邮件地址，类型可以是以下之一：email、recovery、invite 或 email_change（signup 和 magiclink 类型已被弃用）。&#xA;应根据在调用 verifyOtp 之前使用的相应身份验证方法来确定使用的验证类型，以便进行用户的注册或登录操作。&#xA;案例教程 link案例1 （验证短信一次性密码） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.verifyOtp({ phone, token, type: &amp;#39;sms&amp;#39;})&#xD;案例2 （验证注册一次性密码） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.verifyOtp({ email, token, type: &amp;#39;signup&amp;#39;})&#xD;参数说明 link&#xD;params&#xD;[必要参数]&#xD;VerifyOtpParams&#xD;</description>
    </item>
    <item>
      <title>updateUser()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-updateuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-updateuser/</guid>
      <description>updateUser()用于更新用户信息，该方法用于更新已登录用户的用户数据。&#xA;使用 updateUser() 方法之前，用户必须先登录。默认情况下，如果对用户的电子邮箱进行更新，这将向用户当前的电子邮箱和新的电子邮箱发送确认链接。 若希望仅向用户的新电子邮箱发送确认链接，请在项目的电子邮箱认证提供程序设置中禁用 Secure email change 选项。这样可以避免同时向当前和新电子邮箱发送确认链接。&#xA;案例教程 link案例1 （更新已认证用户的电子邮件地址） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.updateUser({email: &amp;#39;new@email.com&amp;#39;})&#xD;发送一封“确认电子邮件更改”邮件至新的电子邮件地址。&#xA;案例2 （更新已认证用户的密码） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.updateUser({password: &amp;#39;new password&amp;#39;})&#xD;如果密码超过72个字符，它将被截断为前72个字符。&#xA;案例3 （更新用户的元数据信息） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.updateUser({&#xD;data: { hello: &amp;#39;world&amp;#39; }&#xD;})&#xD;案例4 （使用一次性随机码更新用户的密码） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>getSession()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-getsession/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-getsession/</guid>
      <description>getSession()用于检索会话信息，返回会话，并在必要时进行刷新。这意味着如果需要，会话会被刷新后返回。 如果未检测到会话，返回的会话可能为 空（null），这可能发生在用户未登录或已退出登陆的情况下。&#xA;这个方法用于检索当前的本地会话（即本地存储）。 当会话的访问令牌过期时，该方法会使用刷新令牌来获取一个新的会话。 案例教程 link案例1 （获取会话数据） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.getSession()&#xD;</description>
    </item>
    <item>
      <title>getUser()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-getuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-getuser/</guid>
      <description>getUser()用于获取用户信息，当存在有效会话时，该方法获取当前用户的详细信息。&#xA;与从本地会话获取信息不同，该方法从数据库中获取用户对象的信息。 这个方法非常有用，因为它能够验证用户的访问令牌（JWT）在服务器端是否有效，从而用于检查用户是否已被授权。 建议仅在需要最新的用户数据时使用此方法。对于更快的结果，推荐使用 getSession().session.user。这是因为 getSession().session.user 直接从本地会话获取数据速度较快。而 Retrieve a user 方法需要从数据库中获取数据会稍慢一些。 案例教程 link案例1 （通过当前现有的会话获取已登录的用户信息） link&#xD;使用方法&#xD;const { data: { user } } = await supabase.auth.getUser()&#xD;案例2 （使用自定义访问令牌 jwt 获取已登录的用户信息） link&#xD;使用方法&#xD;const { data: { user } } = await supabase.auth.getUser(jwt)&#xD;参数说明 link&#xD;jwt&#xD;[可选参数]&#xD;string类型&#xD;接收一个可选的访问令牌jwt。如果没有提供jwt，getUser()将试图从当前会话中获取jwt。</description>
    </item>
    <item>
      <title>onAuthStateChange()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-onauthstatechange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-onauthstatechange/</guid>
      <description>onAuthStateChange()用于监听认证事件，接收每次认证事件发生时的通知。&#xA;认证事件类型： SIGNED_IN（登录）、SIGNED_OUT（登出）、TOKEN_REFRESHED（令牌刷新）、USER_UPDATED（用户信息更新）、PASSWORD_RECOVERY（密码恢复） 然而目前使用 onAuthStateChange() 方法在不同的标签页之间无效。 举例来说，在密码重置流程中，如果用户在一个标签页请求密码重置链接，当用户点击链接时，原始的标签页将无法收到SIGNED_IN（登录）和PASSWORD_RECOVERY（密码恢复）事件。 案例教程 link案例1 （监听认证变化） link&#xD;使用方法&#xD;supabase.auth.onAuthStateChange((event, session) =&amp;gt; {&#xD;console.log(event, session)&#xD;})&#xD;案例2 （监听密码恢复事件） link&#xD;使用方法&#xD;supabase.auth.onAuthStateChange((event, session) =&amp;gt; {&#xD;if (event == &amp;#39;PASSWORD_RECOVERY&amp;#39;) {&#xD;console.log(&amp;#39;PASSWORD_RECOVERY&amp;#39;, session)&#xD;// show screen to update user&amp;#39;s password&#xD;showPasswordResetScreen(true)&#xD;}&#xD;})&#xD;案例3 （监听登录） link&#xD;使用方法&#xD;supabase.auth.onAuthStateChange((event, session) =&amp;gt; {&#xD;if (event == &amp;#39;SIGNED_IN&amp;#39;) console.log(&amp;#39;SIGNED_IN&amp;#39;, session)&#xD;})&#xD;案例4 （监听退出登录） link&#xD;使用方法&#xD;supabase.auth.onAuthStateChange((event, session) =&amp;gt; {&#xD;if (event == &amp;#39;SIGNED_OUT&amp;#39;) console.</description>
    </item>
    <item>
      <title>refreshSession()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-refreshsession/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-refreshsession/</guid>
      <description>refreshSession()用于获取新的会话，无论会话是否已过期，都将返回一个新的会话。该方法接受一个可选的当前会话作为参数。如果未传入当前会话，那么 refreshSession() 方法将尝试从 getSession() 方法中获取当前会话。 如果当前会话的刷新令牌无效，将抛出一个错误。&#xA;该方法将刷新并返回一个新的会话，无论当前会话是否已过期。 案例教程 link案例1 （使用当前会话刷新会话） link&#xD;使用方法&#xD;const { data: { user, session }, error } = await supabase.auth.refreshSession()&#xD;案例2 （使用传入的会话刷新会话） link&#xD;使用方法&#xD;const { data: { user, session }, error } = await supabase.auth.refreshSession({ refresh_token })&#xD;参数说明 link&#xD;currentSession&#xD;[可选参数]&#xD;object类型&#xD;当前会话的信息。如果传入了这个参数，则必须包含一个刷新令牌。&#xA;特性&#xD;刷新令牌（refresh_token）&#xD;[必要参数]&#xD;string类型&#xD;</description>
    </item>
    <item>
      <title>resetPasswordForEmail()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-resetpasswordforemail/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-resetpasswordforemail/</guid>
      <description>resetPasswordForEmail() 方法会向一个电子邮件地址发送密码重置请求。&#xA;密码重置流程包含两个主要步骤：1. 允许用户通过密码重置链接登录。2. 更新用户的密码。&#xA;resetPasswordForEmail() 方法仅会向用户的电子邮件发送密码重置链接。若要更新用户的密码，请参阅 updateUser() 方法。&#xA;当密码恢复链接被点击时，会触发一个 SIGNED_IN 和 PASSWORD_RECOVERY 事件。你可以使用 onAuthStateChange() 方法来监听这些事件，并在其上调用一个回调函数。&#xA;当用户点击邮件中的重置链接后，他们将被重定向回您的应用程序。您可以通过 redirectTo 参数配置用户重定向的URL。请参阅重定向URL和通配符，以添加其他重定向URL到您的项目中。&#xA;成功重定向用户后，提示他们输入一个新密码并调用 updateUser() ，使用方法如下：&#xA;const { data, error } = await supabase.auth.updateUser({&#xD;password: new_password&#xD;})&#xD;案例教程 link案例1 （重置密码） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.resetPasswordForEmail(email, {&#xD;redirectTo: &amp;#39;https://example.com/update-password&amp;#39;,&#xD;})&#xD;案例2 （重置密码（React）） link&#xD;使用方法&#xD;/**&#xD;* Step 1: Send the user an email to get a password reset token.&#xD;* This email contains a link which sends the user back to your application.</description>
    </item>
    <item>
      <title>setSession()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-setsession/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-setsession/</guid>
      <description>setSession()函数的主要目的，是用于设置当前会话的会话数据。 当用户登录或进行其他需要会话数据的操作时，可以使用setSession()函数来更新或设置相关的会话信息。&#xA;如果当前会话已过期，setSession()将负责刷新它以获取新的会话 如果当前会话中的刷新令牌或访问令牌无效，将会抛出错误 setSession()函数需要一个刷新令牌作为参数，然后利用这个刷新令牌来获取一个新的会话。刷新令牌是用于更新会话数据的重要凭证。&#xA;刷新令牌是单次使用的，一旦被用来获取新的会话后，就会失效。&#xA;为了保护系统免受重放攻击，所有项目默认启用刷新令牌轮换功能。重放攻击是指攻击者通过重复使用先前获取的令牌来模拟合法用户的行为，从而进行未经授权的操作。&#xA;为了灵活性，MemFire Cloud允许你配置REFRESH_TOKEN_REUSE_INTERVAL，这是一个时间窗口，在这个窗口内，相同的刷新令牌可以在并发或离线问题的情况下多次使用。&#xA;案例教程 link案例1 （刷新对话） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = supabase.auth.setSession({&#xD;access_token,&#xD;refresh_token&#xD;})&#xD;使用 refresh_token 设置会话数据，并返回当前会话状态；若 refresh_token 无效，则返回错误信息。&#xA;参数说明 link&#xD;当前会话（currentSession）&#xD;[必要参数]&#xD;object类型&#xD;当前的会话，它至少包含一个访问令牌和刷新令牌。&#xA;特性&#xD;刷新令牌（refresh_token）&#xD;[必要参数]&#xD;string类型&#xD;访问令牌（access_token）&#xD;[必要参数]&#xD;string类型&#xD;</description>
    </item>
    <item>
      <title>signInWithOAuth()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signinwithoauth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signinwithoauth/</guid>
      <description>通过第三方服务商登录现有的用户。&#xA;该方法用于使用第三方服务商进行登录。&#xA;MemFire Cloud支持许多不同的第三方服务商。&#xA;案例教程 link案例1 （借助第三方服务商登陆） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.signInWithOAuth({&#xD;provider: &amp;#39;github&amp;#39;&#xD;})&#xD;案例2 （使用带有重定向的第三方服务商登录） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signInWithOAuth({&#xD;provider: &amp;#39;github&amp;#39;,&#xD;options: {&#xD;redirectTo: &amp;#39;https://example.com/welcome&amp;#39;&#xD;}&#xD;})&#xD;当第三方服务商成功验证用户后，服务商将用户重定向到redirectTo参数指定的URL。默认情况下，该参数为SITE_URL。调用此方法后不会立即重定向用户。&#xA;请查看重定向URL和通配符以向您的项目添加其他重定向URL。&#xA;案例3 （带有作用域(scopes)的登录） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signInWithOAuth({&#xD;provider: &amp;#39;github&amp;#39;,&#xD;options: {&#xD;scopes: &amp;#39;repo gist notifications&amp;#39;&#xD;}&#xD;})&#xD;const oAuthToken = data.session.provider_token // use to access provider API&#xD;如果你需要从OAuth服务商获取附加数据，你可以在请求中包含一个以空格分隔的作用域（scopes）列表，以获得OAuth服务商令牌。</description>
    </item>
    <item>
      <title>signInWithPassword()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signinwithpassword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signinwithpassword/</guid>
      <description>你可以使用电子邮件和密码或者手机号码和密码来登录已存在的用户账户。登录时必须提供以下其中一种组合：&#xA;电子邮件和密码：输入用户注册时使用的电子邮件地址和相应的密码进行登录。 手机号码和密码：输入用户注册时使用的手机号码和相应的密码进行登录。 案例教程 link案例1 （使用电子邮件和密码登录） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.signInWithPassword({&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;})&#xD;案例2 （使用手机号码和密码登录） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.signInWithPassword({&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;password: &amp;#39;some-password&amp;#39;,&#xD;})&#xD;// After receiving a SMS with a OTP.&#xD;const { data, error } = await supabase.auth.verifyOtp({&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;token: &amp;#39;123456&amp;#39;,&#xD;})&#xD;参数说明 link&#xD;credentials&#xD;[必要参数]&#xD;SignUpWithPasswordCredentials SignUpWithPasswordCredentials是使用密码进行身份验证的一种凭据类型。通常包含以下信息：&#xA;1.email（电子邮件）：用户的电子邮件地址，作为账户的唯一标识符之一。&#xA;2.password（密码）：用户选择的密码，用于以后登录时进行身份验证。&#xA;3.可能还包含其他一些相关的字段，例如用户名、手机号码或其他自定义的用户信息。</description>
    </item>
    <item>
      <title>signOut()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth/auth-signout/</guid>
      <description>在浏览器中，signOut() 方法将会从浏览器会话中移除已登录的用户，并让他们退出登陆。&#xA;清除所有本地存储项，然后触发一个 SIGNED_OUT事件。 为了使用 signOut() 方法，用户首先需要完成登录操作。 案例教程 link案例1 link&#xD;使用方法&#xD;const { error } = await supabase.auth.signOut()&#xD;</description>
    </item>
    <item>
      <title>初始化客户端</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/initializing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/initializing/</guid>
      <description>你可以使用 createClient() 方法初始化一个新的 Supabase 客户端。&#xA;Supabase 客户端是你访问 Supabase 其他功能的入口是与我们在 Supabase 生态系统中提供的所有功能进行交互的最简单方法。&#xA;案例教程 link案例1 （createClient()） link&#xD;使用方法&#xD;&gt;&#xD;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;// Create a single supabase client for interacting with your database&#xD;const supabase = createClient(&amp;#39;https://xyzcompany.supabase.co&amp;#39;, &amp;#39;public-anon-key&amp;#39;)&#xD;使用自定义域名：&#xA;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;// Use a custom domain as the supabase URL&#xD;const supabase = createClient(&amp;#39;https://my-custom-domain.com&amp;#39;, &amp;#39;public-anon-key&amp;#39;)&#xD;案例2 （带附加参数的情况） link&#xD;使用方法&#xD;&gt;&#xD;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;const options = {&#xD;db: {&#xD;schema: &amp;#39;public&amp;#39;,&#xD;},&#xD;auth: {&#xD;autoRefreshToken: true,&#xD;persistSession: true,&#xD;detectSessionInUrl: true&#xD;},&#xD;global: {&#xD;headers: { &amp;#39;x-my-custom-header&amp;#39;: &amp;#39;my-app-name&amp;#39; },&#xD;},&#xD;}&#xD;const supabase = createClient(&amp;#34;https://xyzcompany.</description>
    </item>
    <item>
      <title>Select 查询</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/select/</guid>
      <description>在表(table)或视图(view)上执行 SELECT 查询。&#xA;默认情况下，Supabase项目返回最多1,000行数据。你可以在项目的API设置中更改此设置。建议将其保持较低，以限制意外或恶意请求的负载大小。你可以使用range()查询来对数据进行分页处理。 select()可以与过滤器(Filters)组合使用，用于过滤数据。 select()可以与修饰器(Modifiers)组合使用，用于对数据进行修改。 如果你使用Supabase平台，apikey是一个保留关键字，应避免将其用作列名。 案例教程 link案例1 (获取数据) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 (选择特定列) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>Insert 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/insert/</guid>
      <description>在表（table）或视图（view）执行 INSERT 操作。&#xA;案例教程 link案例1 （创建一个记录） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;const { error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.insert({ id: 1, name: &amp;#39;Denmark&amp;#39; })&#xD;{&#xD;&amp;#34;status&amp;#34;: 201,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Created&amp;#34;&#xD;}&#xD;案例2 （创建一个记录并返回） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.insert({ id: 1, name: &amp;#39;Denmark&amp;#39; })&#xD;.select()&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Denmark&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 201,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Created&amp;#34;&#xD;}&#xD;案例3 （批量创建） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;const { error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>Delete 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/delete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/delete/</guid>
      <description>delete()用于在表（table）或视图（view）执行 DELETE 操作。&#xA;delete() 应始终与过滤器（filter）结合使用，以便定位要删除的项。 如果你在使用 delete() 时带有过滤器，并且启用了RLS（行级安全性），则只会删除通过 SELECT 策略可见的行。请注意，默认情况下没有行可见，因此你需要至少有一个 SELECT/ALL 策略来使行可见。 案例教程 link案例1 （删除记录） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Spain&amp;#39;);&#xD;const { error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.eq(&amp;#39;id&amp;#39;, 1)&#xD;{&#xD;&amp;#34;status&amp;#34;: 204,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;No Content&amp;#34;&#xD;}&#xD;参数说明 link&#xD;选项（option）&#xD;[必要参数]&#xD;object类型&#xD;命名的参数&#xA;特性&#xD;count&#xD;optional&#xD;exact | planned | estimated&#xD;用来计算更新行的计数算法。&#xA;exact:可以精确计算行数，但执行速度较慢。执行 &amp;ldquo;COUNT(*)&amp;ldquo;操作。</description>
    </item>
    <item>
      <title>Update 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/update/</guid>
      <description>在表（table）或视图（view）执行 UPDATE 更新数据操作。&#xA;update() 应该始终与筛选器 (Filters) 结合使用，以便定位您希望更新的项目。 案例教程 link案例1 （更新数据） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Taiwan&amp;#39;);&#xD;const { error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ name: &amp;#39;Australia&amp;#39; })&#xD;.eq(&amp;#39;id&amp;#39;, 1)&#xD;{&#xD;&amp;#34;status&amp;#34;: 204,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;No Content&amp;#34;&#xD;}&#xD;案例2 （更新一个记录并返回） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Singapore&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>Upsert 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/upsert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/upsert/</guid>
      <description>upsert()用于对表（table）或视图（view）执行 UPSERT 操作。&#xA;在关系型数据库中，Upsert是一种结合了&amp;quot;插入（Insert）&amp;ldquo;和&amp;quot;更新（Update）&amp;ldquo;的操作,它允许我们在表或视图上执行插入或更新操作。 通常情况下，当我们想要向数据库中插入一行数据时，我们会使用INSERT语句。 但是，如果该行数据已经存在（通常通过主键来判断），我们可能希望更新该行数据而不是插入重复的数据。&#xA;Upsert通过传递列到onConflict方法，我们可以使用.upsert()来实现以下功能：&#xA;如果不存在具有相应onConflict列的行，则执行等效于.insert()的插入操作。 如果存在具有相应onConflict列的行，则根据ignoreDuplicates的设置执行另一种操作。 需要注意的是，为了使用upsert，必须在values中包含主键。主键是用于唯一标识表中每一行的一列或一组列，确保数据的唯一性和完整性。&#xA;案例教程 link案例1 （Upsert数据） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.upsert({ id: 1, name: &amp;#39;Albania&amp;#39; })&#xD;.select()&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 201,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Created&amp;#34;&#xD;}&#xD;案例2 （批量Upsert数据） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>select()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/db-modifiers-select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/db-modifiers-select/</guid>
      <description>对查询结果执行SELECT。&#xA;默认情况下，.insert(), .update(), .upsert(), 和 .delete()不会返回修改过的记录。通过调用这个方法，修改过的行会返回到data。&#xA;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.upsert({ id: 1, name: &amp;#39;Algeria&amp;#39; })&#xD;.select()&#xD;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.upsert({ id: 1, name: &amp;#39;Algeria&amp;#39; })&#xD;.select()&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 201,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Created&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[可选参数]&#xD;query类型&#xD;要检索的列，用逗号分隔</description>
    </item>
    <item>
      <title>containedBy()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/containedby/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/containedby/</guid>
      <description>该方法仅用于在 jsonb、数组（array）和范围（range）列上进行过滤&#xA;contains()的作用是匹配那些其中每个元素都被包含在指定的值中的行。&#xA;换句话说，在指定列中，给定的数组（array）是匹配出来的记录值的子集&#xA;也就是说，在指定列中，匹配出来的记录的值包含了给定的数组（array）的所有元素。&#xA;案例教程 link案例1 （关于数组列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;classes (&#xD;id int8 primary key,&#xD;name text,&#xD;days text[]&#xD;);&#xD;insert into&#xD;classes (id, name, days)&#xD;values&#xD;(1, &amp;#39;Chemistry&amp;#39;, array[&amp;#39;monday&amp;#39;, &amp;#39;friday&amp;#39;]),&#xD;(2, &amp;#39;History&amp;#39;, array[&amp;#39;monday&amp;#39;, &amp;#39;wednesday&amp;#39;, &amp;#39;thursday&amp;#39;]);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;classes&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.containedBy(&amp;#39;days&amp;#39;, [&amp;#39;monday&amp;#39;, &amp;#39;tuesday&amp;#39;, &amp;#39;wednesday&amp;#39;, &amp;#39;friday&amp;#39;])&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Chemistry&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （关于范围列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>filter()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/filter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/filter/</guid>
      <description>仅匹配满足过滤器条件的行。&#xA;尽管filter()函数是一种通用的筛选方式，但为了代码的可读性和维护性，官方建议优先使用特定的筛选方法，以利用更简洁和直观的筛选语法。 例如，使用eq()、gt()、lt()等特定的筛选方法，可以使查询更加清晰和易于理解。&#xA;filter() 期望您使用原始的 PostgREST语法 来指定过滤器的值。&#xA;.filter(&amp;#39;id&amp;#39;, &amp;#39;in&amp;#39;, &amp;#39;(5,6,7)&amp;#39;) // Use `()` for `in` filter&#xD;.filter(&amp;#39;arraycol&amp;#39;, &amp;#39;cs&amp;#39;, &amp;#39;{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use `cs` for `contains()`, `{}` for array values&#xD;案例教程 link案例1 （和select一起使用） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.filter(&amp;#39;name&amp;#39;, &amp;#39;in&amp;#39;, &amp;#39;(&amp;#34;Algeria&amp;#34;,&amp;#34;Japan&amp;#34;)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （在外部表上） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;create table&#xD;cities (&#xD;id int8 primary key,&#xD;country_id int8 not null references countries,&#xD;name text&#xD;);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Germany&amp;#39;),&#xD;(2, &amp;#39;Indonesia&amp;#39;);&#xD;insert into&#xD;cities (id, country_id, name)&#xD;values&#xD;(1, 2, &amp;#39;Bali&amp;#39;),&#xD;(2, 1, &amp;#39;Munich&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>gt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/gt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/gt/</guid>
      <description>gt()用于查找所有在所述列（column）上的值大于指定值（value）的记录。&#xA;案例教程 link案例1 （使用select） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.gt(&amp;#39;id&amp;#39;, 2)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;当使用保留字作为列名时，需要添加双引号，例如：.gt(&#39;&amp;quot;order&amp;quot;&#39;, 2)&#xA;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>gte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/gte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/gte/</guid>
      <description>gte()用于查找所有在所述列（column）上的值大于或等于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.gte(&amp;#39;id&amp;#39;, 2)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>ilike()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/ilike/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/ilike/</guid>
      <description>ilike()用于查找所有在所述列（column）上的值与提供的 模板（pattern）相符的记录（不区分大小写）。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.ilike(&amp;#39;name&amp;#39;, &amp;#39;%Alba%&amp;#39;)&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;模式（pattern）&#xD;[必要参数]&#xD;string类型&#xD;与之匹配的模式</description>
    </item>
    <item>
      <title>in()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/in/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/in/</guid>
      <description>in_()用于查找所有在指定列（column）上数值存在于指定值列表（arry）中的记录&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.in(&amp;#39;name&amp;#39;, [&amp;#39;Albania&amp;#39;, &amp;#39;Algeria&amp;#39;])&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型数组&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>contains()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/contains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/contains/</guid>
      <description>该方法仅用于在 jsonb、数组（array）和范围（range）列上进行过滤&#xA;contains()的作用是匹配包含指定元素的行。&#xA;换句话说，在指定列中，匹配出来的记录的值是给定数组（array）的子集。&#xA;也就是说，在指定列中，给定的数组（array）包含了匹配出记录的所有元素。&#xA;案例教程 link案例1 （关于数组列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;issues (&#xD;id int8 primary key,&#xD;title text,&#xD;tags text[]&#xD;);&#xD;insert into&#xD;issues (id, title, tags)&#xD;values&#xD;(1, &amp;#39;Cache invalidation is not working&amp;#39;, array[&amp;#39;is:open&amp;#39;, &amp;#39;severity:high&amp;#39;, &amp;#39;priority:low&amp;#39;]),&#xD;(2, &amp;#39;Use better names&amp;#39;, array[&amp;#39;is:open&amp;#39;, &amp;#39;severity:low&amp;#39;, &amp;#39;priority:medium&amp;#39;]);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;users&amp;#39;)&#xD;.select()&#xD;.contains(&amp;#39;tags&amp;#39;, [&amp;#39;is:open&amp;#39;, &amp;#39;severity:high&amp;#39;, &amp;#39;priority:low&amp;#39;]); {&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;title&amp;#34;: &amp;#34;Cache invalidation is not working&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （关于范围列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>is()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/is/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/is/</guid>
      <description>仅匹配列值与指定值相等的行。&#xA;对于非boolean型列，这只与检查column的值是否为NULL有关。 column的值是NULL，通过设置value为null。&#xA;对于boolean型列，你也可以将value设置为true或false，它的行为与 它的行为与.eq()相同。&#xA;案例教程 link案例1 (检查是否为 null) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;null&amp;#39;),&#xD;(2, null);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.is(&amp;#39;name&amp;#39;, null)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;null&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;使用eq()筛选器在过滤null时不起作用。相反，您需要使用is()。&#xA;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;null或者boolean类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>like()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/like/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/like/</guid>
      <description>like()用于查找所有在所述列（column）上的值与提供的 模板（pattern）相符的记录（区分大小写）。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.like(&amp;#39;name&amp;#39;, &amp;#39;%Alba%&amp;#39;)&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;模式（pattern）&#xD;[必要参数]&#xD;string类型&#xD;与之匹配的模式</description>
    </item>
    <item>
      <title>limit()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/limit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/limit/</guid>
      <description>通过count限制查询结果。&#xA;案例教程 link案例1 （使用select） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.limit(1)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （在外键表中） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;create table&#xD;cities (&#xD;id int8 primary key,&#xD;country_id int8 not null references countries,&#xD;name text&#xD;);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;United States&amp;#39;);&#xD;insert into&#xD;cities (id, country_id, name)&#xD;values&#xD;(1, 1, &amp;#39;Atlanta&amp;#39;),&#xD;(2, 1, &amp;#39;New York City&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>lt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/lt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/lt/</guid>
      <description>lt()用于查找所有在所述列（column）上的值小于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.lt(&amp;#39;id&amp;#39;, 2)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>lte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/lte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/lte/</guid>
      <description>lte()用于查找所有在所述列（column）上的值小于或等于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.lte(&amp;#39;id&amp;#39;, 2)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>match()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/match/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/match/</guid>
      <description>仅匹配每个查询(query)键中的列与其关联值相等的行。相当于多个 .eq() 的简写。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.match({ id: 2, name: &amp;#39;Albania&amp;#39; })&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;查询（query）&#xD;[必要参数]&#xD;Record类型&#xD;用于筛选的对象，其中列名作为键映射到它们的筛选值。</description>
    </item>
    <item>
      <title>maybeSingle()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/maybesingle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/maybesingle/</guid>
      <description>将数据(data)作为单个对象返回，而不是返回一个对象数组。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;Singapore&amp;#39;)&#xD;.maybeSingle()&#xD;{&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;</description>
    </item>
    <item>
      <title>neq()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/neq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/neq/</guid>
      <description>neq()用于匹配列值不等于指定值的行。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.neq(&amp;#39;name&amp;#39;, &amp;#39;Albania&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>not()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/not/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/not/</guid>
      <description>仅匹配不满足筛选条件的行。&#xA;not()函数要求您使用原始的PostgREST语法来表示筛选条件的值。&#xA;.not(&amp;#39;id&amp;#39;, &amp;#39;in&amp;#39;, &amp;#39;(5,6,7)&amp;#39;) // Use `()` for `in` filter&#xD;.not(&amp;#39;arraycol&amp;#39;, &amp;#39;cs&amp;#39;, &amp;#39;{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use `cs` for `contains()`, `{}` for array values&#xD;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;null&amp;#39;),&#xD;(2, null);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.not(&amp;#39;name&amp;#39;, &amp;#39;is&amp;#39;, null)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;null&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列</description>
    </item>
    <item>
      <title>or()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/or/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/or/</guid>
      <description>仅匹配满足至少一个过滤条件的行。&#xA;or() 期望您使用原始的 PostgREST语法 来指定过滤器的名称和值。&#xA;.or(&amp;#39;id.in.(5,6,7), arraycol.cs.{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use `()` for `in` filter, `{}` for array values and `cs` for `contains()`.&#xD;.or(&amp;#39;id.in.(5,6,7), arraycol.cd.{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use `cd` for `containedBy()`&#xD;案例教程 link案例1 （和select一起使用） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.or(&amp;#39;id.eq.2,name.eq.Algeria&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （与and一起使用or） link&#xD;建表&#xD;使用方法&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>order()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/order/</guid>
      <description>按列对查询结果进行排序。&#xA;你可以多次调用这个方法来按多列排序。&#xA;你可以对外部表进行排序，但这并不影响对当前表的排序。&#xA;案例教程 link案例1 （使用select） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;id&amp;#39;, &amp;#39;name&amp;#39;)&#xD;.order(&amp;#39;id&amp;#39;, { ascending: false })&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （在外部表） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;create table&#xD;cities (&#xD;id int8 primary key,&#xD;country_id int8 not null references countries,&#xD;name text&#xD;);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;United States&amp;#39;),&#xD;(2, &amp;#39;Vanuatu&amp;#39;);&#xD;insert into&#xD;cities (id, country_id, name)&#xD;values&#xD;(1, 1, &amp;#39;Atlanta&amp;#39;),&#xD;(2, 1, &amp;#39;New York City&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>overlaps()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/overlaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/overlaps/</guid>
      <description>仅适用于数组列和范围列&#xA;仅匹配列（column）和值（value）有一个共同元素的行。&#xA;案例教程 link案例1 （关于数组列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;issues (&#xD;id int8 primary key,&#xD;title text,&#xD;tags text[]&#xD;);&#xD;insert into&#xD;issues (id, title, tags)&#xD;values&#xD;(1, &amp;#39;Cache invalidation is not working&amp;#39;, array[&amp;#39;is:open&amp;#39;, &amp;#39;severity:high&amp;#39;, &amp;#39;priority:low&amp;#39;]),&#xD;(2, &amp;#39;Use better names&amp;#39;, array[&amp;#39;is:open&amp;#39;, &amp;#39;severity:low&amp;#39;, &amp;#39;priority:medium&amp;#39;]);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;issues&amp;#39;)&#xD;.select(&amp;#39;title&amp;#39;)&#xD;.overlaps(&amp;#39;tags&amp;#39;, [&amp;#39;is:closed&amp;#39;, &amp;#39;severity:high&amp;#39;])&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;title&amp;#34;: &amp;#34;Cache invalidation is not working&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （关于范围列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>range()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/range/</guid>
      <description>通过 from和 to来限制查询结果。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.range(0, 1)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;from&#xD;[必要参数]&#xD;number类型&#xD;用于限制结果的起始索引&#xA;to&#xD;[必要参数]&#xD;number类型&#xD;限制结果的最后一个索引&#xA;选项（option）&#xD;[可选参数]&#xD;object类型&#xD;命名的参数</description>
    </item>
    <item>
      <title>rangeAdjacent()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangeadjacent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangeadjacent/</guid>
      <description>仅适用于范围列&#xA;仅匹配列与范围(range)互斥且两个范围之间不能有任何元素的行。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeAdjacent(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-01 12:00, 2000-01-01 13:00)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Emerald&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-01 13:00:00\&amp;#34;,\&amp;#34;2000-01-01 15:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>rangeGt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangegt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangegt/</guid>
      <description>仅适用于范围（range）列&#xA;仅匹配列中的每个元素都大于范围(range)中的任何元素的行。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeGt(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-02 08:00, 2000-01-02 09:00)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Topaz&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-02 09:00:00\&amp;#34;,\&amp;#34;2000-01-02 10:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>rangeGte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangegte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangegte/</guid>
      <description>仅适用于范围（range）列&#xA;仅匹配列中的每个元素要么包含在范围(range)内，要么大于范围(range)中的任何元素的行。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeGte(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-02 08:30, 2000-01-02 09:30)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Topaz&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-02 09:00:00\&amp;#34;,\&amp;#34;2000-01-02 10:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>rangeLt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangelt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangelt/</guid>
      <description>仅适用于范围列&#xA;仅匹配列中的每个元素都小于范围(range)中的任何元素的行。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeLt(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-01 15:00, 2000-01-01 16:00)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Emerald&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-01 13:00:00\&amp;#34;,\&amp;#34;2000-01-01 15:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>rangeLte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangelte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/rangelte/</guid>
      <description>仅适用于范围列&#xA;仅匹配列中的每个元素要么包含在范围(range)内，要么小于范围(range)中的任何元素的行。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeLte(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-01 14:00, 2000-01-01 16:00)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Emerald&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-01 13:00:00\&amp;#34;,\&amp;#34;2000-01-01 15:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>调用Postgres函数</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/rpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/rpc/</guid>
      <description>你可以将Postgres函数作为远程过程调用（Remote Procedure Calls）来调用，即你可以从任何地方执行数据库中的逻辑。 函数在逻辑很少更改时非常有用，比如用于密码重置和更新等情况。&#xA;下面是一个示例的 Postgres 函数定义：&#xA;create or replace function hello_world() returns text as $$&#xD;select &amp;#39;Hello world&amp;#39;;&#xD;$$ language sql;&#xD;这个函数叫做hello_world，它不带参数，返回一个text类型的结果。函数的逻辑很简单，就是返回字符串&amp;quot;Hello world&amp;quot;。 你可以从任何地方调用这个函数，并获得结果&amp;quot;Hello world&amp;quot;。&#xA;案例教程 link案例1 （调用一个没有参数的Postgres函数） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create function hello_world() returns text as $$&#xD;select &amp;#39;Hello world&amp;#39;;&#xD;$$ language sql;&#xD;const { data, error } = await supabase.rpc(&amp;#39;hello_world&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: &amp;#34;Hello world&amp;#34;,&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （调用一个带参数的Postgres函数） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create function echo(say text) returns text as $$&#xD;select say;&#xD;$$ language sql;&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>eq()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/eq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/eq/</guid>
      <description>eq()用于匹配列值等于指定值的行。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;Albania&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;要检查column的值是否为NULL，你应该使用.is()来代替。&#xA;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>single()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/single/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/single/</guid>
      <description>将数据(data)作为单个对象返回，而不是返回一个对象数组。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.limit(1)&#xD;.single()&#xD;{&#xD;&amp;#34;data&amp;#34;: {&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;</description>
    </item>
    <item>
      <title>textSearch()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/textsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/textsearch/</guid>
      <description>仅适用于文本和 tsvector 列。&#xA;textSearch()作用是找到所有在指定列上的 tsvector 值与给定的 to_tsquery 查询条件匹配的记录。&#xA;更多信息，请参见Postgres全文搜索。 案例教程 link案例1 （文本搜索） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;quotes&amp;#39;)&#xD;.select(&amp;#39;catchphrase&amp;#39;)&#xD;.textSearch(&amp;#39;catchphrase&amp;#39;, `&amp;#39;fat&amp;#39; &amp;amp; &amp;#39;cat&amp;#39;`, {&#xD;config: &amp;#39;english&amp;#39;&#xD;})&#xD;案例2 （基本归一化） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;quotes&amp;#39;)&#xD;.select(&amp;#39;catchphrase&amp;#39;)&#xD;.textSearch(&amp;#39;catchphrase&amp;#39;, `&amp;#39;fat&amp;#39; &amp;amp; &amp;#39;cat&amp;#39;`, {&#xD;type: &amp;#39;plain&amp;#39;,&#xD;config: &amp;#39;english&amp;#39;&#xD;})&#xD;使用PostgreSQL的plainto_tsquery函数。&#xA;案例3 （全面归一化） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>abortSignal()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/db-abortsignal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/db-abortsignal/</guid>
      <description>设置获取请求的AbortSignal。&#xA;案例教程 link案例1 link&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;const ac = new AbortController()&#xD;ac.abort()&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;very_big_table&amp;#39;)&#xD;.select()&#xD;.abortSignal(ac.signal)&#xD;{&#xD;&amp;#34;error&amp;#34;: {&#xD;&amp;#34;message&amp;#34;: &amp;#34;FetchError: The user aborted a request.&amp;#34;,&#xD;&amp;#34;details&amp;#34;: &amp;#34;&amp;#34;,&#xD;&amp;#34;hint&amp;#34;: &amp;#34;&amp;#34;,&#xD;&amp;#34;code&amp;#34;: &amp;#34;&amp;#34;&#xD;},&#xD;&amp;#34;status&amp;#34;: 400,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Bad Request&amp;#34;&#xD;}&#xD;你可以使用 AbortController 来中止请求。 请注意，对于被中止的请求，状态 (status) 和状态文本 (statusText) 并不具有实际意义，因为请求未能完成。&#xA;参数说明 link&#xD;signal&#xD;[必要参数]&#xD;AbortSignal类型&#xD;用于获取请求的AbortSignal</description>
    </item>
    <item>
      <title>csv()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/db-csv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/db-csv/</guid>
      <description>以 CSV 格式将数据（data）作为字符串返回。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.csv()&#xD;{&#xD;&amp;#34;data&amp;#34;: &amp;#34;id,name\n1,Afghanistan\n2,Albania\n3,Algeria&amp;#34;,&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;默认情况下，数据以 JSON 格式返回，但也可以选择返回 CSV 格式。</description>
    </item>
    <item>
      <title>使用过滤器</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/using-filters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/filter/using-filters/</guid>
      <description>过滤器允许你只返回符合某些条件的记录。&#xA;过滤器可以用于select(), update(), upsert(), 和delete()查询。&#xA;如果一个Postgres函数返回一个表的响应，你也可以应用过滤器。&#xA;案例1 （应用过滤器） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;The Shire&amp;#39;) // Correct&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;The Shire&amp;#39;) // Incorrect&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;过滤器必须在select(), update()、upsert()、delete()和rpc()之后，并在修改器之前应用。&#xA;案例2 （链式） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.gte(&amp;#39;population&amp;#39;, 1000)&#xD;.lt(&amp;#39;population&amp;#39;, 10000)&#xD;过滤器可以串联起来，产生高级查询。例如。 来查询人口在1,000和10,000之间的城市。&#xA;案例3 （条件链式） link&#xD;使用方法&#xD;注意事项&#xD;const filterByName = null&#xD;const filterPopLow = 1000&#xD;const filterPopHigh = 10000&#xD;let query = supabase&#xD;.</description>
    </item>
    <item>
      <title>使用修改器</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/using-modifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/using-modifiers/</guid>
      <description>过滤器是在行的层面上工作的&amp;ndash;它们允许你在不改变行的形状的情况下，返回只符合特定条件的行。 只符合某些条件的行，而不改变行的形状。修改器是不符合该定义的一切，允许你改变响应的格式（例如，返回一个CSV字符串）。&#xA;修改器必须在过滤器之后指定。有些修改器只适用于一些修改器只适用于返回行的查询（例如，select()或rpc()在一个返回表的函数上返回表格响应的函数）。</description>
    </item>
    <item>
      <title>createBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-createbucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-createbucket/</guid>
      <description>createBucket()用于创建一个新的存储桶&#xA;需要RLS策略权限:&#xA;buckets表的权限: insert表权限 objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （创建一个存储桶） link&#xD;使用方法&#xD;const { data, error } = await supabase .storage&#xD;.createBucket(&amp;#39;avatars&amp;#39;, {&#xD;public: false,&#xD;allowedMimeTypes: [&amp;#39;image/png&amp;#39;],&#xD;fileSizeLimit: 1024&#xD;})&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。&#xA;选项（option）&#xD;[必要参数]&#xD;object类型&#xD;特性&#xD;public&#xD;[必要参数]&#xD;boolean类型&#xD;存储桶的可见性。公开桶不需要授权令牌来下载对象，但对于所有其他操作仍需要有效的令牌。默认情况下，存储桶是私有的。&#xA;allowedMimeTypes&#xD;[可选参数]&#xD;object类型&#xD;指定此存储桶在上传过程中允许接受的 MIME 类型。默认值为 null，允许上传具有所有 MIME 类型的文件。每个指定的 MIME 类型可以是通配符，例如 image/*，也可以是特定的 MIME 类型，例如 image/png。&#xA;fileSizeLimit&#xD;[可选参数]&#xD;null | 字符串 | 数字&#xD;指定可以上传到此存储桶的最大文件大小（以字节为单位）。全局文件大小限制优先于此值。默认值为 null，表示不设置每个存储桶的文件大小限制。</description>
    </item>
    <item>
      <title>deleteBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-deletebucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-deletebucket/</guid>
      <description>deleteBucket()用于删除现有的存储桶。&#xA;如果存储桶内存在对象，则无法删除存储桶。您必须首先清空empty()存储桶。&#xA;需要RLS策略权限:&#xA;buckets表的权限: select和delete objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （删除一个存储桶） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.deleteBucket(&amp;#39;avatars&amp;#39;)&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。</description>
    </item>
    <item>
      <title>from.download()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-download/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-download/</guid>
      <description>from.download()的作用是从私有存储桶下载文件。对于公共存储桶，从 getPublicUrl 返回的 URL 发起请求。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （下载文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.download(&amp;#39;folder/avatar1.png&amp;#39;)&#xD;案例2 （带transform参数的下载文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.download(&amp;#39;folder/avatar1.png&amp;#39;, {&#xD;transform: {&#xD;width: 100,&#xD;height: 100,&#xD;quality: 80&#xD;}&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.png的格式。在尝试上传之前，必须确保存储桶已经存在。&#xA;选项（option）&#xD;[可选参数]&#xD;object类型 特性&#xD;transform&#xD;[可选参数]&#xD;TransformOptions类型&#xD;在向客户端提供资源之前对资源进行转换。&#xA;特性&#xD;format&#xD;[可选参数]&#xD;&#34;origin&#34;&#xD;指定请求的图像格式。当使用 &amp;lsquo;origin&amp;rsquo; 时，我们强制格式与原始图像相同。如果未传递此选项，则将图像优化为现代图像格式，如 Webp。</description>
    </item>
    <item>
      <title>from.upload()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-upload/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-upload/</guid>
      <description>from.upload()用于将一个文件上传到一个现有的桶。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：仅在上传新文件时需要插入insert权限，以及在更新文件时需要选择select、插入insert和更新updata权限 请参考存储指南中关于访问控制的工作方式。&#xA;对于 React Native，使用 Blob、File 或 FormData 并不能按预期工作。相反，应该使用来自 base64 文件数据的 ArrayBuffer 来上传文件，参见下面的示例。&#xA;案例教程 link案例1 （上传文件） link&#xD;使用方法&#xD;const avatarFile = event.target.files[0]&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.upload(&amp;#39;public/avatar1.png&amp;#39;, avatarFile, {&#xD;cacheControl: &amp;#39;3600&amp;#39;,&#xD;upsert: false&#xD;})&#xD;案例2 （使用来自 base64 文件数据的 ArrayBuffer 来上传文件） link&#xD;使用方法&#xD;const avatarFile = event.target.files[0]&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.upload(&amp;#39;public/avatar1.png&amp;#39;, avatarFile, {&#xD;cacheControl: &amp;#39;3600&amp;#39;,&#xD;upsert: false&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.</description>
    </item>
    <item>
      <title>from.update()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-update/</guid>
      <description>from.update()用于实现一个新文件替换指定路径下的现有文件。.&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：update和select权限 请参考存储指南中关于访问控制的工作方式。&#xA;对于使用 React Native 进行开发的情况，直接使用 Blob、File 或 FormData 对象来进行文件操作可能会无法达到预期的效果。 相反，建议使用来自 base64 文件数据的 ArrayBuffer 来更新文件。可以参考提供的示例代码来了解如何以此方式进行文件更新操作。&#xA;案例教程 link案例1 （更新文件） link&#xD;使用方法&#xD;const avatarFile = event.target.files[0]&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.update(&amp;#39;public/avatar1.png&amp;#39;, avatarFile, {&#xD;cacheControl: &amp;#39;3600&amp;#39;,&#xD;upsert: true&#xD;})&#xD;案例2 （使用ArrayBuffer从base64文件数据更新文件） link&#xD;使用方法&#xD;import {decode} from &amp;#39;base64-arraybuffer&amp;#39;&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.update(&amp;#39;public/avatar1.png&amp;#39;, decode(&amp;#39;base64FileData&amp;#39;), {&#xD;contentType: &amp;#39;image/png&amp;#39;&#xD;}) 参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.</description>
    </item>
    <item>
      <title>from.remove()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-remove/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-remove/</guid>
      <description>from.remove()用于删除存储桶中的文件&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：delete和select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （删除文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.remove([&amp;#39;folder/avatar1.png&amp;#39;])&#xD;参数说明 link&#xD;paths&#xD;[必要参数]&#xD;string[]类型（字符串数组）&#xD;一个要删除的文件数组，包括路径和文件名。例如[folder/image.png]。</description>
    </item>
    <item>
      <title>from.list()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-list/</guid>
      <description>from.list()用于列出存储桶内的所有文件。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （在存储桶中列出文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.list(&amp;#39;folder&amp;#39;, {&#xD;limit: 100,&#xD;offset: 0,&#xD;sortBy: { column: &amp;#39;name&amp;#39;, order: &amp;#39;asc&amp;#39; },&#xD;})&#xD;案例2 （在存储桶中搜索文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.list(&amp;#39;folder&amp;#39;, {&#xD;limit: 100,&#xD;offset: 0,&#xD;sortBy: { column: &amp;#39;name&amp;#39;, order: &amp;#39;asc&amp;#39; },&#xD;search: &amp;#39;jon&amp;#39;&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[可选参数]&#xD;string类型&#xD;文件夹路径。</description>
    </item>
    <item>
      <title>from.move()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-move/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-move/</guid>
      <description>from.move()用于将一个现有的文件移动到同一桶中的新路径。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：update和select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （移动文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.move(&amp;#39;public/avatar1.png&amp;#39;, &amp;#39;private/avatar2.png&amp;#39;)&#xD;参数说明 link&#xD;fromPath&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.png的格式。在尝试上传之前，必须确保存储桶已经存在。&#xA;toPath&#xD;[必要参数]&#xD;string类型&#xD;新的文件路径，包括新的文件名。例如folder/image-new.png。</description>
    </item>
    <item>
      <title>from.copy()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-copy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-copy/</guid>
      <description>from.copy()用于将一个现有的文件复制到存储桶中的新路径。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：insert和select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （复制文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.copy(&amp;#39;public/avatar1.png&amp;#39;, &amp;#39;private/avatar2.png&amp;#39;)&#xD;参数说明 link&#xD;fromPath&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.png的格式。在尝试上传之前，必须确保存储桶已经存在。&#xA;toPath&#xD;[必要参数]&#xD;string类型&#xD;新的文件路径，包括新的文件名。例如folder/image-copy.png。</description>
    </item>
    <item>
      <title>from.createSignedUrl()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-createsignedurl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-createsignedurl/</guid>
      <description>创建一个签名的URL。使用签名的URL在固定时间内分享一个文件。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （创建一个带有签名的URL） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrl(&amp;#39;folder/avatar1.png&amp;#39;, 60)&#xD;案例2 （创建带有转换的签名URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrl(&amp;#39;folder/avatar1.png&amp;#39;, 60, {&#xD;transform: {&#xD;width: 100,&#xD;height: 100,&#xD;}&#xD;})&#xD;案例3 （创建用于触发资源下载的签名URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrl(&amp;#39;folder/avatar1.png&amp;#39;, 60, {&#xD;download: true,&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括当前文件名。例如 folder/image.</description>
    </item>
    <item>
      <title>from.createSignedUrls()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-createsignedurls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-createsignedurls/</guid>
      <description>from.createSignedUrls()用于创建多个签名的URL。使用签名的URL在固定的时间内分享一个文件。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （创建多个带有签名的URL） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrls([&amp;#39;folder/avatar1.png&amp;#39;, &amp;#39;folder/avatar2.png&amp;#39;], 60)&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string[]类型（字符串数组）&#xD;要下载的文件路径，包括当前文件名。例如：[&amp;lsquo;folder/image.png&amp;rsquo;, &amp;lsquo;folder2/image2.png&amp;rsquo;]。&#xA;expiresIn&#xD;[必要参数]&#xD;数字类型&#xD;签名URL的过期时间，以秒为单位。例如，对于有效期为一分钟的URL，可以设置为 60。&#xA;选项（option）&#xD;[可选参数]&#xD;object类型&#xD;特性&#xD;download&#xD;[可选参数]&#xD;string | boolean&#xD;如果设置为 true，将触发文件下载。如果您希望使用不同的文件名触发下载，请将此参数设置为所需的文件名。</description>
    </item>
    <item>
      <title>from.getPublicUrl()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-getpublicurl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-from-getpublicurl/</guid>
      <description>from.getPublicUrl()是用于获取公开存储桶中资源URL的函数。如果你不想使用这个函数，也可以通过将存储桶URL与资源路径拼接在一起来构建公开（public）URL。&#xA;这个函数不会验证存储桶是否为公开（public）。如果为非公开的存储桶创建了公开（public）URL，你将无法下载资源。&#xA;需要将存储桶设置为公开（public）状态，可以通过 updateBucket() 方法或者在 MemFireCloud应用控制台的存储页面中，选择你需要操作的存储桶，点击该存储桶的扩展按钮。选择编辑存储桶，然后选择公开存储桶按钮即可完成。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （返回公开存储桶中资源的URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;public-bucket&amp;#39;)&#xD;.getPublicUrl(&amp;#39;folder/avatar1.png&amp;#39;)&#xD;案例2 （返回公开存储桶中带有转换的资源的URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;public-bucket&amp;#39;)&#xD;.getPublicUrl(&amp;#39;folder/avatar1.png&amp;#39;, {&#xD;transform: {&#xD;width: 100,&#xD;height: 100,&#xD;}&#xD;})&#xD;案例3 （返回触发公开存储桶中资源下载的URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;public-bucket&amp;#39;)&#xD;.getPublicUrl(&amp;#39;folder/avatar1.png&amp;#39;, {&#xD;download: true,&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括当前文件名。例如 folder/image.</description>
    </item>
    <item>
      <title>emptyBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-emptybucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-emptybucket/</guid>
      <description>emptyBucket()用于移除单个桶内的所有对象。&#xA;需要RLS策略权限:&#xA;buckets表的权限: select objects表的权限：select和delet 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （清空一个存储桶） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.emptyBucket(&amp;#39;avatars&amp;#39;)&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。</description>
    </item>
    <item>
      <title>getBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-getbucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-getbucket/</guid>
      <description>getBucket()用于获取现有存储桶的详细信息。&#xA;需要RLS策略权限:&#xA;buckets表的权限: select objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （获取存储桶信息） link&#xD;使用方法&#xD;const { data, error } = await supabase .storage&#xD;.getBucket(&amp;#39;avatars&amp;#39;)&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。</description>
    </item>
    <item>
      <title>listBuckets()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-listbuckets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-listbuckets/</guid>
      <description>listBuckets()用于获取现有项目中所有存储桶的详细信息。&#xA;需要RLS策略权限:&#xA;buckets表的权限: select objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （获取所有存储桶信息） link&#xD;使用方法&#xD;const { data, error } = await supabase .storage&#xD;.listBuckets()&#xD;</description>
    </item>
    <item>
      <title>updateBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-updatebucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/storage/storage-updatebucket/</guid>
      <description>updateBucket()用于更新存储桶&#xA;需要RLS策略权限:&#xA;buckets表的权限: select和update objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （更新存储桶） link&#xD;使用方法&#xD;const { data, error } = await supabase .storage&#xD;.updateBucket(&amp;#39;avatars&amp;#39;, {&#xD;public: false,&#xD;allowedMimeTypes: [&amp;#39;image/png&amp;#39;],&#xD;fileSizeLimit: 1024&#xD;})&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。&#xA;选项（option）&#xD;[必要参数]&#xD;object类型&#xD;特性&#xD;public&#xD;[必要参数]&#xD;boolean类型&#xD;存储桶的可见性。公开桶不需要授权令牌来下载对象，但对于所有其他操作仍需要有效的令牌。默认情况下，存储桶是私有的。&#xA;allowedMimeTypes&#xD;[可选参数]&#xD;object类型&#xD;指定此存储桶在上传过程中允许接受的 MIME 类型。默认值为 null，允许上传具有所有 MIME 类型的文件。每个指定的 MIME 类型可以是通配符，例如 image/*，也可以是特定的 MIME 类型，例如 image/png。&#xA;fileSizeLimit&#xD;[可选参数]&#xD;null | 字符串 | 数字&#xD;指定可以上传到此存储桶的最大文件大小（以字节为单位）。全局文件大小限制优先于此值。默认值为 null，表示不设置每个存储桶的文件大小限制。</description>
    </item>
    <item>
      <title>on().subscribe()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/realtime/subscribe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/realtime/subscribe/</guid>
      <description>on().subscribe()创建一个事件处理程序，用于监听变更。&#xA;默认情况下，广播（Broadcast）和在线状态（Presence）对所有项目都是启用的。 对于新项目，默认情况下禁用了监听数据库变更，原因是出于数据库性能和安全方面的考虑。你可以通过管理实时数据的复制功能来启用它。 你可以通过将表的 REPLICA IDENTITY 设置为 FULL（例如，执行 ALTER TABLE your_table REPLICA IDENTITY FULL;），来接收更新和删除操作的&amp;quot;之前&amp;quot;的数据。 删除语句(delete statements)不适用行级安全（Row level security）。当启用行级安全并将复制标识（replica identity）设置为 full 时，只有主键会被发送到客户端。 案例教程 link案例1 （监听广播消息） link&#xD;使用方法&#xD;supabase&#xD;.channel(&amp;#39;any&amp;#39;)&#xD;.on(&amp;#39;broadcast&amp;#39;, { event: &amp;#39;cursor-pos&amp;#39; }, payload =&amp;gt; {&#xD;console.log(&amp;#39;Cursor position received!&amp;#39;, payload)&#xD;})&#xD;.subscribe((status) =&amp;gt; {&#xD;if (status === &amp;#39;SUBSCRIBED&amp;#39;) {&#xD;channel.send({&#xD;type: &amp;#39;broadcast&amp;#39;,&#xD;event: &amp;#39;cursor-pos&amp;#39;,&#xD;payload: { x: Math.random(), y: Math.random() },&#xD;})&#xD;}&#xD;})&#xD;案例2 （监听在线状态同步） link&#xD;使用方法&#xD;const channel = supabase.</description>
    </item>
    <item>
      <title>getChannels()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/realtime/getchannels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/realtime/getchannels/</guid>
      <description>getChannels()用于返回所有的Realtime通道。&#xA;案例教程 link案例1 link&#xD;使用方法&#xD;const channels = supabase.getChannels() </description>
    </item>
    <item>
      <title>removeChannel()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/realtime/removechannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/realtime/removechannel/</guid>
      <description>removeChannel()用于取消订阅并从实时（realtime）客户端移除实时（realtime）频道。&#xA;移除频道是维护项目的实时服务性能以及在监听Postgres更改时维护数据库性能的好方法。 在客户端断开连接后，MemFire Cloud会自动在30秒后进行清理，但是未使用的频道可能会导致性能下降，特别是当有更多客户端同时订阅时。&#xA;案例教程 link案例1 link&#xD;使用方法&#xD;supabase.removeChannel(myChannel)&#xD;参数说明 link&#xD;频道（channel）&#xD;[必要参数]&#xD;default&#xD;实时（realtime）通道的名称。如果没有显式指定通道名称，系统将使用&amp;quot;default&amp;quot;作为默认值。</description>
    </item>
    <item>
      <title>removeAllChannels()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/realtime/removeallchannels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/realtime/removeallchannels/</guid>
      <description>removeAllChannels()用于取消订阅并从实时客户端移除所有实时通道。&#xA;移除频道是维护项目的实时服务性能以及在监听Postgres更改时维护数据库性能的好方法。 在客户端断开连接后，MemFire Cloud会自动在30秒后进行清理，但是未使用的频道可能会导致性能下降，特别是当有更多客户端同时订阅时。&#xA;案例教程 link案例1 link&#xD;使用方法&#xD;supabase.removeAllChannels()&#xD;</description>
    </item>
    <item>
      <title>invoke()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/function/invoke/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/function/invoke/</guid>
      <description>应用使用MemFire Cloud的云函数功能时，需要结合supabase-wechat-stable-v2与memfire-cloud-functions-js 这两个SDK进行云函数的调用。&#xA;使用方法 link在根目录下执行命令，安装依赖&#xA;npm install supabase-wechat-stable-v2&#xD;添加一个js/ts文件与数据库建立连接，添加以下代码，并且将应用的URL和anon_key填写进去。&#xA;import { createClient } from &amp;#39;supabase-wechat-stable-v2&amp;#39;&#xD;const supabaseUrl = &amp;#39;&amp;#39;&#xD;const supabaseAnonKey = &amp;#39;&amp;#39;&#xD;export const supabase = createClient(supabaseUrl, supabaseAnonKey)&#xD;在需要使用云函数的页面调用，填写用户在MemFire Cloud创建的云函数生成的访问地址和访问方法。&#xA;const { data, error } = await functions.invoke(&#xD;&amp;#39;访问地址&amp;#39;,{method:&amp;#39;访问方法&amp;#39;}&#xD;);&#xD;参数 link&#xD;functionName&#xD;required&#xD;string&#xD;要调用的函数的名称&#xA;invokeOptions&#xD;required&#xD;FunctionInvokeOptions&#xD;未提供说明。&#xA;注释 link 需要一个授权标头。 调用参数通常符合Fetch API规范。 当你向函数传递一个body时，我们会自动附加 Blob、ArrayBuffer、File、FormData和 String的Content-Type标头。如果它不符合这些类型，会默认为json，将其序列化并附加Content-Type&#39;头为application/json。用户还可以自定义 Content-Type`。 响应会自动解析为json、blob或form-data，取决于你的函数发送的Content-Type头。默认情况下，响应被解析为text。 示例 link基本调用 link&#xD;const { data, error } = await functions.</description>
    </item>
    <item>
      <title>概览</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/supabase-auth-admin-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/supabase-auth-admin-api/</guid>
      <description> 在 supabase.auth.admin 命名空间下的任何方法都需要使用 service_role 密钥。 这些方法被认为是管理员级别的方法，它们应该只在可信任的服务器端被调用执行，而不应该在客户端浏览器等不受信任的环境中使用。 绝对不要在客户端浏览器中公开或传递 service_role 密钥。因为这个密钥拥有管理用户认证和权限的权限，如果泄露给不信任的用户，可能会导致安全风险. 案例教程 link案例1 （创建服务器端认证客户端） link&#xD;使用方法&#xD;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;const supabase = createClient(supabase_url, service_role_key, {&#xD;auth: {&#xD;autoRefreshToken: false,&#xD;persistSession: false&#xD;}&#xD;})&#xD;// Access auth admin api&#xD;const adminAuthClient = supabase.auth.admin&#xD;</description>
    </item>
    <item>
      <title>createUser()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-createuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-createuser/</guid>
      <description>createUser()用于创建一个新的用户。这个函数应该只在服务器上调用。不要在浏览器中暴露你的service_role密钥。&#xA;为了确认用户的电子邮件地址或电话号码，请将 email_confirm 或 phone_confirm 设置为 true。如果不进行设置，这两个参数的默认值为 false。 createUser() 不会向用户发送确认电子邮件。如果你想发送邀请电子邮件，可以使用 inviteUserByEmail() 方法。 如果你确定所创建的用户的电子邮件或电话号码是合法且经过验证的，你可以将 email_confirm 或 phone_confirm 参数设置为 `true。 案例教程 link案例1 （带有自定义用户元数据） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.admin.createUser({&#xD;email: &amp;#39;user@email.com&amp;#39;,&#xD;password: &amp;#39;password&amp;#39;,&#xD;user_metadata: { name: &amp;#39;Yoda&amp;#39; }&#xD;})&#xD;如果密码超过了72个字符，它将被截断为前72个字符。&#xA;案例2 （自动确认用户的电子邮件） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.createUser({&#xD;email: &amp;#39;user@email.com&amp;#39;,&#xD;email_confirm: true&#xD;}) 案例3 （自动确认用户的电话号码） link&#xD;使用方法&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>deleteUser()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-deleteuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-deleteuser/</guid>
      <description>deleteUser()用于删除用户。这个过程需要使用 service_role 密钥。&#xA;案例教程 link案例1 （移除一个用户） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.deleteUser(&#xD;&amp;#39;715ed5db-f090-4b8c-a067-640ecee36aa0&amp;#39;&#xD;)&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;你想删除的用户ID。&#xA;shouldSoftDelete&#xD;[可选参数]&#xD;boolean类型&#xD;当设置为 true 时，将对用户进行软删除操作（&amp;ldquo;软删除&amp;rdquo; 是一种在数据库中标记数据为已删除但不立即物理删除的操作方式。），即在认证模式（auth schema）中进行软删除。而当设置为 false 时，用户将被物理删除。&#xA;默认情况下，&amp;ldquo;shouldSoftDelete&amp;rdquo; 参数的值为 false，这是为了保持向后兼容性。这意味着如果在调用删除用户的函数时不显式指定 &amp;ldquo;shouldSoftDelete&amp;rdquo; 参数，那么默认情况下用户将会被物理删除，而不是软删除。&#xA;需要特别注意的是绝对不能将这个参数暴露给客户端浏览器。这是因为这个参数涉及到对数据进行软删除或物理删除的决定，是一个敏感的操作。确保在服务器端安全地处理这个参数，并且绝不要在客户端浏览器中传递敏感的 service_role 密钥。</description>
    </item>
    <item>
      <title>generateLink()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-generatelink/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-generatelink/</guid>
      <description>generateLink() 函数用于生成电子邮件链接和一次性密码（OTP），这些链接和密码将通过自定义的电子邮件服务商发送。&#xA;generateLink() 函数可以接受以下类型的参数：signup、magiclink、invite、recovery、email_change_current、email_change_new、phone_change。 根据传入的类型不同，生成的链接和密码可能有所不同，用于不同的场景，比如用户注册、魔术链接登录、邀请用户、找回密码等。 对于 email_change_email 类型的参数，generateLink() 函数只会生成电子邮件链接，前提是在你的 Supabase 项目的 &amp;ldquo;Email&amp;rdquo; 提供商中启用了 &amp;ldquo;Secure email change&amp;rdquo; 设置。这个功能用于确保用户更改电子邮件地址时的安全性。 generateLink() 函数处理了注册、邀请和魔术链接场景下的用户创建。这意味着在这些场景中，函数会在生成链接和密码的同时，也会创建用户账号，使得用户可以使用相应的链接和密码进行注册、登录或邀请操作。 案例教程 link案例1 （生成注册链接） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.generateLink({&#xD;type: &amp;#39;signup&amp;#39;,&#xD;email: &amp;#39;email@example.com&amp;#39;,&#xD;password: &amp;#39;secret&amp;#39;&#xD;})&#xD;案例2 （生成邀请链接） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.generateLink({&#xD;type: &amp;#39;invite&amp;#39;,&#xD;email: &amp;#39;email@example.com&amp;#39;&#xD;}) 案例3 （生成魔术链接） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.generateLink({&#xD;type: &amp;#39;magiclink&amp;#39;,&#xD;email: &amp;#39;email@example.</description>
    </item>
    <item>
      <title>getUserById()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-getuserbyid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-getuserbyid/</guid>
      <description>getUserById()可以根据用户的 ID 获取用户信息。&#xA;它将根据用户提供的用户 ID，在数据库中查找并获取相应的用户对象（user object）。用户对象包含了有关该用户的各种信息，比如用户名、电子邮件地址、角色等。 执行这个操作需要使用 getUserById() 方法，并且这个方法需要提供用户的 ID 作为参数。这个 ID 映射到数据库中的 auth.users.id 列，用于唯一标识一个用户。 案例教程 link案例1 （使用 access_token jwt 获取用户对象） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.getUserById(1)&#xD;参数说明 link&#xD;uid&#xD;[必要参数]&#xD;string类型&#xD;用户的唯一标识符。此函数应该只在服务器上调用。绝对不要在浏览器中暴露你的 service_role 密钥。</description>
    </item>
    <item>
      <title>inviteUserByEmail()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-inviteuserbyemail/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-inviteuserbyemail/</guid>
      <description>inviteUserByEmail()函数用于向一个用户电子邮件地址发送邀请链接。&#xA;案例教程 link案例1 （邀请一个用户） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.inviteUserByEmail(&amp;#39;email@example.com&amp;#39;)&#xD;参数说明 link&#xD;email&#xD;[必要参数]&#xD;string类型&#xD;用户的电子邮件地址。&#xA;选项（option）&#xD;[必要参数]&#xD;object类型&#xD;用于指定在邀请时包含的额外选项。&#xA;特性&#xD;data&#xD;[可选参数]&#xD;object类型&#xD;用于存储关于用户的其他元数据。这个数据对象映射到 auth.users.user_metadata 列，可以用于存储一些用户特定的信息。&#xA;redirectTo&#xD;[可选参数]&#xD;string类型&#xD;它会附加在发送给用户电子邮件地址的邀请链接的 URL 后面。用户点击链接后将跳转到这个指定的 URL。</description>
    </item>
    <item>
      <title>listUsers()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-listusers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-listusers/</guid>
      <description>listUsers()用于获取用户列表，默认每页返回50个用户。&#xA;案例教程 link案例1 （获取用户的一页数据） link&#xD;使用方法&#xD;const { data: { users }, error } = await supabase.auth.admin.listUsers()&#xD;案例2 （用户的分页列表） link&#xD;使用方法&#xD;const { data: { users }, error } = await supabase.auth.admin.listUsers({&#xD;page: 1,&#xD;perPage: 1000&#xD;})&#xD;参数说明 link&#xD;params&#xD;[可选参数]&#xD;PageParams&#xD;一个对象，支持 page 和 perPage 作为数字，用于更改分页结果。&#xA;特性&#xD;page&#xD;[可选参数]&#xD;数字类型&#xD;页数&#xA;perPage&#xD;[可选参数]&#xD;数字类型&#xD;每一页返回项目的个数</description>
    </item>
    <item>
      <title>updateUserById()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-updateuserbyid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/auth-admin/auth-admin-updateuserbyid/</guid>
      <description>updateUserById()用于更新用户数据。&#xA;案例教程 link案例1 （更新用户的电子邮件地址） link&#xD;使用方法&#xD;const { data: user, error } = await supabase.auth.admin.updateUserById(&#xD;&amp;#39;6aa5d0d4-2a9f-4483-b6c8-0cf4c6c98ac4&amp;#39;,&#xD;{ email: &amp;#39;new@email.com&amp;#39; }&#xD;)&#xD;案例2 （更新用户的密码） link&#xD;使用方法&#xD;const { data: user, error } = await supabase.auth.admin.updateUserById(&#xD;&amp;#39;6aa5d0d4-2a9f-4483-b6c8-0cf4c6c98ac4&amp;#39;,&#xD;{ password: &amp;#39;new_password&amp;#39; }&#xD;)&#xD;案例3 （更新用户的元数据） link&#xD;使用方法&#xD;const { data: user, error } = await supabase.auth.admin.updateUserById(&#xD;&amp;#39;6aa5d0d4-2a9f-4483-b6c8-0cf4c6c98ac4&amp;#39;,&#xD;{ user_metadata: { hello: &amp;#39;world&amp;#39; } }&#xD;)&#xD;案例4 （更新用户的应用程序元数据） link&#xD;使用方法&#xD;const { data: user, error } = await supabase.</description>
    </item>
    <item>
      <title>安装</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/installing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/installing/</guid>
      <description>supabase-wechat-stable-v2是由MemFire Cloud团队直接建立的。&#xA;supabase-wechat-stable-v2 link使用NPM安装&#xA;npm install supabase-wechat-stable-v2&#xD;使用Yarn安装&#xA;yarn add supabase-wechat-stable-v2&#xD;</description>
    </item>
    <item>
      <title>版本说明</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/release-notes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/release-notes/</guid>
      <description>supabase-wechat-stable-v2 v2发布说明。&#xA;2.0.0 link用npm install supabase-wechat-stable-v2安装最新版本。&#xA;明确的构造器选项 link构造函数中的所有客户端特定选项都是键入库的。&#xA;const supabase = createClient(apiURL, apiKey, {&#xD;db: {&#xD;schema: &amp;#39;public&amp;#39;,&#xD;},&#xD;auth: {&#xD;storage: AsyncStorage,&#xD;autoRefreshToken: true,&#xD;persistSession: true,&#xD;detectSessionInUrl: true,&#xD;},&#xD;realtime: {&#xD;channels,&#xD;endpoint,&#xD;},&#xD;global: {&#xD;fetch: customFetch,&#xD;headers: DEFAULT_HEADERS,&#xD;},&#xD;})&#xD;支持typescript link这些库现在支持typescript。&#xA;// v2 - definitions are injected in `createClient()`&#xD;import type { Database } from &amp;#39;./DatabaseDefinitions&amp;#39;&#xD;const supabase = createClient&amp;lt;Database&amp;gt;(SUPABASE_URL, ANON_KEY)&#xD;const { data } = await supabase.</description>
    </item>
    <item>
      <title>支持Typescript</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/typescript-support/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/start/typescript-support/</guid>
      <description>supabase-wechat-stable-v2支持Typescript。&#xA;生成类型 link你可以使用我们的CLI来生成类型。&#xA;supabase start&#xD;supabase gen types typescript --local &amp;gt; lib/database.types.ts&#xD;这些类型是直接从你的数据库中生成的。给定一个表public.movies，该定义将提供以下数据。&#xA;interface Database {&#xD;public: {&#xD;Tables: {&#xD;movies: {&#xD;Row: {} // The data expected to be returned from a &amp;#34;select&amp;#34; statement.&#xD;Insert: {} // The data expected passed to an &amp;#34;insert&amp;#34; statement.&#xD;Update: {} // The data expected passed to an &amp;#34;update&amp;#34; statement.&#xD;}&#xD;}&#xD;}&#xD;}&#xD;在 &amp;ldquo;选择&amp;rdquo;、&amp;ldquo;插入 &amp;ldquo;和 &amp;ldquo;更新 &amp;ldquo;之间是有区别的，因为通常你会在数据库中为特定的列设置默认值。 有了默认值，你就不需要通过网络发送任何数据，即使该列是一个 &amp;ldquo;必填 &amp;ldquo;字段。我们的类型系统是精细的 足以处理这些情况。</description>
    </item>
    <item>
      <title>signUp()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signup/</guid>
      <description>创建一个新的用户。&#xA;默认情况下，用户在登录之前需要验证他们的电子邮件地址。要关闭此功能，请在您的项目中禁用 确认电子邮 选项。&#xA;确认电子邮件 决定用户在注册后是否需要确认他们的电子邮件地址。&#xA;如果启用了 确认电子邮件 ，将返回一个用户对象，但会话 (session) 为空。&#xA;如果禁用了 确认电子邮 ，将返回一个用户对象和一个会话 (session)。&#xA;当用户确认他们的电子邮件地址时，默认情况下会重定向到 SITE_URL。您可以在项目中修改 SITE_URL 或在你的项目中添加其他重定向 URL。&#xA;如果对已确认的现有用户调用 signUp()：&#xA;如果您的项目中启用了 确认电子邮件 ，将返回一个混淆的（假的）的用户对象。 如果禁用了 确认电子邮件 ，将返回错误消息用户已注册。 要获取当前已登录的用户，请参阅 getUser() 方法。 案例教程 link案例1 （注册） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signUp({&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;})&#xD;如果密码超过72个字符，它将被截断为前72个字符。&#xA;案例2 （使用附加用户元数据进行注册） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.signUp(&#xD;{&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;options: {&#xD;data: {&#xD;first_name: &amp;#39;John&amp;#39;,&#xD;age: 27,&#xD;}&#xD;}&#xD;}&#xD;)&#xD;案例3 （使用重定向URL进行注册） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>通过 OTP 进行验证和登录</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-verifyotp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-verifyotp/</guid>
      <description>用户通过手机接收到的 OTP（一次性密码） 来登录。&#xA;verifyOtp 方法接受不同的验证类型。如果使用手机号码，类型可以是 sms 或 phone_change。 如果使用电子邮件地址，类型可以是以下之一：email、recovery、invite 或 email_change（signup 和 magiclink 类型已被弃用）。&#xA;应根据在调用 verifyOtp 之前使用的相应身份验证方法来确定使用的验证类型，以便进行用户的注册或登录操作。&#xA;案例教程 link案例1 （验证短信一次性密码） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.verifyOtp({ phone, token, type: &amp;#39;sms&amp;#39;})&#xD;案例2 （验证注册一次性密码） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.verifyOtp({ email, token, type: &amp;#39;signup&amp;#39;})&#xD;参数说明 link&#xD;params&#xD;[必要参数]&#xD;VerifyOtpParams&#xD;</description>
    </item>
    <item>
      <title>getSession()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-getsession/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-getsession/</guid>
      <description>getSession()用于检索会话信息，返回会话，并在必要时进行刷新。这意味着如果需要，会话会被刷新后返回。 如果未检测到会话，返回的会话可能为 空（null），这可能发生在用户未登录或已退出登陆的情况下。&#xA;这个方法用于检索当前的本地会话（即本地存储）。 当会话的访问令牌过期时，该方法会使用刷新令牌来获取一个新的会话。 案例教程 link案例1 （获取会话数据） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.getSession()&#xD;</description>
    </item>
    <item>
      <title>getUser()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-getuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-getuser/</guid>
      <description>getUser()用于获取用户信息，当存在有效会话时，该方法获取当前用户的详细信息。&#xA;与从本地会话获取信息不同，该方法从数据库中获取用户对象的信息。 这个方法非常有用，因为它能够验证用户的访问令牌（JWT）在服务器端是否有效，从而用于检查用户是否已被授权。 建议仅在需要最新的用户数据时使用此方法。对于更快的结果，推荐使用 getSession().session.user。这是因为 getSession().session.user 直接从本地会话获取数据速度较快。而 Retrieve a user 方法需要从数据库中获取数据会稍慢一些。 案例教程 link案例1 （通过当前现有的会话获取已登录的用户信息） link&#xD;使用方法&#xD;const { data: { user } } = await supabase.auth.getUser()&#xD;案例2 （使用自定义访问令牌 jwt 获取已登录的用户信息） link&#xD;使用方法&#xD;const { data: { user } } = await supabase.auth.getUser(jwt)&#xD;参数说明 link&#xD;jwt&#xD;[可选参数]&#xD;string类型&#xD;接收一个可选的访问令牌jwt。如果没有提供jwt，getUser()将试图从当前会话中获取jwt。</description>
    </item>
    <item>
      <title>setSession()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-setsession/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-setsession/</guid>
      <description>setSession()函数的主要目的，是用于设置当前会话的会话数据。 当用户登录或进行其他需要会话数据的操作时，可以使用setSession()函数来更新或设置相关的会话信息。&#xA;如果当前会话已过期，setSession()将负责刷新它以获取新的会话 如果当前会话中的刷新令牌或访问令牌无效，将会抛出错误 setSession()函数需要一个刷新令牌作为参数，然后利用这个刷新令牌来获取一个新的会话。刷新令牌是用于更新会话数据的重要凭证。&#xA;刷新令牌是单次使用的，一旦被用来获取新的会话后，就会失效。&#xA;为了保护系统免受重放攻击，所有项目默认启用刷新令牌轮换功能。重放攻击是指攻击者通过重复使用先前获取的令牌来模拟合法用户的行为，从而进行未经授权的操作。&#xA;为了灵活性，MemFire Cloud允许你配置REFRESH_TOKEN_REUSE_INTERVAL，这是一个时间窗口，在这个窗口内，相同的刷新令牌可以在并发或离线问题的情况下多次使用。&#xA;案例教程 link案例1 （刷新对话） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = supabase.auth.setSession({&#xD;access_token,&#xD;refresh_token&#xD;})&#xD;使用 refresh_token 设置会话数据，并返回当前会话状态；若 refresh_token 无效，则返回错误信息。&#xA;参数说明 link&#xD;当前会话（currentSession）&#xD;[必要参数]&#xD;object类型&#xD;当前的会话，它至少包含一个访问令牌和刷新令牌。&#xA;特性&#xD;刷新令牌（refresh_token）&#xD;[必要参数]&#xD;string类型&#xD;访问令牌（access_token）&#xD;[必要参数]&#xD;string类型&#xD;</description>
    </item>
    <item>
      <title>updateUser()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-updateuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-updateuser/</guid>
      <description>updateUser()用于更新用户信息，该方法用于更新已登录用户的用户数据。&#xA;使用 updateUser() 方法之前，用户必须先登录。默认情况下，如果对用户的电子邮箱进行更新，这将向用户当前的电子邮箱和新的电子邮箱发送确认链接。 若希望仅向用户的新电子邮箱发送确认链接，请在项目的电子邮箱认证提供程序设置中禁用 Secure email change 选项。这样可以避免同时向当前和新电子邮箱发送确认链接。&#xA;案例教程 link案例1 （更新已认证用户的电子邮件地址） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.updateUser({email: &amp;#39;new@email.com&amp;#39;})&#xD;发送一封“确认电子邮件更改”邮件至新的电子邮件地址。&#xA;案例2 （更新已认证用户的密码） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.updateUser({password: &amp;#39;new password&amp;#39;})&#xD;如果密码超过72个字符，它将被截断为前72个字符。&#xA;案例3 （更新用户的元数据信息） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.updateUser({&#xD;data: { hello: &amp;#39;world&amp;#39; }&#xD;})&#xD;案例4 （使用一次性随机码更新用户的密码） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>signInWithWechat()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-getunlimitedqrcode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-getunlimitedqrcode/</guid>
      <description>生成指定小程序某页面的二维码，扫码后可以跳转到该小程序页面。&#xA;使用 SDK 操作如下 link&#xD;const { data, error } = await supabase.auth.getUnlimitedQRCode({&#xD;page: &amp;#34;pages/index/index&amp;#34;, // pageUrl，不能带参数，不能带最开始的 / scene: &amp;#34;root=123&amp;#34;, // 页面参数，字符串最大长度32字节，字符约束参考微信官方文档&#xD;check_path: true,&#xD;env_version: &amp;#34;trial&amp;#34;,&#xD;width: 430,&#xD;auto_color: false,&#xD;line_color: {&amp;#34;r&amp;#34;:0,&amp;#34;g&amp;#34;:0,&amp;#34;b&amp;#34;:0},&#xD;is_hyaline: false&#xD;})&#xD;参数 link&#xD;参数 类型 是否必填 说明 scene String 是 最大32个可见字符，只支持数字，大小写英文以及部分特殊字符：!#$&amp;amp;&amp;rsquo;()*+,/:;=?@-._~，其它字符请自行编码为合法字符（因不支持%，中文无法使用 urlencode 处理，请使用其他编码方式） page String 否 默认是主页，页面 page，例如 pages/index/index，根路径前不要填加 /，不能携带参数（参数请放在 scene 字段里），如果不填写这个字段，默认跳主页面。 check_path boolean 否 默认是true，检查page 是否存在，为 true 时 page 必须是已经发布的小程序存在的页面（否则报错）；为 false 时允许小程序未发布或者 page 不存在， 但page 有数量上限（60000个）请勿滥用。 env_version String 否 要打开的小程序版本。正式版为 &amp;ldquo;release&amp;rdquo;，体验版为 &amp;ldquo;trial&amp;rdquo;，开发版为 &amp;ldquo;develop&amp;rdquo;。默认是正式版。 width number 否 默认430，二维码的宽度，单位 px，最小 280px，最大 1280px auto_color boolean 否 自动配置线条颜色，如果颜色依然是黑色，则说明不建议配置主色调，默认 false line_color object 否 默认是{&amp;ldquo;r&amp;rdquo;:0,&amp;ldquo;g&amp;rdquo;:0,&amp;ldquo;b&amp;rdquo;:0} 。auto_color 为 false 时生效，使用 rgb 设置颜色 例如 {&amp;ldquo;r&amp;rdquo;:&amp;ldquo;xxx&amp;rdquo;,&amp;ldquo;g&amp;rdquo;:&amp;ldquo;xxx&amp;rdquo;,&amp;ldquo;b&amp;rdquo;:&amp;ldquo;xxx&amp;rdquo;} 十进制表示 is_hyaline boolean 否 默认是false，是否需要透明底色，为 true 时，生成透明底色的小程序 返回参数 link&#xD;//请求成功返回正常用户信息&#xD;data: { session: Session | null; user: User | null }; error: null //请求出错，返回错误信息&#xD;data: { session: null; user: null }; error: AuthError 返回示例 linkdata结构如下： link&#xD;{&#xD;&amp;#34;access_token&amp;#34;:&amp;#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9xxxxxxxxxxxxxxxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;token_type&amp;#34;:&amp;#34;bearer&amp;#34;,&#xD;&amp;#34;expires_in&amp;#34;:3600,&#xD;&amp;#34;refresh_token&amp;#34;:&amp;#34;xxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;user&amp;#34;:{&#xD;&amp;#34;id&amp;#34;:&amp;#34;xxxxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;aud&amp;#34;:&amp;#34;authenticated&amp;#34;,&#xD;&amp;#34;role&amp;#34;:&amp;#34;authenticated&amp;#34;,&#xD;&amp;#34;email&amp;#34;:&amp;#34;&amp;#34;,&#xD;&amp;#34;phone&amp;#34;:&amp;#34;&amp;#34;,&#xD;&amp;#34;wechat_id&amp;#34;:&amp;#34;xxxxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;wechat_unionid&amp;#34;:&amp;#34;&amp;#34;,&#xD;&amp;#34;last_sign_in_at&amp;#34;:&amp;#34;2023-03-13T02:47:38.</description>
    </item>
    <item>
      <title>onAuthStateChange()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-onauthstatechange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-onauthstatechange/</guid>
      <description>onAuthStateChange()用于监听认证事件，接收每次认证事件发生时的通知。&#xA;认证事件类型： SIGNED_IN（登录）、SIGNED_OUT（登出）、TOKEN_REFRESHED（令牌刷新）、USER_UPDATED（用户信息更新）、PASSWORD_RECOVERY（密码恢复） 然而目前使用 onAuthStateChange() 方法在不同的标签页之间无效。 举例来说，在密码重置流程中，如果用户在一个标签页请求密码重置链接，当用户点击链接时，原始的标签页将无法收到SIGNED_IN（登录）和PASSWORD_RECOVERY（密码恢复）事件。 案例教程 link案例1 （监听认证变化） link&#xD;使用方法&#xD;supabase.auth.onAuthStateChange((event, session) =&amp;gt; {&#xD;console.log(event, session)&#xD;})&#xD;案例2 （监听密码恢复事件） link&#xD;使用方法&#xD;supabase.auth.onAuthStateChange((event, session) =&amp;gt; {&#xD;if (event == &amp;#39;PASSWORD_RECOVERY&amp;#39;) {&#xD;console.log(&amp;#39;PASSWORD_RECOVERY&amp;#39;, session)&#xD;// show screen to update user&amp;#39;s password&#xD;showPasswordResetScreen(true)&#xD;}&#xD;})&#xD;案例3 （监听登录） link&#xD;使用方法&#xD;supabase.auth.onAuthStateChange((event, session) =&amp;gt; {&#xD;if (event == &amp;#39;SIGNED_IN&amp;#39;) console.log(&amp;#39;SIGNED_IN&amp;#39;, session)&#xD;})&#xD;案例4 （监听退出登录） link&#xD;使用方法&#xD;supabase.auth.onAuthStateChange((event, session) =&amp;gt; {&#xD;if (event == &amp;#39;SIGNED_OUT&amp;#39;) console.</description>
    </item>
    <item>
      <title>refreshSession()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-refreshsession/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-refreshsession/</guid>
      <description>refreshSession()用于获取新的会话，无论会话是否已过期，都将返回一个新的会话。该方法接受一个可选的当前会话作为参数。如果未传入当前会话，那么 refreshSession() 方法将尝试从 getSession() 方法中获取当前会话。 如果当前会话的刷新令牌无效，将抛出一个错误。&#xA;该方法将刷新并返回一个新的会话，无论当前会话是否已过期。 案例教程 link案例1 （使用当前会话刷新会话） link&#xD;使用方法&#xD;const { data: { user, session }, error } = await supabase.auth.refreshSession()&#xD;案例2 （使用传入的会话刷新会话） link&#xD;使用方法&#xD;const { data: { user, session }, error } = await supabase.auth.refreshSession({ refresh_token })&#xD;参数说明 link&#xD;currentSession&#xD;[可选参数]&#xD;object类型&#xD;当前会话的信息。如果传入了这个参数，则必须包含一个刷新令牌。&#xA;特性&#xD;刷新令牌（refresh_token）&#xD;[必要参数]&#xD;string类型&#xD;</description>
    </item>
    <item>
      <title>resetPasswordForEmail()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-resetpasswordforemail/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-resetpasswordforemail/</guid>
      <description>resetPasswordForEmail() 方法会向一个电子邮件地址发送密码重置请求。&#xA;密码重置流程包含两个主要步骤：1. 允许用户通过密码重置链接登录。2. 更新用户的密码。&#xA;resetPasswordForEmail() 方法仅会向用户的电子邮件发送密码重置链接。若要更新用户的密码，请参阅 updateUser() 方法。&#xA;当密码恢复链接被点击时，会触发一个 SIGNED_IN 和 PASSWORD_RECOVERY 事件。你可以使用 onAuthStateChange() 方法来监听这些事件，并在其上调用一个回调函数。&#xA;当用户点击邮件中的重置链接后，他们将被重定向回您的应用程序。您可以通过 redirectTo 参数配置用户重定向的URL。请参阅重定向URL和通配符，以添加其他重定向URL到您的项目中。&#xA;成功重定向用户后，提示他们输入一个新密码并调用 updateUser() ，使用方法如下：&#xA;const { data, error } = await supabase.auth.updateUser({&#xD;password: new_password&#xD;})&#xD;案例教程 link案例1 （重置密码） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.resetPasswordForEmail(email, {&#xD;redirectTo: &amp;#39;https://example.com/update-password&amp;#39;,&#xD;})&#xD;案例2 （重置密码（React）） link&#xD;使用方法&#xD;/**&#xD;* Step 1: Send the user an email to get a password reset token.&#xD;* This email contains a link which sends the user back to your application.</description>
    </item>
    <item>
      <title>signInWithOAuth()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signinwithoauth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signinwithoauth/</guid>
      <description>通过第三方服务商登录现有的用户。&#xA;该方法用于使用第三方服务商进行登录。&#xA;MemFire Cloud支持许多不同的第三方服务商。&#xA;案例教程 link案例1 （借助第三方服务商登陆） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.signInWithOAuth({&#xD;provider: &amp;#39;github&amp;#39;&#xD;})&#xD;案例2 （使用带有重定向的第三方服务商登录） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signInWithOAuth({&#xD;provider: &amp;#39;github&amp;#39;,&#xD;options: {&#xD;redirectTo: &amp;#39;https://example.com/welcome&amp;#39;&#xD;}&#xD;})&#xD;当第三方服务商成功验证用户后，服务商将用户重定向到redirectTo参数指定的URL。默认情况下，该参数为SITE_URL。调用此方法后不会立即重定向用户。&#xA;请查看重定向URL和通配符以向您的项目添加其他重定向URL。&#xA;案例3 （带有作用域(scopes)的登录） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signInWithOAuth({&#xD;provider: &amp;#39;github&amp;#39;,&#xD;options: {&#xD;scopes: &amp;#39;repo gist notifications&amp;#39;&#xD;}&#xD;})&#xD;const oAuthToken = data.session.provider_token // use to access provider API&#xD;如果你需要从OAuth服务商获取附加数据，你可以在请求中包含一个以空格分隔的作用域（scopes）列表，以获得OAuth服务商令牌。</description>
    </item>
    <item>
      <title>signInWithOtp()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signinwithotp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signinwithotp/</guid>
      <description>使用魔法链接（Magiclink）或一次性密码（OTP）登录用户，需要提供电子邮件或手机号码中的任意一种。&#xA;这个方法用于无需密码的登录，其中一次性密码（OTP）将发送到用户的电子邮件或手机号码。 如果用户不存在，signInWithOtp() 将代替其进行用户注册。要限制此行为，您可以将 SignInWithPasswordlessCredentials.options 中的 shouldCreateUser 设置为 false。&#xA;如果您使用电子邮件，您可以配置是否要向用户发送魔法链接或一次性密码（OTP）。&#xA;如果您使用手机号码，您可以配置是否要向用户发送一次性密码（OTP）。&#xA;魔法链接的目标URL由 SITE_URL 决定。请查看重定向URL和通配符以向您的项目添加其他重定向URL。&#xA;魔法链接和OTP共享相同的实现。若要向用户发送一次性密码（OTP）而不是魔法链接，请修改魔法链接的电子邮件模板，将 {{ .ConfirmationURL }} 替换为 {{ .Token }}。&#xA;案例教程 link案例1 （使用电子邮件登录） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signInWithOtp({&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;options: {&#xD;emailRedirectTo: &amp;#39;https://example.com/welcome&amp;#39;&#xD;}&#xD;})&#xD;用户将收到一封电子邮件，其中包含魔法链接或者一次性密码（OTP）亦或是两者都有。默认情况下，同一用户在60秒内只能请求一次一次性密码（OTP）。&#xA;案例2 （使用短信OTP登陆） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.signInWithOtp({&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;})&#xD;用户将收到一条包含一次性密码（OTP）的短信。默认情况下，同一用户在60秒内只能请求一次一次性密码（OTP）。&#xA;案例3 （使用WhatsApp OTP登录） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>signInWithPassword()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signinwithpassword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signinwithpassword/</guid>
      <description>你可以使用电子邮件和密码或者手机号码和密码来登录已存在的用户账户。登录时必须提供以下其中一种组合：&#xA;电子邮件和密码：输入用户注册时使用的电子邮件地址和相应的密码进行登录。 手机号码和密码：输入用户注册时使用的手机号码和相应的密码进行登录。 案例教程 link案例1 （使用电子邮件和密码登录） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.signInWithPassword({&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;})&#xD;案例2 （使用手机号码和密码登录） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.signInWithPassword({&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;password: &amp;#39;some-password&amp;#39;,&#xD;})&#xD;// After receiving a SMS with a OTP.&#xD;const { data, error } = await supabase.auth.verifyOtp({&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;token: &amp;#39;123456&amp;#39;,&#xD;})&#xD;参数说明 link&#xD;credentials&#xD;[必要参数]&#xD;SignUpWithPasswordCredentials SignUpWithPasswordCredentials是使用密码进行身份验证的一种凭据类型。通常包含以下信息：&#xA;1.email（电子邮件）：用户的电子邮件地址，作为账户的唯一标识符之一。&#xA;2.password（密码）：用户选择的密码，用于以后登录时进行身份验证。&#xA;3.可能还包含其他一些相关的字段，例如用户名、手机号码或其他自定义的用户信息。</description>
    </item>
    <item>
      <title>signInWithWechat()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signinwithwechat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signinwithwechat/</guid>
      <description>微信注册&#xA;使用 SDK 操作如下 link&#xD;wx.login({&#xD;success: async res =&amp;gt; {&#xD;const { data, error } = await supabase.auth.signInWithWechat({code:res.code})&#xD;},&#xD;})&#xD;参数 link&#xD;参数 类型 是否必填 说明 code String 是 使用wx.login成功后返回的code 返回参数 link&#xD;//请求成功返回正常用户信息&#xD;data: { session: Session | null; user: User | null }; error: null //请求出错，返回错误信息&#xD;data: { session: null; user: null }; error: AuthError 返回示例 linkdata结构如下： link&#xD;{&#xD;&amp;#34;access_token&amp;#34;:&amp;#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9xxxxxxxxxxxxxxxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;token_type&amp;#34;:&amp;#34;bearer&amp;#34;,&#xD;&amp;#34;expires_in&amp;#34;:3600,&#xD;&amp;#34;refresh_token&amp;#34;:&amp;#34;xxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;user&amp;#34;:{&#xD;&amp;#34;id&amp;#34;:&amp;#34;xxxxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;aud&amp;#34;:&amp;#34;authenticated&amp;#34;,&#xD;&amp;#34;role&amp;#34;:&amp;#34;authenticated&amp;#34;,&#xD;&amp;#34;email&amp;#34;:&amp;#34;&amp;#34;,&#xD;&amp;#34;phone&amp;#34;:&amp;#34;&amp;#34;,&#xD;&amp;#34;wechat_id&amp;#34;:&amp;#34;xxxxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;wechat_unionid&amp;#34;:&amp;#34;&amp;#34;,&#xD;&amp;#34;last_sign_in_at&amp;#34;:&amp;#34;2023-03-13T02:47:38.</description>
    </item>
    <item>
      <title>signOut()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-signout/</guid>
      <description>在浏览器中，signOut() 方法将会从浏览器会话中移除已登录的用户，并让他们退出登陆。&#xA;清除所有本地存储项，然后触发一个 SIGNED_OUT事件。 为了使用 signOut() 方法，用户首先需要完成登录操作。 案例教程 link案例1 link&#xD;使用方法&#xD;const { error } = await supabase.auth.signOut()&#xD;</description>
    </item>
    <item>
      <title>signInWithWechat()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-wechatbindaccount/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-wechatbindaccount/</guid>
      <description>该接口接受一个wx.login返回的code参数，通过code兑换openid等信息，并判断用户是否存在，已经存在会报错，不存在，则将该openid绑定到当前登录的账号上。 应用场景：小程序对应的web/app端先使用手机号+短信的方式注册的用户，在小程序端需要关联微信小程序账号，后续用户通过小程序或者短信方式都能登录到同一个账号下。使用条件，使用此接口之前，用户必须已经在小程序用手机号+短信的方式登录。&#xA;使用 SDK 操作如下 link&#xD;wx.login({&#xD;success: async res =&amp;gt; {&#xD;const { data, error } = await supabase.auth.wechatBindAccount({code:res.code})&#xD;},&#xD;})&#xD;参数 link&#xD;参数 类型 是否必填 说明 code String 是 使用wx.login成功后返回的code 返回参数 link&#xD;//请求成功返回正常用户信息&#xD;data: { session: Session | null; user: User | null }; error: null //请求出错，返回错误信息&#xD;data: { session: null; user: null }; error: AuthError 返回示例 linkdata结构如下： link&#xD;{&#xD;&amp;#34;access_token&amp;#34;:&amp;#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9xxxxxxxxxxxxxxxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;token_type&amp;#34;:&amp;#34;bearer&amp;#34;,&#xD;&amp;#34;expires_in&amp;#34;:3600,&#xD;&amp;#34;refresh_token&amp;#34;:&amp;#34;xxxxxxxxxxx&amp;#34;,&#xD;&amp;#34;user&amp;#34;:{&#xD;&amp;#34;id&amp;#34;:&amp;#34;2411981dxxxx&amp;#34;,&#xD;&amp;#34;aud&amp;#34;:&amp;#34;authenticated&amp;#34;,&#xD;&amp;#34;role&amp;#34;:&amp;#34;authenticated&amp;#34;,&#xD;&amp;#34;email&amp;#34;:&amp;#34;&amp;#34;,&#xD;&amp;#34;phone&amp;#34;:&amp;#34;131xxxx&amp;#34;,&#xD;&amp;#34;phone_confirmed_at&amp;#34;:&amp;#34;2023-03-13T02:53:37.</description>
    </item>
    <item>
      <title>signInWithWechat()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-wechatbindphone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth/auth-wechatbindphone/</guid>
      <description>微信小程序用户登录后，通过该接口绑定该用户授权的微信手机号。&#xA;使用 SDK 操作如下 link&#xD;const { data, error } = await supabase.auth.wechatBindPhone({&#xD;code: &amp;#39;013fA51w3S8Ad03D0C3w31WiTT3fA51k&amp;#39;,&#xD;})&#xD;参数 link&#xD;参数 类型 是否必填 说明 code String 是 需要将 button 组件 open-type 的值设置为 getPhoneNumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到动态令牌code，然后把code传到开发者后台，并在开发者后台调用微信后台提供的 phonenumber.getPhoneNumber 接口，消费code来换取用户手机号。每个code有效期为5分钟，且只能消费一次。 返回参数 link&#xD;//请求成功，返回用户信息&#xD;data: { user: User }; error: null //请求出错，返回错误信息&#xD;data: { user: null }; error: AuthError 返回示例 linkdata结构如下： link&#xD;{&#xD;&amp;#34;id&amp;#34;:&amp;#34;e38801c5xxxxxx&amp;#34;,&#xD;&amp;#34;aud&amp;#34;:&amp;#34;authenticated&amp;#34;,&#xD;&amp;#34;role&amp;#34;:&amp;#34;authenticated&amp;#34;,&#xD;&amp;#34;email&amp;#34;:&amp;#34;&amp;#34;,&#xD;&amp;#34;phone&amp;#34;:&amp;#34;131xxxxxx&amp;#34;,&#xD;&amp;#34;wechat_id&amp;#34;:&amp;#34;ok1s85Rxxxxxx&amp;#34;,&#xD;&amp;#34;wechat_unionid&amp;#34;:&amp;#34;&amp;#34;,&#xD;&amp;#34;last_sign_in_at&amp;#34;:&amp;#34;2023-03-13T08:37:51.308806Z&amp;#34;,&#xD;&amp;#34;app_metadata&amp;#34;:{&#xD;&amp;#34;provider&amp;#34;:&amp;#34;wechat_mini&amp;#34;,&#xD;&amp;#34;providers&amp;#34;:[&#xD;&amp;#34;wechat_mini&amp;#34;&#xD;]&#xD;},&#xD;&amp;#34;user_metadata&amp;#34;:{&#xD;&amp;#34;arvatar&amp;#34;:&amp;#34;http://tmp/z0dymKP81zu04f1fa14be668b52cd87aa12b759cf411.</description>
    </item>
    <item>
      <title>Select 查询</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/select/</guid>
      <description>在表(table)或视图(view)上执行 SELECT 查询。&#xA;默认情况下，Supabase项目返回最多1,000行数据。你可以在项目的API设置中更改此设置。建议将其保持较低，以限制意外或恶意请求的负载大小。你可以使用range()查询来对数据进行分页处理。 select()可以与过滤器(Filters)组合使用，用于过滤数据。 select()可以与修饰器(Modifiers)组合使用，用于对数据进行修改。 如果你使用Supabase平台，apikey是一个保留关键字，应避免将其用作列名。 案例教程 link案例1 (获取数据) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 (选择特定列) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>Insert 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/insert/</guid>
      <description>在表（table）或视图（view）执行 INSERT 操作。&#xA;案例教程 link案例1 （创建一个记录） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;const { error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.insert({ id: 1, name: &amp;#39;Denmark&amp;#39; })&#xD;{&#xD;&amp;#34;status&amp;#34;: 201,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Created&amp;#34;&#xD;}&#xD;案例2 （创建一个记录并返回） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.insert({ id: 1, name: &amp;#39;Denmark&amp;#39; })&#xD;.select()&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Denmark&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 201,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Created&amp;#34;&#xD;}&#xD;案例3 （批量创建） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;const { error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>Delete 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/delete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/delete/</guid>
      <description>delete()用于在表（table）或视图（view）执行 DELETE 操作。&#xA;delete() 应始终与过滤器（filter）结合使用，以便定位要删除的项。 如果你在使用 delete() 时带有过滤器，并且启用了RLS（行级安全性），则只会删除通过 SELECT 策略可见的行。请注意，默认情况下没有行可见，因此你需要至少有一个 SELECT/ALL 策略来使行可见。 案例教程 link案例1 （删除记录） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Spain&amp;#39;);&#xD;const { error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.eq(&amp;#39;id&amp;#39;, 1)&#xD;{&#xD;&amp;#34;status&amp;#34;: 204,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;No Content&amp;#34;&#xD;}&#xD;参数说明 link&#xD;选项（option）&#xD;[必要参数]&#xD;object类型&#xD;命名的参数&#xA;特性&#xD;count&#xD;optional&#xD;exact | planned | estimated&#xD;用来计算更新行的计数算法。&#xA;exact:可以精确计算行数，但执行速度较慢。执行 &amp;ldquo;COUNT(*)&amp;ldquo;操作。</description>
    </item>
    <item>
      <title>Update 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/update/</guid>
      <description>在表（table）或视图（view）执行 UPDATE 更新数据操作。&#xA;update() 应该始终与筛选器 (Filters) 结合使用，以便定位您希望更新的项目。 案例教程 link案例1 （更新数据） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Taiwan&amp;#39;);&#xD;const { error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ name: &amp;#39;Australia&amp;#39; })&#xD;.eq(&amp;#39;id&amp;#39;, 1)&#xD;{&#xD;&amp;#34;status&amp;#34;: 204,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;No Content&amp;#34;&#xD;}&#xD;案例2 （更新一个记录并返回） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Singapore&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>Upsert 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/upsert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/upsert/</guid>
      <description>upsert()用于对表（table）或视图（view）执行 UPSERT 操作。&#xA;在关系型数据库中，Upsert是一种结合了&amp;quot;插入（Insert）&amp;ldquo;和&amp;quot;更新（Update）&amp;ldquo;的操作,它允许我们在表或视图上执行插入或更新操作。 通常情况下，当我们想要向数据库中插入一行数据时，我们会使用INSERT语句。 但是，如果该行数据已经存在（通常通过主键来判断），我们可能希望更新该行数据而不是插入重复的数据。&#xA;Upsert通过传递列到onConflict方法，我们可以使用.upsert()来实现以下功能：&#xA;如果不存在具有相应onConflict列的行，则执行等效于.insert()的插入操作。 如果存在具有相应onConflict列的行，则根据ignoreDuplicates的设置执行另一种操作。 需要注意的是，为了使用upsert，必须在values中包含主键。主键是用于唯一标识表中每一行的一列或一组列，确保数据的唯一性和完整性。&#xA;案例教程 link案例1 （Upsert数据） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.upsert({ id: 1, name: &amp;#39;Albania&amp;#39; })&#xD;.select()&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 201,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Created&amp;#34;&#xD;}&#xD;案例2 （批量Upsert数据） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>使用过滤器</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/using-filters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/using-filters/</guid>
      <description>过滤器允许你只返回符合某些条件的记录。&#xA;过滤器可以用于select(), update(), upsert(), 和delete()查询。&#xA;如果一个Postgres函数返回一个表的响应，你也可以应用过滤器。&#xA;案例1 （应用过滤器） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;The Shire&amp;#39;) // Correct&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;The Shire&amp;#39;) // Incorrect&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;过滤器必须在select(), update()、upsert()、delete()和rpc()之后，并在修改器之前应用。&#xA;案例2 （链式） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.gte(&amp;#39;population&amp;#39;, 1000)&#xD;.lt(&amp;#39;population&amp;#39;, 10000)&#xD;过滤器可以串联起来，产生高级查询。例如。 来查询人口在1,000和10,000之间的城市。&#xA;案例3 （条件链式） link&#xD;使用方法&#xD;注意事项&#xD;const filterByName = null&#xD;const filterPopLow = 1000&#xD;const filterPopHigh = 10000&#xD;let query = supabase&#xD;.</description>
    </item>
    <item>
      <title>limit()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/limit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/limit/</guid>
      <description>通过count限制查询结果。&#xA;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.limit(1)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （在外键表中） link&#xD;建表&#xD;使用方法&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;create table&#xD;cities (&#xD;id int8 primary key,&#xD;country_id int8 not null references countries,&#xD;name text&#xD;);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;United States&amp;#39;);&#xD;insert into&#xD;cities (id, country_id, name)&#xD;values&#xD;(1, 1, &amp;#39;Atlanta&amp;#39;),&#xD;(2, 1, &amp;#39;New York City&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>returns()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/db-returns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/javascript/database/modifier/db-returns/</guid>
      <description>覆盖返回数据（data）的类型。&#xA;案例教程 link案例1 (覆盖成功响应的类型) link&#xD;使用方法&#xD;返回结果&#xD;const { data } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.returns&amp;lt;MyType&amp;gt;()&#xD;let x: typeof data // MyType | null&#xD;</description>
    </item>
    <item>
      <title>returns()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/db-returns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/db-returns/</guid>
      <description>覆盖返回数据（data）的类型。&#xA;案例教程 link案例1 (覆盖成功响应的类型) link&#xD;使用方法&#xD;返回结果&#xD;const { data } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.returns&amp;lt;MyType&amp;gt;()&#xD;let x: typeof data // MyType | null&#xD;</description>
    </item>
    <item>
      <title>使用修改器</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/using-modifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/using-modifiers/</guid>
      <description>过滤器是在行的层面上工作的&amp;ndash;它们允许你在不改变行的形状的情况下，返回只符合特定条件的行。 只符合某些条件的行，而不改变行的形状。修改器是不符合该定义的一切，允许你改变响应的格式（例如，返回一个CSV字符串）。&#xA;修改器必须在过滤器之后指定。有些修改器只适用于一些修改器只适用于返回行的查询（例如，select()或rpc()在一个返回表的函数上返回表格响应的函数）。</description>
    </item>
    <item>
      <title>containedBy()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/containedby/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/containedby/</guid>
      <description>该方法仅用于在 jsonb、数组（array）和范围（range）列上进行过滤&#xA;contains()的作用是匹配那些其中每个元素都被包含在指定的值中的行。&#xA;换句话说，在指定列中，给定的数组（array）是匹配出来的记录值的子集&#xA;也就是说，在指定列中，匹配出来的记录的值包含了给定的数组（array）的所有元素。&#xA;案例教程 link案例1 （关于数组列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;classes (&#xD;id int8 primary key,&#xD;name text,&#xD;days text[]&#xD;);&#xD;insert into&#xD;classes (id, name, days)&#xD;values&#xD;(1, &amp;#39;Chemistry&amp;#39;, array[&amp;#39;monday&amp;#39;, &amp;#39;friday&amp;#39;]),&#xD;(2, &amp;#39;History&amp;#39;, array[&amp;#39;monday&amp;#39;, &amp;#39;wednesday&amp;#39;, &amp;#39;thursday&amp;#39;]);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;classes&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.containedBy(&amp;#39;days&amp;#39;, [&amp;#39;monday&amp;#39;, &amp;#39;tuesday&amp;#39;, &amp;#39;wednesday&amp;#39;, &amp;#39;friday&amp;#39;])&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Chemistry&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （关于范围列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>contains()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/contains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/contains/</guid>
      <description>该方法仅用于在 jsonb、数组（array）和范围（range）列上进行过滤&#xA;contains()的作用是匹配包含指定元素的行。&#xA;换句话说，在指定列中，匹配出来的记录的值是给定数组（array）的子集。&#xA;也就是说，在指定列中，给定的数组（array）包含了匹配出记录的所有元素。&#xA;案例教程 link案例1 （关于数组列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;issues (&#xD;id int8 primary key,&#xD;title text,&#xD;tags text[]&#xD;);&#xD;insert into&#xD;issues (id, title, tags)&#xD;values&#xD;(1, &amp;#39;Cache invalidation is not working&amp;#39;, array[&amp;#39;is:open&amp;#39;, &amp;#39;severity:high&amp;#39;, &amp;#39;priority:low&amp;#39;]),&#xD;(2, &amp;#39;Use better names&amp;#39;, array[&amp;#39;is:open&amp;#39;, &amp;#39;severity:low&amp;#39;, &amp;#39;priority:medium&amp;#39;]);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;users&amp;#39;)&#xD;.select()&#xD;.contains(&amp;#39;tags&amp;#39;, [&amp;#39;is:open&amp;#39;, &amp;#39;severity:high&amp;#39;, &amp;#39;priority:low&amp;#39;]); {&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;title&amp;#34;: &amp;#34;Cache invalidation is not working&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （关于范围列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>abortSignal()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/db-abortsignal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/db-abortsignal/</guid>
      <description>设置获取请求的AbortSignal。&#xA;案例教程 link案例1 link&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;const ac = new AbortController()&#xD;ac.abort()&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;very_big_table&amp;#39;)&#xD;.select()&#xD;.abortSignal(ac.signal)&#xD;{&#xD;&amp;#34;error&amp;#34;: {&#xD;&amp;#34;message&amp;#34;: &amp;#34;FetchError: The user aborted a request.&amp;#34;,&#xD;&amp;#34;details&amp;#34;: &amp;#34;&amp;#34;,&#xD;&amp;#34;hint&amp;#34;: &amp;#34;&amp;#34;,&#xD;&amp;#34;code&amp;#34;: &amp;#34;&amp;#34;&#xD;},&#xD;&amp;#34;status&amp;#34;: 400,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Bad Request&amp;#34;&#xD;}&#xD;你可以使用 AbortController 来中止请求。 请注意，对于被中止的请求，状态 (status) 和状态文本 (statusText) 并不具有实际意义，因为请求未能完成。&#xA;参数说明 link&#xD;signal&#xD;[必要参数]&#xD;AbortSignal类型&#xD;用于获取请求的AbortSignal</description>
    </item>
    <item>
      <title>csv()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/db-csv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/db-csv/</guid>
      <description>以 CSV 格式将数据（data）作为字符串返回。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.csv()&#xD;{&#xD;&amp;#34;data&amp;#34;: &amp;#34;id,name\n1,Afghanistan\n2,Albania\n3,Algeria&amp;#34;,&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;默认情况下，数据以 JSON 格式返回，但也可以选择返回 CSV 格式。</description>
    </item>
    <item>
      <title>select()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/db-modifiers-select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/db-modifiers-select/</guid>
      <description>对查询结果执行SELECT。&#xA;默认情况下，.insert(), .update(), .upsert(), 和 .delete()不会返回修改过的记录。通过调用这个方法，修改过的行会返回到data。&#xA;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.upsert({ id: 1, name: &amp;#39;Algeria&amp;#39; })&#xD;.select()&#xD;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.upsert({ id: 1, name: &amp;#39;Algeria&amp;#39; })&#xD;.select()&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 201,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;Created&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[可选参数]&#xD;query类型&#xD;要检索的列，用逗号分隔</description>
    </item>
    <item>
      <title>eq()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/eq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/eq/</guid>
      <description>eq()用于匹配列值等于指定值的行。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;Albania&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;要检查column的值是否为NULL，你应该使用.is()来代替。&#xA;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>filter()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/filter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/filter/</guid>
      <description>仅匹配满足过滤器条件的行。&#xA;尽管filter()函数是一种通用的筛选方式，但为了代码的可读性和维护性，官方建议优先使用特定的筛选方法，以利用更简洁和直观的筛选语法。 例如，使用eq()、gt()、lt()等特定的筛选方法，可以使查询更加清晰和易于理解。&#xA;filter() 期望您使用原始的 PostgREST语法 来指定过滤器的值。&#xA;.filter(&amp;#39;id&amp;#39;, &amp;#39;in&amp;#39;, &amp;#39;(5,6,7)&amp;#39;) // Use `()` for `in` filter&#xD;.filter(&amp;#39;arraycol&amp;#39;, &amp;#39;cs&amp;#39;, &amp;#39;{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use `cs` for `contains()`, `{}` for array values&#xD;案例教程 link案例1 （和select一起使用） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.filter(&amp;#39;name&amp;#39;, &amp;#39;in&amp;#39;, &amp;#39;(&amp;#34;Algeria&amp;#34;,&amp;#34;Japan&amp;#34;)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （在外部表上） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;create table&#xD;cities (&#xD;id int8 primary key,&#xD;country_id int8 not null references countries,&#xD;name text&#xD;);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Germany&amp;#39;),&#xD;(2, &amp;#39;Indonesia&amp;#39;);&#xD;insert into&#xD;cities (id, country_id, name)&#xD;values&#xD;(1, 2, &amp;#39;Bali&amp;#39;),&#xD;(2, 1, &amp;#39;Munich&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>gt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/gt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/gt/</guid>
      <description>gt()用于查找所有在所述列（column）上的值大于指定值（value）的记录。&#xA;案例教程 link案例1 （使用select） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.gt(&amp;#39;id&amp;#39;, 2)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;当使用保留字作为列名时，需要添加双引号，例如：.gt(&#39;&amp;quot;order&amp;quot;&#39;, 2)&#xA;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>gte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/gte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/gte/</guid>
      <description>gte()用于查找所有在所述列（column）上的值大于或等于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.gte(&amp;#39;id&amp;#39;, 2)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>ilike()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/ilike/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/ilike/</guid>
      <description>ilike()用于查找所有在所述列（column）上的值与提供的 模板（pattern）相符的记录（不区分大小写）。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.ilike(&amp;#39;name&amp;#39;, &amp;#39;%Alba%&amp;#39;)&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;模式（pattern）&#xD;[必要参数]&#xD;string类型&#xD;与之匹配的模式</description>
    </item>
    <item>
      <title>in()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/in/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/in/</guid>
      <description>in_()用于查找所有在指定列（column）上数值存在于指定值列表（arry）中的记录&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.in(&amp;#39;name&amp;#39;, [&amp;#39;Albania&amp;#39;, &amp;#39;Algeria&amp;#39;])&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型数组&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>is()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/is/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/is/</guid>
      <description>仅匹配列值与指定值相等的行。&#xA;对于非boolean型列，这只与检查column的值是否为NULL有关。 column的值是NULL，通过设置value为null。&#xA;对于boolean型列，你也可以将value设置为true或false，它的行为与 它的行为与.eq()相同。&#xA;案例教程 link案例1 (检查是否为 null) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;null&amp;#39;),&#xD;(2, null);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.is(&amp;#39;name&amp;#39;, null)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;null&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;使用eq()筛选器在过滤null时不起作用。相反，您需要使用is()。&#xA;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;null或者boolean类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>like()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/like/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/like/</guid>
      <description>like()用于查找所有在所述列（column）上的值与提供的 模板（pattern）相符的记录（区分大小写）。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.like(&amp;#39;name&amp;#39;, &amp;#39;%Alba%&amp;#39;)&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;模式（pattern）&#xD;[必要参数]&#xD;string类型&#xD;与之匹配的模式</description>
    </item>
    <item>
      <title>lt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/lt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/lt/</guid>
      <description>lt()用于查找所有在所述列（column）上的值小于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.lt(&amp;#39;id&amp;#39;, 2)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>lte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/lte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/lte/</guid>
      <description>lte()用于查找所有在所述列（column）上的值小于或等于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.lte(&amp;#39;id&amp;#39;, 2)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>match()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/match/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/match/</guid>
      <description>仅匹配每个查询(query)键中的列与其关联值相等的行。相当于多个 .eq() 的简写。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.match({ id: 2, name: &amp;#39;Albania&amp;#39; })&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;查询（query）&#xD;[必要参数]&#xD;Record类型&#xD;用于筛选的对象，其中列名作为键映射到它们的筛选值。</description>
    </item>
    <item>
      <title>maybeSingle()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/maybesingle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/maybesingle/</guid>
      <description>将数据(data)作为单个对象返回，而不是返回一个对象数组。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;Singapore&amp;#39;)&#xD;.maybeSingle()&#xD;{&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;</description>
    </item>
    <item>
      <title>rangeLte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangelte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangelte/</guid>
      <description>仅适用于范围列&#xA;仅匹配列中的每个元素要么包含在范围(range)内，要么小于范围(range)中的任何元素的行。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeLte(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-01 14:00, 2000-01-01 16:00)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Emerald&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-01 13:00:00\&amp;#34;,\&amp;#34;2000-01-01 15:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>neq()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/neq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/neq/</guid>
      <description>neq()用于匹配列值不等于指定值的行。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.neq(&amp;#39;name&amp;#39;, &amp;#39;Albania&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列&#xA;值（value）&#xD;[必要参数]&#xD;任意类型&#xD;用来过滤的值</description>
    </item>
    <item>
      <title>not()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/not/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/not/</guid>
      <description>仅匹配不满足筛选条件的行。&#xA;not()函数要求您使用原始的PostgREST语法来表示筛选条件的值。&#xA;.not(&amp;#39;id&amp;#39;, &amp;#39;in&amp;#39;, &amp;#39;(5,6,7)&amp;#39;) // Use `()` for `in` filter&#xD;.not(&amp;#39;arraycol&amp;#39;, &amp;#39;cs&amp;#39;, &amp;#39;{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use `cs` for `contains()`, `{}` for array values&#xD;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;null&amp;#39;),&#xD;(2, null);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select()&#xD;.not(&amp;#39;name&amp;#39;, &amp;#39;is&amp;#39;, null)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;null&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;列（column）&#xD;[必要参数]&#xD;string类型&#xD;要过滤的列</description>
    </item>
    <item>
      <title>调用Postgres函数</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/rpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/rpc/</guid>
      <description>你可以将Postgres函数作为远程过程调用（Remote Procedure Calls）来调用，即你可以从任何地方执行数据库中的逻辑。 函数在逻辑很少更改时非常有用，比如用于密码重置和更新等情况。&#xA;下面是一个示例的 Postgres 函数定义：&#xA;create or replace function hello_world() returns text as $$&#xD;select &amp;#39;Hello world&amp;#39;;&#xD;$$ language sql;&#xD;这个函数叫做hello_world，它不带参数，返回一个text类型的结果。函数的逻辑很简单，就是返回字符串&amp;quot;Hello world&amp;quot;。 你可以从任何地方调用这个函数，并获得结果&amp;quot;Hello world&amp;quot;。&#xA;案例教程 link案例1 （调用一个没有参数的Postgres函数） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create function hello_world() returns text as $$&#xD;select &amp;#39;Hello world&amp;#39;;&#xD;$$ language sql;&#xD;const { data, error } = await supabase.rpc(&amp;#39;hello_world&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: &amp;#34;Hello world&amp;#34;,&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （调用一个带参数的Postgres函数） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create function echo(say text) returns text as $$&#xD;select say;&#xD;$$ language sql;&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>or()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/or/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/or/</guid>
      <description>仅匹配满足至少一个过滤条件的行。&#xA;or() 期望您使用原始的 PostgREST语法 来指定过滤器的名称和值。&#xA;.or(&amp;#39;id.in.(5,6,7), arraycol.cs.{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use `()` for `in` filter, `{}` for array values and `cs` for `contains()`.&#xD;.or(&amp;#39;id.in.(5,6,7), arraycol.cd.{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use `cd` for `containedBy()`&#xD;案例教程 link案例1 （和select一起使用） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.or(&amp;#39;id.eq.2,name.eq.Algeria&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （与and一起使用or） link&#xD;建表&#xD;使用方法&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>order()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/order/</guid>
      <description>按列对查询结果进行排序。&#xA;你可以多次调用这个方法来按多列排序。&#xA;你可以对外部表进行排序，但这并不影响对当前表的排序。&#xA;案例教程 link案例1 （使用select） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;id&amp;#39;, &amp;#39;name&amp;#39;)&#xD;.order(&amp;#39;id&amp;#39;, { ascending: false })&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 3,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Algeria&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （在外部表） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;&gt;&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;create table&#xD;cities (&#xD;id int8 primary key,&#xD;country_id int8 not null references countries,&#xD;name text&#xD;);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;United States&amp;#39;),&#xD;(2, &amp;#39;Vanuatu&amp;#39;);&#xD;insert into&#xD;cities (id, country_id, name)&#xD;values&#xD;(1, 1, &amp;#39;Atlanta&amp;#39;),&#xD;(2, 1, &amp;#39;New York City&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>overlaps()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/overlaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/overlaps/</guid>
      <description>仅适用于数组列和范围列&#xA;仅匹配列（column）和值（value）有一个共同元素的行。&#xA;案例教程 link案例1 （关于数组列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;issues (&#xD;id int8 primary key,&#xD;title text,&#xD;tags text[]&#xD;);&#xD;insert into&#xD;issues (id, title, tags)&#xD;values&#xD;(1, &amp;#39;Cache invalidation is not working&amp;#39;, array[&amp;#39;is:open&amp;#39;, &amp;#39;severity:high&amp;#39;, &amp;#39;priority:low&amp;#39;]),&#xD;(2, &amp;#39;Use better names&amp;#39;, array[&amp;#39;is:open&amp;#39;, &amp;#39;severity:low&amp;#39;, &amp;#39;priority:medium&amp;#39;]);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;issues&amp;#39;)&#xD;.select(&amp;#39;title&amp;#39;)&#xD;.overlaps(&amp;#39;tags&amp;#39;, [&amp;#39;is:closed&amp;#39;, &amp;#39;severity:high&amp;#39;])&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;title&amp;#34;: &amp;#34;Cache invalidation is not working&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;案例2 （关于范围列） link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>range()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/range/</guid>
      <description>通过 from和 to来限制查询结果。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.range(0, 1)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;{&#xD;&amp;#34;name&amp;#34;: &amp;#34;Albania&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;参数说明 link&#xD;from&#xD;[必要参数]&#xD;number类型&#xD;用于限制结果的起始索引&#xA;to&#xD;[必要参数]&#xD;number类型&#xD;限制结果的最后一个索引&#xA;选项（option）&#xD;[可选参数]&#xD;object类型&#xD;命名的参数</description>
    </item>
    <item>
      <title>rangeAdjacent()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangeadjacent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangeadjacent/</guid>
      <description>仅适用于范围列&#xA;仅匹配列与范围(range)互斥且两个范围之间不能有任何元素的行。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeAdjacent(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-01 12:00, 2000-01-01 13:00)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Emerald&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-01 13:00:00\&amp;#34;,\&amp;#34;2000-01-01 15:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>rangeGt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangegt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangegt/</guid>
      <description>仅适用于范围（range）列&#xA;仅匹配列中的每个元素都大于范围(range)中的任何元素的行。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeGt(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-02 08:00, 2000-01-02 09:00)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Topaz&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-02 09:00:00\&amp;#34;,\&amp;#34;2000-01-02 10:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>rangeGte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangegte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangegte/</guid>
      <description>仅适用于范围（range）列&#xA;仅匹配列中的每个元素要么包含在范围(range)内，要么大于范围(range)中的任何元素的行。&#xA;案例教程 link案例1 (使用select) link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeGte(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-02 08:30, 2000-01-02 09:30)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 2,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Topaz&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-02 09:00:00\&amp;#34;,\&amp;#34;2000-01-02 10:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>rangeLt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangelt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/rangelt/</guid>
      <description>仅适用于范围列&#xA;仅匹配列中的每个元素都小于范围(range)中的任何元素的行。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;注意事项&#xD;create table&#xD;reservations (&#xD;id int8 primary key,&#xD;room_name text,&#xD;during tsrange&#xD;);&#xD;insert into&#xD;reservations (id, room_name, during)&#xD;values&#xD;(1, &amp;#39;Emerald&amp;#39;, &amp;#39;[2000-01-01 13:00, 2000-01-01 15:00)&amp;#39;),&#xD;(2, &amp;#39;Topaz&amp;#39;, &amp;#39;[2000-01-02 09:00, 2000-01-02 10:00)&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;reservations&amp;#39;)&#xD;.select()&#xD;.rangeLt(&amp;#39;during&amp;#39;, &amp;#39;[2000-01-01 15:00, 2000-01-01 16:00)&amp;#39;)&#xD;{&#xD;&amp;#34;data&amp;#34;: [&#xD;{&#xD;&amp;#34;id&amp;#34;: 1,&#xD;&amp;#34;room_name&amp;#34;: &amp;#34;Emerald&amp;#34;,&#xD;&amp;#34;during&amp;#34;: &amp;#34;[\&amp;#34;2000-01-01 13:00:00\&amp;#34;,\&amp;#34;2000-01-01 15:00:00\&amp;#34;)&amp;#34;&#xD;}&#xD;],&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;Postgres 支持多种范围类型。您可以使用范围值的字符串表示来过滤范围列。</description>
    </item>
    <item>
      <title>single()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/single/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/modifier/single/</guid>
      <description>将数据(data)作为单个对象返回，而不是返回一个对象数组。&#xA;案例教程 link案例1 link&#xD;建表&#xD;使用方法&#xD;返回结果&#xD;create table&#xD;countries (id int8 primary key, name text);&#xD;insert into&#xD;countries (id, name)&#xD;values&#xD;(1, &amp;#39;Afghanistan&amp;#39;),&#xD;(2, &amp;#39;Albania&amp;#39;),&#xD;(3, &amp;#39;Algeria&amp;#39;);&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;)&#xD;.limit(1)&#xD;.single()&#xD;{&#xD;&amp;#34;data&amp;#34;: {&#xD;&amp;#34;name&amp;#34;: &amp;#34;Afghanistan&amp;#34;&#xD;},&#xD;&amp;#34;status&amp;#34;: 200,&#xD;&amp;#34;statusText&amp;#34;: &amp;#34;OK&amp;#34;&#xD;}&#xD;</description>
    </item>
    <item>
      <title>textSearch()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/textsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/database/filter/textsearch/</guid>
      <description>仅适用于文本和 tsvector 列。&#xA;textSearch()作用是找到所有在指定列上的 tsvector 值与给定的 to_tsquery 查询条件匹配的记录。&#xA;更多信息，请参见Postgres全文搜索。 案例教程 link案例1 （文本搜索） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;quotes&amp;#39;)&#xD;.select(&amp;#39;catchphrase&amp;#39;)&#xD;.textSearch(&amp;#39;catchphrase&amp;#39;, `&amp;#39;fat&amp;#39; &amp;amp; &amp;#39;cat&amp;#39;`, {&#xD;config: &amp;#39;english&amp;#39;&#xD;})&#xD;案例2 （基本归一化） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase&#xD;.from(&amp;#39;quotes&amp;#39;)&#xD;.select(&amp;#39;catchphrase&amp;#39;)&#xD;.textSearch(&amp;#39;catchphrase&amp;#39;, `&amp;#39;fat&amp;#39; &amp;amp; &amp;#39;cat&amp;#39;`, {&#xD;type: &amp;#39;plain&amp;#39;,&#xD;config: &amp;#39;english&amp;#39;&#xD;})&#xD;使用PostgreSQL的plainto_tsquery函数。&#xA;案例3 （全面归一化） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase&#xD;.</description>
    </item>
    <item>
      <title>from.download()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-download/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-download/</guid>
      <description>from.download()的作用是从私有存储桶下载文件。对于公共存储桶，从 getPublicUrl 返回的 URL 发起请求。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （下载文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.download(&amp;#39;folder/avatar1.png&amp;#39;)&#xD;案例2 （带transform参数的下载文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.download(&amp;#39;folder/avatar1.png&amp;#39;, {&#xD;transform: {&#xD;width: 100,&#xD;height: 100,&#xD;quality: 80&#xD;}&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.png的格式。在尝试上传之前，必须确保存储桶已经存在。&#xA;选项（option）&#xD;[可选参数]&#xD;object类型 特性&#xD;transform&#xD;[可选参数]&#xD;TransformOptions类型&#xD;在向客户端提供资源之前对资源进行转换。&#xA;特性&#xD;format&#xD;[可选参数]&#xD;&#34;origin&#34;&#xD;指定请求的图像格式。当使用 &amp;lsquo;origin&amp;rsquo; 时，我们强制格式与原始图像相同。如果未传递此选项，则将图像优化为现代图像格式，如 Webp。</description>
    </item>
    <item>
      <title>from.upload()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-upload/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-upload/</guid>
      <description>from.upload()用于将一个文件上传到一个现有的桶。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：仅在上传新文件时需要插入insert权限，以及在更新文件时需要选择select、插入insert和更新updata权限 请参考存储指南中关于访问控制的工作方式。&#xA;对于 React Native，使用 Blob、File 或 FormData 并不能按预期工作。相反，应该使用来自 base64 文件数据的 ArrayBuffer 来上传文件，参见下面的示例。&#xA;案例教程 link案例1 （上传文件） link&#xD;使用方法&#xD;const avatarFile = event.target.files[0]&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.upload(&amp;#39;public/avatar1.png&amp;#39;, avatarFile, {&#xD;cacheControl: &amp;#39;3600&amp;#39;,&#xD;upsert: false&#xD;})&#xD;案例2 （使用来自 base64 文件数据的 ArrayBuffer 来上传文件） link&#xD;使用方法&#xD;const avatarFile = event.target.files[0]&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.upload(&amp;#39;public/avatar1.png&amp;#39;, avatarFile, {&#xD;cacheControl: &amp;#39;3600&amp;#39;,&#xD;upsert: false&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.</description>
    </item>
    <item>
      <title>from.list()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-list/</guid>
      <description>from.list()用于列出存储桶内的所有文件。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （在存储桶中列出文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.list(&amp;#39;folder&amp;#39;, {&#xD;limit: 100,&#xD;offset: 0,&#xD;sortBy: { column: &amp;#39;name&amp;#39;, order: &amp;#39;asc&amp;#39; },&#xD;})&#xD;案例2 （在存储桶中搜索文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.list(&amp;#39;folder&amp;#39;, {&#xD;limit: 100,&#xD;offset: 0,&#xD;sortBy: { column: &amp;#39;name&amp;#39;, order: &amp;#39;asc&amp;#39; },&#xD;search: &amp;#39;jon&amp;#39;&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[可选参数]&#xD;string类型&#xD;文件夹路径。</description>
    </item>
    <item>
      <title>from.move()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-move/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-move/</guid>
      <description>from.move()用于将一个现有的文件移动到同一桶中的新路径。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：update和select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （移动文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.move(&amp;#39;public/avatar1.png&amp;#39;, &amp;#39;private/avatar2.png&amp;#39;)&#xD;参数说明 link&#xD;fromPath&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.png的格式。在尝试上传之前，必须确保存储桶已经存在。&#xA;toPath&#xD;[必要参数]&#xD;string类型&#xD;新的文件路径，包括新的文件名。例如folder/image-new.png。</description>
    </item>
    <item>
      <title>createBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-createbucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-createbucket/</guid>
      <description>createBucket()用于创建一个新的存储桶&#xA;需要RLS策略权限:&#xA;buckets表的权限: insert表权限 objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （创建一个存储桶） link&#xD;使用方法&#xD;const { data, error } = await supabase .storage&#xD;.createBucket(&amp;#39;avatars&amp;#39;, {&#xD;public: false,&#xD;allowedMimeTypes: [&amp;#39;image/png&amp;#39;],&#xD;fileSizeLimit: 1024&#xD;})&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。&#xA;选项（option）&#xD;[必要参数]&#xD;object类型&#xD;特性&#xD;public&#xD;[必要参数]&#xD;boolean类型&#xD;存储桶的可见性。公开桶不需要授权令牌来下载对象，但对于所有其他操作仍需要有效的令牌。默认情况下，存储桶是私有的。&#xA;allowedMimeTypes&#xD;[可选参数]&#xD;object类型&#xD;指定此存储桶在上传过程中允许接受的 MIME 类型。默认值为 null，允许上传具有所有 MIME 类型的文件。每个指定的 MIME 类型可以是通配符，例如 image/*，也可以是特定的 MIME 类型，例如 image/png。&#xA;fileSizeLimit&#xD;[可选参数]&#xD;null | 字符串 | 数字&#xD;指定可以上传到此存储桶的最大文件大小（以字节为单位）。全局文件大小限制优先于此值。默认值为 null，表示不设置每个存储桶的文件大小限制。</description>
    </item>
    <item>
      <title>deleteBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-deletebucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-deletebucket/</guid>
      <description>deleteBucket()用于删除现有的存储桶。&#xA;如果存储桶内存在对象，则无法删除存储桶。您必须首先清空empty()存储桶。&#xA;需要RLS策略权限:&#xA;buckets表的权限: select和delete objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （删除一个存储桶） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.deleteBucket(&amp;#39;avatars&amp;#39;)&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。</description>
    </item>
    <item>
      <title>from.copy()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-copy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-copy/</guid>
      <description>from.copy()用于将一个现有的文件复制到存储桶中的新路径。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：insert和select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （复制文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.copy(&amp;#39;public/avatar1.png&amp;#39;, &amp;#39;private/avatar2.png&amp;#39;)&#xD;参数说明 link&#xD;fromPath&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.png的格式。在尝试上传之前，必须确保存储桶已经存在。&#xA;toPath&#xD;[必要参数]&#xD;string类型&#xD;新的文件路径，包括新的文件名。例如folder/image-copy.png。</description>
    </item>
    <item>
      <title>from.createSignedUrl()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-createsignedurl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-createsignedurl/</guid>
      <description>创建一个签名的URL。使用签名的URL在固定时间内分享一个文件。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （创建一个带有签名的URL） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrl(&amp;#39;folder/avatar1.png&amp;#39;, 60)&#xD;案例2 （创建带有转换的签名URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrl(&amp;#39;folder/avatar1.png&amp;#39;, 60, {&#xD;transform: {&#xD;width: 100,&#xD;height: 100,&#xD;}&#xD;})&#xD;案例3 （创建用于触发资源下载的签名URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrl(&amp;#39;folder/avatar1.png&amp;#39;, 60, {&#xD;download: true,&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括当前文件名。例如 folder/image.</description>
    </item>
    <item>
      <title>from.createSignedUrls()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-createsignedurls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-createsignedurls/</guid>
      <description>from.createSignedUrls()用于创建多个签名的URL。使用签名的URL在固定的时间内分享一个文件。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （创建多个带有签名的URL） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrls([&amp;#39;folder/avatar1.png&amp;#39;, &amp;#39;folder/avatar2.png&amp;#39;], 60)&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string[]类型（字符串数组）&#xD;要下载的文件路径，包括当前文件名。例如：[&amp;lsquo;folder/image.png&amp;rsquo;, &amp;lsquo;folder2/image2.png&amp;rsquo;]。&#xA;expiresIn&#xD;[必要参数]&#xD;数字类型&#xD;签名URL的过期时间，以秒为单位。例如，对于有效期为一分钟的URL，可以设置为 60。&#xA;选项（option）&#xD;[可选参数]&#xD;object类型&#xD;特性&#xD;download&#xD;[可选参数]&#xD;string | boolean&#xD;如果设置为 true，将触发文件下载。如果您希望使用不同的文件名触发下载，请将此参数设置为所需的文件名。</description>
    </item>
    <item>
      <title>emptyBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-emptybucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-emptybucket/</guid>
      <description>emptyBucket()用于移除单个桶内的所有对象。&#xA;需要RLS策略权限:&#xA;buckets表的权限: select objects表的权限：select和delet 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （清空一个存储桶） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.emptyBucket(&amp;#39;avatars&amp;#39;)&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。</description>
    </item>
    <item>
      <title>from.getPublicUrl()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-getpublicurl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-getpublicurl/</guid>
      <description>from.getPublicUrl()是用于获取公开存储桶中资源URL的函数。如果你不想使用这个函数，也可以通过将存储桶URL与资源路径拼接在一起来构建公开（public）URL。&#xA;这个函数不会验证存储桶是否为公开（public）。如果为非公开的存储桶创建了公开（public）URL，你将无法下载资源。&#xA;需要将存储桶设置为公开（public）状态，可以通过 updateBucket() 方法或者在 MemFireCloud应用控制台的存储页面中，选择你需要操作的存储桶，点击该存储桶的扩展按钮。选择编辑存储桶，然后选择公开存储桶按钮即可完成。&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （返回公开存储桶中资源的URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;public-bucket&amp;#39;)&#xD;.getPublicUrl(&amp;#39;folder/avatar1.png&amp;#39;)&#xD;案例2 （返回公开存储桶中带有转换的资源的URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;public-bucket&amp;#39;)&#xD;.getPublicUrl(&amp;#39;folder/avatar1.png&amp;#39;, {&#xD;transform: {&#xD;width: 100,&#xD;height: 100,&#xD;}&#xD;})&#xD;案例3 （返回触发公开存储桶中资源下载的URL） link&#xD;使用方法&#xD;const { data } = supabase&#xD;.storage&#xD;.from(&amp;#39;public-bucket&amp;#39;)&#xD;.getPublicUrl(&amp;#39;folder/avatar1.png&amp;#39;, {&#xD;download: true,&#xD;})&#xD;参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括当前文件名。例如 folder/image.</description>
    </item>
    <item>
      <title>from.remove()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-remove/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-remove/</guid>
      <description>from.remove()用于删除存储桶中的文件&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：delete和select权限 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （删除文件） link&#xD;使用方法&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.remove([&amp;#39;folder/avatar1.png&amp;#39;])&#xD;参数说明 link&#xD;paths&#xD;[必要参数]&#xD;string[]类型（字符串数组）&#xD;一个要删除的文件数组，包括路径和文件名。例如[folder/image.png]。</description>
    </item>
    <item>
      <title>from.update()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-from-update/</guid>
      <description>from.update()用于实现一个新文件替换指定路径下的现有文件。.&#xA;需要RLS策略权限:&#xA;buckets表的权限: 无 objects表的权限：update和select权限 请参考存储指南中关于访问控制的工作方式。&#xA;对于使用 React Native 进行开发的情况，直接使用 Blob、File 或 FormData 对象来进行文件操作可能会无法达到预期的效果。 相反，建议使用来自 base64 文件数据的 ArrayBuffer 来更新文件。可以参考提供的示例代码来了解如何以此方式进行文件更新操作。&#xA;案例教程 link案例1 （更新文件） link&#xD;使用方法&#xD;const avatarFile = event.target.files[0]&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.update(&amp;#39;public/avatar1.png&amp;#39;, avatarFile, {&#xD;cacheControl: &amp;#39;3600&amp;#39;,&#xD;upsert: true&#xD;})&#xD;案例2 （使用ArrayBuffer从base64文件数据更新文件） link&#xD;使用方法&#xD;import {decode} from &amp;#39;base64-arraybuffer&amp;#39;&#xD;const { data, error } = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.update(&amp;#39;public/avatar1.png&amp;#39;, decode(&amp;#39;base64FileData&amp;#39;), {&#xD;contentType: &amp;#39;image/png&amp;#39;&#xD;}) 参数说明 link&#xD;路径（path）&#xD;[必要参数]&#xD;string类型&#xD;文件路径，包括文件名。应该采用folder/subfolder/filename.</description>
    </item>
    <item>
      <title>getBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-getbucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-getbucket/</guid>
      <description>getBucket()用于获取现有存储桶的详细信息。&#xA;需要RLS策略权限:&#xA;buckets表的权限: select objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （获取存储桶信息） link&#xD;使用方法&#xD;const { data, error } = await supabase .storage&#xD;.getBucket(&amp;#39;avatars&amp;#39;)&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。</description>
    </item>
    <item>
      <title>listBuckets()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-listbuckets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-listbuckets/</guid>
      <description>listBuckets()用于获取现有项目中所有存储桶的详细信息。&#xA;需要RLS策略权限:&#xA;buckets表的权限: select objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （获取所有存储桶信息） link&#xD;使用方法&#xD;const { data, error } = await supabase .storage&#xD;.listBuckets()&#xD;</description>
    </item>
    <item>
      <title>updateBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-updatebucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/storage/storage-updatebucket/</guid>
      <description>updateBucket()用于更新存储桶&#xA;需要RLS策略权限:&#xA;buckets表的权限: select和update objects表的权限：无 请参考存储指南中关于访问控制的工作方式。&#xA;案例教程 link案例1 （更新存储桶） link&#xD;使用方法&#xD;const { data, error } = await supabase .storage&#xD;.updateBucket(&amp;#39;avatars&amp;#39;, {&#xD;public: false,&#xD;allowedMimeTypes: [&amp;#39;image/png&amp;#39;],&#xD;fileSizeLimit: 1024&#xD;})&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;这是你创建存储桶的唯一标识符。&#xA;选项（option）&#xD;[必要参数]&#xD;object类型&#xD;特性&#xD;public&#xD;[必要参数]&#xD;boolean类型&#xD;存储桶的可见性。公开桶不需要授权令牌来下载对象，但对于所有其他操作仍需要有效的令牌。默认情况下，存储桶是私有的。&#xA;allowedMimeTypes&#xD;[可选参数]&#xD;object类型&#xD;指定此存储桶在上传过程中允许接受的 MIME 类型。默认值为 null，允许上传具有所有 MIME 类型的文件。每个指定的 MIME 类型可以是通配符，例如 image/*，也可以是特定的 MIME 类型，例如 image/png。&#xA;fileSizeLimit&#xD;[可选参数]&#xD;null | 字符串 | 数字&#xD;指定可以上传到此存储桶的最大文件大小（以字节为单位）。全局文件大小限制优先于此值。默认值为 null，表示不设置每个存储桶的文件大小限制。</description>
    </item>
    <item>
      <title>on().subscribe()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/realtime/subscribe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/realtime/subscribe/</guid>
      <description>on().subscribe()创建一个事件处理程序，用于监听变更。&#xA;默认情况下，广播（Broadcast）和在线状态（Presence）对所有项目都是启用的。 对于新项目，默认情况下禁用了监听数据库变更，原因是出于数据库性能和安全方面的考虑。你可以通过管理实时数据的复制功能来启用它。 你可以通过将表的 REPLICA IDENTITY 设置为 FULL（例如，执行 ALTER TABLE your_table REPLICA IDENTITY FULL;），来接收更新和删除操作的&amp;quot;之前&amp;quot;的数据。 删除语句(delete statements)不适用行级安全（Row level security）。当启用行级安全并将复制标识（replica identity）设置为 full 时，只有主键会被发送到客户端。 案例教程 link案例1 （监听广播消息） link&#xD;使用方法&#xD;supabase&#xD;.channel(&amp;#39;any&amp;#39;)&#xD;.on(&amp;#39;broadcast&amp;#39;, { event: &amp;#39;cursor-pos&amp;#39; }, payload =&amp;gt; {&#xD;console.log(&amp;#39;Cursor position received!&amp;#39;, payload)&#xD;})&#xD;.subscribe((status) =&amp;gt; {&#xD;if (status === &amp;#39;SUBSCRIBED&amp;#39;) {&#xD;channel.send({&#xD;type: &amp;#39;broadcast&amp;#39;,&#xD;event: &amp;#39;cursor-pos&amp;#39;,&#xD;payload: { x: Math.random(), y: Math.random() },&#xD;})&#xD;}&#xD;})&#xD;案例2 （监听在线状态同步） link&#xD;使用方法&#xD;const channel = supabase.</description>
    </item>
    <item>
      <title>getChannels()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/realtime/getchannels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/realtime/getchannels/</guid>
      <description>getChannels()用于返回所有的Realtime通道。&#xA;案例教程 link案例1 link&#xD;使用方法&#xD;const channels = supabase.getChannels() </description>
    </item>
    <item>
      <title>removeAllChannels()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/realtime/removeallchannels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/realtime/removeallchannels/</guid>
      <description>removeAllChannels()用于取消订阅并从实时客户端移除所有实时通道。&#xA;移除频道是维护项目的实时服务性能以及在监听Postgres更改时维护数据库性能的好方法。 在客户端断开连接后，MemFire Cloud会自动在30秒后进行清理，但是未使用的频道可能会导致性能下降，特别是当有更多客户端同时订阅时。&#xA;案例教程 link案例1 link&#xD;使用方法&#xD;supabase.removeAllChannels()&#xD;</description>
    </item>
    <item>
      <title>removeChannel()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/realtime/removechannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/realtime/removechannel/</guid>
      <description>removeChannel()用于取消订阅并从实时（realtime）客户端移除实时（realtime）频道。&#xA;移除频道是维护项目的实时服务性能以及在监听Postgres更改时维护数据库性能的好方法。 在客户端断开连接后，MemFire Cloud会自动在30秒后进行清理，但是未使用的频道可能会导致性能下降，特别是当有更多客户端同时订阅时。&#xA;案例教程 link案例1 link&#xD;使用方法&#xD;supabase.removeChannel(myChannel)&#xD;参数说明 link&#xD;频道（channel）&#xD;[必要参数]&#xD;default&#xD;实时（realtime）通道的名称。如果没有显式指定通道名称，系统将使用&amp;quot;default&amp;quot;作为默认值。</description>
    </item>
    <item>
      <title>invoke()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/function/invoke/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/function/invoke/</guid>
      <description>应用使用MemFire Cloud的云函数功能时，需要结合supabase-wechat-stable-v2与memfire-cloud-functions-js 这两个SDK进行云函数的调用。&#xA;使用方法 link在根目录下执行命令，安装依赖&#xA;npm install supabase-wechat-stable-v2&#xD;添加一个js/ts文件与数据库建立连接，添加以下代码，并且将应用的URL和anon_key填写进去。&#xA;import { createClient } from &amp;#39;supabase-wechat-stable-v2&amp;#39;&#xD;const supabaseUrl = &amp;#39;&amp;#39;&#xD;const supabaseAnonKey = &amp;#39;&amp;#39;&#xD;export const supabase = createClient(supabaseUrl, supabaseAnonKey)&#xD;在需要使用云函数的页面调用，填写用户在MemFire Cloud创建的云函数生成的访问地址和访问方法。&#xA;const { data, error } = await functions.invoke(&#xD;&amp;#39;访问地址&amp;#39;,{method:&amp;#39;访问方法&amp;#39;}&#xD;);&#xD;参数 link&#xD;functionName&#xD;required&#xD;string&#xD;要调用的函数的名称&#xA;invokeOptions&#xD;required&#xD;FunctionInvokeOptions&#xD;未提供说明。&#xA;注释 link 需要一个授权标头。 调用参数通常符合Fetch API规范。 当你向函数传递一个body时，我们会自动附加 Blob、ArrayBuffer、File、FormData和 String的Content-Type标头。如果它不符合这些类型，会默认为json，将其序列化并附加Content-Type&#39;头为application/json。用户还可以自定义 Content-Type`。 响应会自动解析为json、blob或form-data，取决于你的函数发送的Content-Type头。默认情况下，响应被解析为text。 示例 link基本调用 link&#xD;const { data, error } = await functions.</description>
    </item>
    <item>
      <title>概览</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/supabase-auth-admin-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/supabase-auth-admin-api/</guid>
      <description> 在 supabase.auth.admin 命名空间下的任何方法都需要使用 service_role 密钥。 这些方法被认为是管理员级别的方法，它们应该只在可信任的服务器端被调用执行，而不应该在客户端浏览器等不受信任的环境中使用。 绝对不要在客户端浏览器中公开或传递 service_role 密钥。因为这个密钥拥有管理用户认证和权限的权限，如果泄露给不信任的用户，可能会导致安全风险. 案例教程 link案例1 （创建服务器端认证客户端） link&#xD;使用方法&#xD;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;const supabase = createClient(supabase_url, service_role_key, {&#xD;auth: {&#xD;autoRefreshToken: false,&#xD;persistSession: false&#xD;}&#xD;})&#xD;// Access auth admin api&#xD;const adminAuthClient = supabase.auth.admin&#xD;</description>
    </item>
    <item>
      <title>createUser()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-createuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-createuser/</guid>
      <description>createUser()用于创建一个新的用户。这个函数应该只在服务器上调用。不要在浏览器中暴露你的service_role密钥。&#xA;为了确认用户的电子邮件地址或电话号码，请将 email_confirm 或 phone_confirm 设置为 true。如果不进行设置，这两个参数的默认值为 false。 createUser() 不会向用户发送确认电子邮件。如果你想发送邀请电子邮件，可以使用 inviteUserByEmail() 方法。 如果你确定所创建的用户的电子邮件或电话号码是合法且经过验证的，你可以将 email_confirm 或 phone_confirm 参数设置为 `true。 案例教程 link案例1 （带有自定义用户元数据） link&#xD;使用方法&#xD;注意事项&#xD;const { data, error } = await supabase.auth.admin.createUser({&#xD;email: &amp;#39;user@email.com&amp;#39;,&#xD;password: &amp;#39;password&amp;#39;,&#xD;user_metadata: { name: &amp;#39;Yoda&amp;#39; }&#xD;})&#xD;如果密码超过了72个字符，它将被截断为前72个字符。&#xA;案例2 （自动确认用户的电子邮件） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.createUser({&#xD;email: &amp;#39;user@email.com&amp;#39;,&#xD;email_confirm: true&#xD;}) 案例3 （自动确认用户的电话号码） link&#xD;使用方法&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>deleteUser()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-deleteuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-deleteuser/</guid>
      <description>deleteUser()用于删除用户。这个过程需要使用 service_role 密钥。&#xA;案例教程 link案例1 （移除一个用户） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.deleteUser(&#xD;&amp;#39;715ed5db-f090-4b8c-a067-640ecee36aa0&amp;#39;&#xD;)&#xD;参数说明 link&#xD;id&#xD;[必要参数]&#xD;string类型&#xD;你想删除的用户ID。&#xA;shouldSoftDelete&#xD;[可选参数]&#xD;boolean类型&#xD;当设置为 true 时，将对用户进行软删除操作（&amp;ldquo;软删除&amp;rdquo; 是一种在数据库中标记数据为已删除但不立即物理删除的操作方式。），即在认证模式（auth schema）中进行软删除。而当设置为 false 时，用户将被物理删除。&#xA;默认情况下，&amp;ldquo;shouldSoftDelete&amp;rdquo; 参数的值为 false，这是为了保持向后兼容性。这意味着如果在调用删除用户的函数时不显式指定 &amp;ldquo;shouldSoftDelete&amp;rdquo; 参数，那么默认情况下用户将会被物理删除，而不是软删除。&#xA;需要特别注意的是绝对不能将这个参数暴露给客户端浏览器。这是因为这个参数涉及到对数据进行软删除或物理删除的决定，是一个敏感的操作。确保在服务器端安全地处理这个参数，并且绝不要在客户端浏览器中传递敏感的 service_role 密钥。</description>
    </item>
    <item>
      <title>listUsers()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-listusers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-listusers/</guid>
      <description>listUsers()用于获取用户列表，默认每页返回50个用户。&#xA;案例教程 link案例1 （获取用户的一页数据） link&#xD;使用方法&#xD;const { data: { users }, error } = await supabase.auth.admin.listUsers()&#xD;案例2 （用户的分页列表） link&#xD;使用方法&#xD;const { data: { users }, error } = await supabase.auth.admin.listUsers({&#xD;page: 1,&#xD;perPage: 1000&#xD;})&#xD;参数说明 link&#xD;params&#xD;[可选参数]&#xD;PageParams&#xD;一个对象，支持 page 和 perPage 作为数字，用于更改分页结果。&#xA;特性&#xD;page&#xD;[可选参数]&#xD;数字类型&#xD;页数&#xA;perPage&#xD;[可选参数]&#xD;数字类型&#xD;每一页返回项目的个数</description>
    </item>
    <item>
      <title>updateUserById()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-updateuserbyid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-updateuserbyid/</guid>
      <description>updateUserById()用于更新用户数据。&#xA;案例教程 link案例1 （更新用户的电子邮件地址） link&#xD;使用方法&#xD;const { data: user, error } = await supabase.auth.admin.updateUserById(&#xD;&amp;#39;6aa5d0d4-2a9f-4483-b6c8-0cf4c6c98ac4&amp;#39;,&#xD;{ email: &amp;#39;new@email.com&amp;#39; }&#xD;)&#xD;案例2 （更新用户的密码） link&#xD;使用方法&#xD;const { data: user, error } = await supabase.auth.admin.updateUserById(&#xD;&amp;#39;6aa5d0d4-2a9f-4483-b6c8-0cf4c6c98ac4&amp;#39;,&#xD;{ password: &amp;#39;new_password&amp;#39; }&#xD;)&#xD;案例3 （更新用户的元数据） link&#xD;使用方法&#xD;const { data: user, error } = await supabase.auth.admin.updateUserById(&#xD;&amp;#39;6aa5d0d4-2a9f-4483-b6c8-0cf4c6c98ac4&amp;#39;,&#xD;{ user_metadata: { hello: &amp;#39;world&amp;#39; } }&#xD;)&#xD;案例4 （更新用户的应用程序元数据） link&#xD;使用方法&#xD;const { data: user, error } = await supabase.</description>
    </item>
    <item>
      <title>generateLink()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-generatelink/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-generatelink/</guid>
      <description>generateLink() 函数用于生成电子邮件链接和一次性密码（OTP），这些链接和密码将通过自定义的电子邮件服务商发送。&#xA;generateLink() 函数可以接受以下类型的参数：signup、magiclink、invite、recovery、email_change_current、email_change_new、phone_change。 根据传入的类型不同，生成的链接和密码可能有所不同，用于不同的场景，比如用户注册、魔术链接登录、邀请用户、找回密码等。 对于 email_change_email 类型的参数，generateLink() 函数只会生成电子邮件链接，前提是在你的 Supabase 项目的 &amp;ldquo;Email&amp;rdquo; 提供商中启用了 &amp;ldquo;Secure email change&amp;rdquo; 设置。这个功能用于确保用户更改电子邮件地址时的安全性。 generateLink() 函数处理了注册、邀请和魔术链接场景下的用户创建。这意味着在这些场景中，函数会在生成链接和密码的同时，也会创建用户账号，使得用户可以使用相应的链接和密码进行注册、登录或邀请操作。 案例教程 link案例1 （生成注册链接） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.generateLink({&#xD;type: &amp;#39;signup&amp;#39;,&#xD;email: &amp;#39;email@example.com&amp;#39;,&#xD;password: &amp;#39;secret&amp;#39;&#xD;})&#xD;案例2 （生成邀请链接） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.generateLink({&#xD;type: &amp;#39;invite&amp;#39;,&#xD;email: &amp;#39;email@example.com&amp;#39;&#xD;}) 案例3 （生成魔术链接） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.generateLink({&#xD;type: &amp;#39;magiclink&amp;#39;,&#xD;email: &amp;#39;email@example.</description>
    </item>
    <item>
      <title>getUserById()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-getuserbyid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-getuserbyid/</guid>
      <description>getUserById()可以根据用户的 ID 获取用户信息。&#xA;它将根据用户提供的用户 ID，在数据库中查找并获取相应的用户对象（user object）。用户对象包含了有关该用户的各种信息，比如用户名、电子邮件地址、角色等。 执行这个操作需要使用 getUserById() 方法，并且这个方法需要提供用户的 ID 作为参数。这个 ID 映射到数据库中的 auth.users.id 列，用于唯一标识一个用户。 案例教程 link案例1 （使用 access_token jwt 获取用户对象） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.getUserById(1)&#xD;参数说明 link&#xD;uid&#xD;[必要参数]&#xD;string类型&#xD;用户的唯一标识符。此函数应该只在服务器上调用。绝对不要在浏览器中暴露你的 service_role 密钥。</description>
    </item>
    <item>
      <title>inviteUserByEmail()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-inviteuserbyemail/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/wechatsdk/auth-admin/auth-admin-inviteuserbyemail/</guid>
      <description>inviteUserByEmail()函数用于向一个用户电子邮件地址发送邀请链接。&#xA;案例教程 link案例1 （邀请一个用户） link&#xD;使用方法&#xD;const { data, error } = await supabase.auth.admin.inviteUserByEmail(&amp;#39;email@example.com&amp;#39;)&#xD;参数说明 link&#xD;email&#xD;[必要参数]&#xD;string类型&#xD;用户的电子邮件地址。&#xA;选项（option）&#xD;[必要参数]&#xD;object类型&#xD;用于指定在邀请时包含的额外选项。&#xA;特性&#xD;data&#xD;[可选参数]&#xD;object类型&#xD;用于存储关于用户的其他元数据。这个数据对象映射到 auth.users.user_metadata 列，可以用于存储一些用户特定的信息。&#xA;redirectTo&#xD;[可选参数]&#xD;string类型&#xD;它会附加在发送给用户电子邮件地址的邀请链接的 URL 后面。用户点击链接后将跳转到这个指定的 URL。</description>
    </item>
    <item>
      <title>介绍</title>
      <link>http://localhost:1313/docs/app/overview/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/overview/overview/</guid>
      <description>MemFire Cloud是CloudBase的替代方案，提供构建产品所需的所有后端功能。 你可以使用它的全部功能，或者只使用你需要的功能。&#xA;了解功能 link&#xD;认证&#xA;具有行级安全性的用户管理&#xA;自动生成API&#xA;立即为数据库生成APIs&#xA;数据库&#xA;专用的、可扩展的Postgres数据库.&#xA;Realtime&#xA;使用广播、存在和Postgres CDC构建.&#xA;文件存储&#xA;存储、组织和服务大型文件.&#xA;静态托管&#xA;静态托管，一键将静态网站资源部署在云端&#xA;云函数&#xA;全托管计算服务，弹性、可靠的运行任务&#xA;从框架开始 linkMemFire Cloud是基于Postgres的数据库，这使得它兼容许多工具和框架。&#xA;Angular示例&#xA;Expo示例&#xA;Flutter示例&#xA;Next.js示例&#xA;React示例&#xA;RedwoodJS示例&#xA;SolidJS示例&#xA;Svelte示例&#xA;Vue示例&#xA;SDK文档 linkMemFire Cloud提供了JavaScript、Flutter、微信小程序的SDK，以满足用户不同的使用场景。&#xA;JavaScript&#xA;Flutter&#xA;微信小程序&#xA;最佳实践 link以下是使用MemFire Cloud在不同框架下的开发实例。&#xA;Posts社交网络论坛&#xA;Web实时游戏场&#xA;Discussbase论坛&#xA;Super课表小程序&#xA;BBS论坛小程序&#xA;微信小程序聊天室&#xA;别踩白块游戏小程序</description>
    </item>
    <item>
      <title>功能</title>
      <link>http://localhost:1313/docs/app/overview/features/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/overview/features/</guid>
      <description>这是MemFire Cloud为每个项目提供的功能的非详尽列表。&#xA;数据库 linkPostgres数据库 link每个项目都是一个完整的Postgres数据库. 文档.&#xA;数据库扩展 link每个数据库都有一整套Postgres扩展. 文档.&#xA;数据库函数 link创建可以从浏览器调用的自定义数据库函数. 文档.&#xA;数据库触发器 link将触发器附加到表以处理数据库更改. 文档.&#xA;数据库备份 link每天备份项目，可选择升级到时间点恢复.&#xA;搜索 link使用Postgres全文搜索构建搜索功能. 文档.&#xA;密钥和加密 link使用我们的Postgres扩展MemFire Cloud Vault加密敏感数据并存储机密.链接&#xA;身份验证 link电子邮件和密码登录 link为您的应用程序或网站建立电子邮件登录. 文档.&#xA;魔法链接 link为应用程序或网站建立无密码登录.文档.&#xA;社交登录 link提供社交登录-从苹果到GitHub，再到Slack. 文档.&#xA;行级别安全性 link使用Postgres策略控制每个用户可以访问的数据. 文档.&#xA;API和客户端库 link自动生成的REST API linkRESTful API是从数据库自动生成的，无需一行代码. 文档.&#xA;自动生成的GraphQL API link使用我们的自定义PostgresGraphQL扩展的快速GraphQL API. 文档.&#xA;实时数据库变更 link通过websockets接收数据库更改. 文档.&#xA;用户广播 link通过websocket在连接的用户之间发送消息. 文档.&#xA;用户状态 link跨用户同步共享状态，包括联机状态和键入指示符. 文档.&#xA;客户端库 link官方客户端库JavaScript和非官方客户端库Dart，由社区支持。&#xA;文件存储 link大文件存储 linkMemFire Cloud 存储使存储和服务大文件变得简单. 文档.&#xA;存储CDN link使用MemFire Cloud CDN缓存大文件. 文档.&#xA;功能状态 linkPostgres和MemFire Cloud平台都已做好生产准备。我们在Postgres之上提供的一些工具仍在开发中。 产品 功能 阶段 Database Postgres GA Database Triggers GA Database Functions GA Database Extensions GA Database Full Text Search GA Database Webhooks alpha Database Poipnt-in-Time Recovery alpha Database Vault alpha Studio GA Realtime Postgres CDC GA Realtime Broadcast beta Realtime Presence beta Storage Backend (S3) GA Storage API beta Storage CDN beta Edge Functions beta Auth OAuth Providers beta Auth Passwordless beta Auth Next.</description>
    </item>
    <item>
      <title>架构</title>
      <link>http://localhost:1313/docs/app/overview/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/overview/architecture/</guid>
      <description>MemFire Cloud 是基于Supabase去构建应用的，Supabase是开源的。我们选择了可扩展且易于使用的开源工具。&#xA;Supabase不是Firebase的一对一映射。虽然我们正在构建Firebase提供的许多功能，但我们的做法并不相同: 我们的技术选择截然不同; 我们使用的一切都是开源的; 在可能的情况下，我们使用并支持现有工具，而不是从头开始开发。&#xA;最值得注意的是，我们使用Postgres而不是NoSQL存储。这个选择是深思熟虑的。我们认为，没有其他数据库提供与Firebase竞争所需的功能， 同时保持超越它所需的可扩展性。&#xA;架构 link每个Supabase项目包括几个工具：:&#xA;PostgreSQL (数据库) linkPostgreSQL是Supabase的核心。我们不抽象PostgreSQL数据库-您可以访问它并以完全权限使用它。我们只是提供了一些工具，使PostgreSQL与Firebase一样易于使用。&#xA;官方文件: postgresql.org/docs 源代码: github.com/postgres/postgres (mirror) License: PostgreSQL Licence 语言: C Studio (仪表盘) link用于管理数据库和服务的一个开源Dashboard.&#xA;官方文件: Supabase docs 源代码: github.com/supabase/supabase License: Apache 2 开发语言: TypeScript GoTrue (用户身份验证) link用于管理用户和颁发访问令牌的基于JWT的API。这与PostgreSQL的行级安全和API服务器集成。&#xA;官方文件: Supabase Auth reference docs 源代码: github.com/supabase/gotrue License: MIT 开发语言: Go PostgREST (API) link一个将PostgreSQL数据库直接转换为RESTful API的独立web服务器。 我们将此与一起使用pg_graphql扩展以提供GraphQL API。&#xA;官方文件: postgrest.org 源代码: github.com/PostgREST/postgrest License: MIT 开发语言: Haskel Realtime (API &amp;amp; multiplayer) link一个可扩展的websocket引擎，用于管理用户状态、广播消息和流数据库更改。</description>
    </item>
    <item>
      <title>产品动态</title>
      <link>http://localhost:1313/docs/app/overview/history/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/overview/history/</guid>
      <description>本文列出了所有已发布的应用版本，按发布时间倒序呈现。 版本 发布日期 2.3.23 2023-05-04 2.3.22 2023-03-18 2.2.X 2023-02-28 2.0.X 2023-01-14 1.2.X 2022-03-04 1.0.X 2021-11-09 2.3.23 link2023年5月4日，云服务平台MemFire Cloud推出了2.3.23版本应用。&#xA;云函数 link支持JavaScript高级编程语言，一键上传，快速体验;&#xA;平台提供多个代码模板，其中包括微信支付代码模板，实现了微信native支付和小程序支付;&#xA;统一管理云函数，可创建、更新、删除云函数；&#xA;定制版应用 linkMemFire Cloud推出了灵活、个性化的定制版应用，实现应用个性化配置，满足不同开发项目的应用场景需求;&#xA;2.3.22 link2023年3月18日，云服务平台MemFire Cloud推出了2.3.22版本应用。&#xA;微信小程序登录 link兼容微信小程序登录，利用微信强大的传播能力，实现快速获客，降低推广成本。&#xA;兼容阿里云SMS服务商 link兼容阿里云的SMS服务，实现手机号+短信验证码进行身份验证。&#xA;使用MemFire Cloud作为后台，应用（APP/Web/小程序）部署上线后，用户即可采用手机号+短信的形式进行身份验证，完成注册/登录等操作。&#xA;SQL编辑器优化 link支持新建SQL查询、删除SQL查询、重命名SQL查询操作，进一步提升用户使用体验。&#xA;2.2.X link2023年2月28日，云服务平台MemFire Cloud推出了2.2.X版本应用。&#xA;静态网站托管 link 新增自定义域名绑定功能 一键上传，提升易用性 应用版本管理 link新增应用升级功能，用户可手动升级应用，以便于随时体验新版本中的各种功能特性。&#xA;2.0.X link2023年1月14日，云服务平台MemFire Cloud推出了2.0.X版本应用。&#xA;realtime linkMemFire Cloud推出的realtime服务可以通过侦听、广播、共享来自其他客户端/数据库的更改来创建多人互动应用, 主要特性包括：&#xA;侦听数据库变更： 侦听数据库插入、更新、删除以及其他变更操作； 保存：在各客户之间一致地存储和同步在线用户状态； 广播：以低延时将任务消息数据发送到订阅同一频道的任何客户端； 新版studio link新版本的仪表盘,用户可以通过WEB页面对数据表、对象存储、触发器、函数、扩展、realtime等功能进行管理操作，从而降低用户的使用门槛。&#xA;1.2.X link2022年3月4日，云服务平台MemFire Cloud推出了1.2.X版本应用。&#xA;静态网站托管 link 支持一键将静态网站资源部署在云端 提供默认域名便于用户访问网站 1.0.X link2021年11月09日，云服务平台MemFire Cloud推出了1.0.X版本应用。 该版本提供“开箱即用”的后端服务，为应用开发人员全面“减负”。&#xA;云数据库 link 新增表编辑器功能 支持自动生成数据表访问API 支持设置表访问权限 新增数据表索引管理功能，提升SQL查询效率 身份验证与授权 link 新增注册用户管理功能 支持配置邮件模板 提供SDK与API调用 对象存储 link 提供SDK与API，轻松实现文件上传，下载、访问操作 支持设置对象的访问权限， </description>
    </item>
    <item>
      <title>联系我们</title>
      <link>http://localhost:1313/docs/app/overview/contactus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/overview/contactus/</guid>
      <description>使用过程中需要任何帮助、有任何需求想法，请添加微信技术交流群，与志同道合的小伙伴交流；&#xA;关于定制版的价格，请扫小助手二维码加我们工作人员的微信咨询，添加微信备注: 咨询定制版&#xA;技术交流群&#xA;产品公众号&#xA;小助手&#xA;联系电话 link您还可以通过以下电话号码与我们取得联系。&#xA;座机：027-87876179&#xA;手机号：13886140230</description>
    </item>
    <item>
      <title>公告</title>
      <link>http://localhost:1313/docs/app/announcement/bulletins/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/app/announcement/bulletins/</guid>
      <description>尊敬的用户，您好！&#xA;为了给各位用户提供更加优质可靠的产品服务，MemFire Cloud应用开发计划在2023年12月11日正式推出计费套餐。目前统一采用基础套餐+按量付费的模式，开发者可先购买带有一定配额的基础套餐，超出套餐配额部分按使用量付费。&#xA;基础套餐 link我们的收费模式充分考虑了用户的实际需求和预算，提供了多样化的套餐选择，以满足不同用户的需求。 配额 免费版（限2个） 入门版 基础版 专业版 单位 云数据库容量 0.5 2 8 30 GB/月 数据备份容量 - 15 50 200 GB/月 对象存储容量 2 8 20 70 GB/月 静态托管容量 1 2 4 8 GB/月 云函数vCPU使用量 0.1 1 3 5 万vCPUs/月 云函数内存使用量 1 10 30 50 万GBs/月 调用次数 2 20 500 1000 万次/月 流量 1 4 16 20 GB/月 价格 ¥ 0.0 ¥ 19.9 ¥ 99 ¥ 299 /月 info&#xD;每个用户都可获得2个免费版应用体验期权益，超出配额后可选择是否进行按量付费。</description>
    </item>
    <item>
      <title>价格文档</title>
      <link>http://localhost:1313/docs/app/purchase/price/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/purchase/price/</guid>
      <description>基础套餐 link可以根据您项目规模与业务需求，选择相应套餐。&#xA;配额 免费版 入门版 基础版 专业版 定制版 单位 调用次数 2 20 500 1000 按需定制 万次/月 流量 1 4 16 20 按需定制 GB/月 云数据库容量 0.5 2 8 30 按需定制 GB/月 数据备份容量 - 15 50 200 按需定制 GB/月 对象存储容量 2 8 20 70 按需定制 GB/月 静态托管容量 1 2 4 8 按需定制 GB/月 vCPU使用量 0.1 1 3 5 按需定制 万vCPUs/月 内存使用量 1 10 30 50 按需定制 万GBs/月 价格 ¥ 0.0 ¥ 19.9 ¥ 99 ¥ 299 按需定制 /月 info&#xD;对于调用次数等单一指标需求超过套餐资源，可开启按量付费。</description>
    </item>
    <item>
      <title>包年包月套餐说明</title>
      <link>http://localhost:1313/docs/app/purchase/package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/purchase/package/</guid>
      <description>计费周期 link 账期日：用户购买包年包月MemFire Cloud应用后，购买日即为账期日。MemFire Cloud应用开发中按月累计的资源将在每个账期日进行重置。即按月累计资源清零，重新开始累计。&#xA;例如：小王在2023年3月10日 8:00:00购买2个月的入门版应用套餐，到期时间为2023年5月10日 。小王的应用账期日为每月10日，即在4月10日按月资源会重置。&#xA;计费周期：用户购买包年包月MemFire Cloud应用后，从1个账期日起到下个账期日的逻辑月记为1个计费周期。&#xA;包年包月应用超配额 link在1个计费周期内，若应用的某项资源使用量超出当前套餐配额限制，平台将限制对该资源的使用，具体限制方案如下：&#xA;数据库容量超过限额时，将无法存储或处理更多的数据。除非用户升级到更高配置的套餐； 备份容量超过限额时，将无法存储或处理更多的数据。除非系统清理数据达上限值以下或用户升级到更高配置的套餐； 对象存储容量、静态托管容量超过限额时，将无法存储或处理更多的数据。除非用户升级到更高配置的套餐； 调用次数、vCPU使用量、内存使用量、流量超过限额时，则在下个计费周期之前，无法使用资源，除非升配到更高配额的套餐； 账期日进行资源重置后，下个计费周期开始后可正常使用资源； 包年包月应用到期 linkMemFire Cloud应用开发到期停服规则。应用到期时，若未及时续费，将会被停服及销毁。用户可为应用设置自动续费。设置成功后，MemFire Cloud应用到期时，系统会自动扣除用户账户余额进行续费。 到期处理机制具体如下表所示： 时间段 处理机制 应用到期前15天 未设置自动续费的应用：应用距离到期不足15天，则系统将推送应用即将到期提醒，并通过短信、站内信的方式推送。设置自动续费的应用：如果账户余额充足，则不会发送资应用即将到期提醒； 到期当天 未设置自动续费的应用：如果用户没有续费，则应用即将被停服（保留数据，但是不可访问），并发送用户应用即将停服，如需使用，请尽快续费。设置自动续费的应用：如果账户余额充足，已自动完成续费，则通知用户应用自动续费成功。如果账户余额不足以续费，则通知用户自动续费失败，应用即将停服，如需使用请尽快充值。 应用停服 应用到期后未续费，将在到期后第1天到第7天停服，用户可续费并找回应用，恢复其工作状态。停服后释放前每隔1天仍会推送通知，通知方式包括短信、站内信； 释放应用 应用停服后，若用户仍未进行续费，应用将被释放，其数据将被清除且不可恢复。应用释放当天会通过短信、站内信的方式进行提醒。 到期停服后：对象存储、数据库、静态托管、云函数等资源均无法使用。&#xA;包年包月应用升配 link升配费用 = 按月升配差价 × 升配天数 / (365 / 12) × 适用折扣&#xA;其中按月升配差价 = 新套餐按月单价-旧套餐按月单价； 升配的费用按天计算：升配天数 = 应用到期时间 - 当前时间。 升配天数精确到天，向下取整，不足的1天则忽略不计。例如购买资源1个月（30天），使用10.5天发起升配操作，则已使用时长为11天，升配天数为19天； 适用折扣：根据升配天数向下匹配适用折扣。折扣为现网生效的折扣。比如: 如果升配天数为200天， 折换成200/(365/12)个月，官网有购买超过6个月打9.5折活动，则可以打九五折； 升配不影响应用到期时间。 升配时的新套餐额度生效时间为旧套餐剩余时长。升配时，用户无法选择升配时长，仅可在续费套餐时选择购买时长。&#xA;升配计算示例&#xA;info&#xD;以MemFire Cloud应用开发包年包月套餐升配说明：&#xA;以下价格仅作为示例使用，具体价格请参考：价格文档&#xA;2023年4月1日 12:00:00购买了入门版套餐，到期时间为2023年7月1日 23:59:59，包年包月的单价为¥ 19.9/月；&#xA;2023年5月15日 16:00:00 ，将该套餐升级为¥ 99.</description>
    </item>
    <item>
      <title>欠费说明</title>
      <link>http://localhost:1313/docs/app/purchase/arrears/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/purchase/arrears/</guid>
      <description>包年包月 link套餐到期前7天 link系统会多次发送续费提醒通知，请及时续费。&#xA;套餐到期 link系统将在到期时间点开始进行停服处理，应用进入已隔离状态，线上业务停服、控制台页面无法访问、应用无法操作。&#xA;此时，用户可以续费来恢复应用。如果不需继续使用亦可删除应用。&#xA;info&#xD;如果用户在应用到期暂停期间内，执行续费操作恢复应用，则续费周期的起始时间是原到期时间。&#xA;例如：应用在1月1日到期，1月4日续费一个月。那么，应用新的到期时间是2月1日（按原到期时间计算）。&#xA;套餐到期超过7天 link系统将在第8天自动删除应用，清除所有资源和数据。删除应用后，则不可恢复、找回资源和数据。&#xA;账户欠款，套餐未到期 link如果出现账户欠费，但是套餐未到期，应用仍可正常使用，但无法续费、无法变更套餐。&#xA;需先充值将欠款将账户冲正后，才可续费或变更套餐。</description>
    </item>
    <item>
      <title>退订说明</title>
      <link>http://localhost:1313/docs/app/purchase/unsubscribe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/purchase/unsubscribe/</guid>
      <description>本文中含有需要您注意的重要提示信息，忽略该信息可能对您的业务造成影响，请您务必认证仔细阅读。&#xA;MemFire Cloud产品退订主要分为2个场景：退订使用中资源、创建/变更资源失败自动退订；&#xA;info&#xD;退订仅针对预付费（包年包月、资源包等）商品，当您想终止服务时，基于退订规则退还资源、并退还相应的款项。&#xA;后付费（按量付费）商品，您可直接在WEB控制台释放/删除资源，不涉及退款申请操作。&#xA;若您退订中遇到问题，可通过客服电话027-87876179联系我们。&#xA;退订使用中资源 link如您购买资源后不再需要该资源，可退订当前使用中的部分（包含正在使用中的部分以及未生效的续费周期）。&#xA;退订使用中的资源有以下2种场景：非全额退订和全额退订。&#xA;info&#xD;1.如您已开具发票，退订时款项将退回账户余额，同时将产生欠票金额，再次开具发票/余额退款时需优先冲抵欠票金额。&#xA;2.退订前请确保已完成数据迁移或备份；&#xA;非全额退订&#xA;支持退订，但预付费产品扣除已消费金额后，进行退货退款，属于非全额退订。&#xA;常见的支持非全额退订的云产品如下所示： 产品名称 MemFire Cloud应用开发（包年包月） 不支持退订&#xA;不支持退订云产品如下所示： 产品名称 共享流量包（包年包月） 共享调用次数包（包年包月） 退订金额计算 link退订金额=当前生效订单实付金额+未开始所有订单实付金额-当前生效订单资源已消费金额；&#xA;“订单实付金额”仅指用户以现金方式支付的订单款项，不包含用户通过代金券、优惠券抵扣的部分。&#xA;“已消费金额”的计算规则如下：&#xA;对于MemFire Cloud应用开发（包年包月）商品：资源已消费金额=（已使用时长/总时长）*订单实付金额；&#xA;已使用时长：指订单的实际消费时长，精确到天，不满1天按1天来计算。&#xA;总时长：指定订单的购买时长，精确到天，不满1天按1天来计算。&#xA;info&#xD;针对MemFire Cloud应用为例；&#xA;例如：用户小王在2023年2月1日下午17点新购入门版套餐3个月，单价¥ 19.9 /月，折扣为9折，对应的新购订单的实付金额为：¥ 53.73；&#xA;用户小王2023年2月15日续费1个月，单价为¥ 19.9 /月，无折扣粒度，对应的续费订单的实付金额为：¥ 19.9；&#xA;当用户在2023年2月16日下午15点删除应用，其退款金额为：&#xA;① 当前生效订单实付金额：¥ 53.73；&#xA;② 未开始所有订单实付金额：¥ 19.9；&#xA;③ 资源已消费金额 = 15/（90）* 53.73 = ¥ 8.95 ；&#xA;其中：&#xA;已使用时长为：15天。实际使用14天22小时，发起退款申请不满1天按1天，则已使用时长为15天； 总时长为：90天，27天7小时+31天+30天+1天=89天7小时，不满1天按1天，则总时长为90天； 则退订该资源，退订金额： ¥ 53.73 + ¥ 19.9 - ¥ 8.</description>
    </item>
    <item>
      <title>计费相关问题</title>
      <link>http://localhost:1313/docs/app/purchase/qa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/purchase/qa/</guid>
      <description>MemFire Cloud应用开发的计费模式是怎么样的？ linkMemFire Cloud应用开发采用基础套餐+按量付费模式。&#xA;您可先购买带有一定配额的基础套餐后，超出套餐配额部分再按照实际使用量付费。&#xA;详情可参见价格文档。&#xA;什么时候适合使用按量计费？ link若应用超出套餐配额，那么将影响应用的正常使用。为了解决这个问题，可以启用按量付费，如果应用的某项资源使用完后，超出套餐的部分将按照按量收费标准进行扣费。&#xA;存量用户如何升级？ link对于V2免费版应用，需要您主动升级，才会生效新计费；&#xA;针对V1版免费应用，内测即将停服，需要您根据迁移方案进行迁移操作，才能体验新的服务。&#xA;现在付费的应用是否可以继续使用呢？ link计费生效后，已付费购买的预付费定制套餐可正常使用至原到期时间，不会存在直接失效或自动退费的情况。您可在付费套餐到期前切换即可。&#xA;自行评估后觉得费用有点高，该如何优化？ link目前MemFire Cloud提供了多种套餐满足不同场景的需求，购买套餐时间越长，优惠折扣粒度越高；&#xA;您可以根据需要选择合适的套餐，如果套餐选配过低，也可以升配到高级套餐，套餐资源打包价格比按量付费更为优惠；&#xA;此外，您也可以减少不必要的多次调用或存储内容，有效控制调用次数和容量的费用；&#xA;如何进行提现操作？ link目前仅支持提现账户的现金余额，不涉及代金券和优惠券，赠送金等；&#xA;提现流程如下：&#xA;1.用户发起申请。MemFire Cloud用户联系MemFire Cloud平台工作人员，发起账户余额退款申请，需提交有效的用户信息，包括：用户名、身份证号、手机号、账户余额信息等；&#xA;2.平台工作人员审核。在收到申请后，平台工作人员进行审核操作，审核确认退款金额；若有问题则审核不通过，备注不通过的原因，流程中断；若没问题则审核通过，并跟用户确认退款金额，与用户达成一致；&#xA;3.财务复审，退款。平台工作人员审核通过后，财务人员需要对售后的退款金额再次审核，审核通过后进行退款操作；审核不通过则需平台工作人员重新审核。&#xA;备注说明：&#xA;（1）超过一年的微信订单是无法退款的，且微信商户平台收取的0.9%的手续费；无法原路退回的部分金额需先进行扣除0.9%手续费，再采用其他协商方式进行退款；&#xA;（2）如果用户已开具发票，且存在资源退订的情况，退订款项将退回账户余额，这时将产生欠票金额，账户余额退款时需冲抵欠票金额。</description>
    </item>
    <item>
      <title>快速入门: Vue</title>
      <link>http://localhost:1313/docs/app/quickstart/with-vue-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-vue-3/</guid>
      <description>第一步：在 MemFire Cloud 仪表板中创建一个新应用。 link应用准备就绪后，进入应用，在左侧菜单-&amp;gt;表编辑器选择 SQL 编辑器在 MemFire Cloud 数据库中创建一个表。使用以下 SQL 语句创建包含一些示例数据的国家/地区表。&#xA;-- Create the table&#xD;CREATE TABLE countries (&#xD;id SERIAL PRIMARY KEY,&#xD;name VARCHAR(255) NOT NULL&#xD;);&#xD;-- Insert some sample data into the table&#xD;INSERT INTO countries (name) VALUES (&amp;#39;United States&amp;#39;);&#xD;INSERT INTO countries (name) VALUES (&amp;#39;Canada&amp;#39;);&#xD;INSERT INTO countries (name) VALUES (&amp;#39;Mexico&amp;#39;);&#xD;第二步：创建 Vue 应用 link使用 npm init 命令创建 Vue 应用。&#xA;npm init vue@latest my-app&#xD;第三步：安装 Supabase 客户端库 link最快的入门方法是使用 supabase-js 客户端库，它提供了一些简便的API，用于在 Vue 应用程序中使用 Supabase。 导航到 Vue 应用程序并安装 supabase-js 。</description>
    </item>
    <item>
      <title>快速入门: React</title>
      <link>http://localhost:1313/docs/app/quickstart/with-react/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-react/</guid>
      <description>第一步：在 MemFire Cloud 仪表板中创建一个新应用。 link应用准备就绪后，进入应用，在左侧菜单-&amp;gt;表编辑器选择 SQL 编辑器在 MemFire Cloud 数据库中创建一个表。使用以下 SQL 语句创建包含一些示例数据的国家/地区表。&#xA;-- Create the table&#xD;CREATE TABLE countries (&#xD;id SERIAL PRIMARY KEY,&#xD;name VARCHAR(255) NOT NULL&#xD;);&#xD;-- Insert some sample data into the table&#xD;INSERT INTO countries (name) VALUES (&amp;#39;United States&amp;#39;);&#xD;INSERT INTO countries (name) VALUES (&amp;#39;Canada&amp;#39;);&#xD;INSERT INTO countries (name) VALUES (&amp;#39;Mexico&amp;#39;);&#xD;第二步：创建 React 应用 link使用 Vite 模板创建 React 应用。&#xA;npm create vite@latest my-app -- --template react&#xD;第三步：安装 Supabase 客户端库 link最快的入门方法是使用 supabase-js 客户端库，它提供了一些简便的API，用于在 React 应用程序中使用 Supabase。 导航到 React 应用程序并安装 supabase-js 。</description>
    </item>
    <item>
      <title>快速入门: Flutter</title>
      <link>http://localhost:1313/docs/app/quickstart/with-flutter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-flutter/</guid>
      <description>第一步：在 MemFire Cloud 仪表板中创建一个新应用。 link应用准备就绪后，进入应用，在左侧菜单-&amp;gt;表编辑器选择 SQL 编辑器在 MemFire Cloud 数据库中创建一个表。使用以下 SQL 并自行运行。&#xA;info&#xD;在本地工作时，可以运行以下命令创建新的迁移文件：&#xA;supabase migration new user_management_starter&#xD;-- Create a table for public profiles&#xD;create table profiles (&#xD;id uuid references auth.users not null primary key,&#xD;updated_at timestamp with time zone,&#xD;username text unique,&#xD;full_name text,&#xD;avatar_url text,&#xD;website text,&#xD;constraint username_length check (char_length(username) &amp;gt;= 3)&#xD;);&#xD;-- Set up Row Level Security (RLS)&#xD;-- See https://supabase.com/docs/guides/auth/row-level-security for more details.</description>
    </item>
    <item>
      <title>快速入门: Next.js</title>
      <link>http://localhost:1313/docs/app/quickstart/with-nextjs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-nextjs/</guid>
      <description>第一步：在 MemFire Cloud 仪表板中创建一个新应用。 link应用准备就绪后，进入应用，在左侧菜单-&amp;gt;表编辑器选择 SQL 编辑器在 MemFire Cloud 数据库中创建一个表。使用以下 SQL 语句创建包含一些示例数据的国家/地区表。&#xA;-- Create the table&#xD;CREATE TABLE countries (&#xD;id SERIAL PRIMARY KEY,&#xD;name VARCHAR(255) NOT NULL&#xD;);&#xD;-- Insert some sample data into the table&#xD;INSERT INTO countries (name) VALUES (&amp;#39;United States&amp;#39;);&#xD;INSERT INTO countries (name) VALUES (&amp;#39;Canada&amp;#39;);&#xD;INSERT INTO countries (name) VALUES (&amp;#39;Mexico&amp;#39;);&#xD;第二步：创建 Next.js 应用 link使用 npx 模板创建 Next.js 应用。&#xA;npx create-next-app my-next-app&#xD;第三步：安装 Supabase 客户端库 link最快的入门方法是使用 supabase-js 客户端库，它提供了一些简便的API，用于在 Next.</description>
    </item>
    <item>
      <title>快速入门: Angular</title>
      <link>http://localhost:1313/docs/app/quickstart/with-angular/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-angular/</guid>
      <description>GitHub link如果你在阅读指南时遇到困难，请参考此版本&#xA;构建应用程序 link让我们开始从头开始构建Angular应用程序。&#xA;初始化一个Angular应用程序 link我们可以使用[Angular CLI]（https://angular.io/cli）来初始化 一个名为`supabase-angular&amp;rsquo;的应用程序：&#xA;npx ng new supabase-angular --routing false --style css&#xD;cd supabase-angular&#xD;然后让我们安装唯一的额外依赖：supabase-js&#xA;npm install @supabase/supabase-js&#xD;最后我们要在environment.ts文件中保存环境变量。 我们所需要的是API URL和你[早些时候]复制的anon密钥(#get-theapi-keys)。 这些变量将暴露在浏览器上，这完全没有问题，因为我们在数据库上启用了行级安全。&#xA;export const environment = {&#xD;production: false,&#xD;supabaseUrl: &amp;#39;YOUR_SUPABASE_URL&amp;#39;,&#xD;supabaseKey: &amp;#39;YOUR_SUPABASE_KEY&amp;#39;,&#xD;}&#xD;现在我们已经有了API凭证，让我们用ng g s supabase创建一个SupabaseService，以初始化Supabase客户端并实现与Supabase API通信的功能。&#xA;import { Injectable } from &amp;#39;@angular/core&amp;#39;&#xD;import {&#xD;AuthChangeEvent,&#xD;AuthSession,&#xD;createClient,&#xD;Session,&#xD;SupabaseClient,&#xD;User,&#xD;} from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;import { environment } from &amp;#39;src/environments/environment&amp;#39;&#xD;import { Database } from &amp;#39;src/schema&amp;#39;&#xD;export interface Profile {&#xD;id?</description>
    </item>
    <item>
      <title>快速入门: Android Kotlin</title>
      <link>http://localhost:1313/docs/app/quickstart/with-kotlin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-kotlin/</guid>
      <description>第一步：在 MemFire Cloud 仪表板中创建一个新应用。 link应用准备就绪后，进入应用，在左侧菜单-&amp;gt;表编辑器选择 SQL 编辑器在 MemFire Cloud 数据库中创建一个表。使用以下 SQL 语句创建包含一些示例数据的国家/地区表。&#xA;-- Create the table&#xD;CREATE TABLE countries (&#xD;id SERIAL PRIMARY KEY,&#xD;name VARCHAR(255) NOT NULL&#xD;);&#xD;-- Insert some sample data into the table&#xD;INSERT INTO countries (name) VALUES (&amp;#39;United States&amp;#39;);&#xD;INSERT INTO countries (name) VALUES (&amp;#39;Canada&amp;#39;);&#xD;INSERT INTO countries (name) VALUES (&amp;#39;Mexico&amp;#39;);&#xD;第二步：使用 Android Studio 创建 Android 应用 link打开 Android Studio &amp;gt; 新建 &amp;gt; 新建 Android 项目。</description>
    </item>
    <item>
      <title>快速入门: Nuxt 3</title>
      <link>http://localhost:1313/docs/app/quickstart/with-nuxt-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-nuxt-3/</guid>
      <description>Github link如果你在阅读指南时遇到困难，请参考此版本。&#xA;构建应用程序 link让我们开始从头开始构建Vue 3应用程序。&#xA;初始化一个Nuxt 3应用程序 link我们可以使用nuxi init来创建一个名为nuxt-user-management的应用程序。&#xA;npx nuxi init nuxt-user-management&#xD;cd nuxt-user-management&#xD;然后让我们安装唯一的额外依赖：NuxtSupabase。我们只需要将NuxtSupabase作为一个开发依赖项导入。&#xA;npm install @nuxtjs/supabase --save-dev&#xD;最后，我们要把环境变量保存在.env中。 我们所需要的是API URL和你[早些时候]复制的anon密钥（#get-theapi-keys）。&#xA;SUPABASE_URL=&amp;#34;YOUR_SUPABASE_URL&amp;#34;&#xD;SUPABASE_KEY=&amp;#34;YOUR_SUPABASE_ANON_KEY&amp;#34;&#xD;这些变量将暴露在浏览器上，这完全没有问题，因为我们的数据库已经启用了行级安全。 关于NuxtSupabase的神奇之处在于，为了开始使用Supabase，我们只需要设置环境变量即可。 不需要初始化Supabase。该库将自动处理它。&#xA;还有一个可选的步骤是更新CSS文件assets/main.css以使应用程序看起来漂亮。 你可以找到这个文件的全部内容这里。&#xA;import { defineNuxtConfig } from &amp;#39;nuxt&amp;#39;&#xD;// https://v3.nuxtjs.org/api/configuration/nuxt.config&#xD;export default defineNuxtConfig({&#xD;modules: [&amp;#39;@nuxtjs/supabase&amp;#39;],&#xD;css: [&amp;#39;@/assets/main.css&amp;#39;],&#xD;})&#xD;设置Auth组件 link让我们建立一个Vue组件来管理登录和注册。我们将使用Magic Links，所以用户可以用他们的电子邮件登录，而不需要使用密码。&#xA;&amp;lt;template&amp;gt;&#xD;&amp;lt;form class=&amp;#34;row flex-center flex&amp;#34; @submit.prevent=&amp;#34;handleLogin&amp;#34;&amp;gt;&#xD;&amp;lt;div class=&amp;#34;col-6 form-widget&amp;#34;&amp;gt;&#xD;&amp;lt;h1 class=&amp;#34;header&amp;#34;&amp;gt;Supabase &amp;#43; Nuxt 3&amp;lt;/h1&amp;gt;&#xD;&amp;lt;p class=&amp;#34;description&amp;#34;&amp;gt;Sign in via magic link with your email below&amp;lt;/p&amp;gt;&#xD;&amp;lt;div&amp;gt;&#xD;&amp;lt;input class=&amp;#34;inputField&amp;#34; type=&amp;#34;email&amp;#34; placeholder=&amp;#34;Your email&amp;#34; v-model=&amp;#34;email&amp;#34; /&amp;gt;&#xD;&amp;lt;/div&amp;gt;&#xD;&amp;lt;div&amp;gt;&#xD;&amp;lt;input&#xD;type=&amp;#34;submit&amp;#34;&#xD;class=&amp;#34;button block&amp;#34;&#xD;:value=&amp;#34;loading ?</description>
    </item>
    <item>
      <title>快速入门: Svelte</title>
      <link>http://localhost:1313/docs/app/quickstart/with-svelte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-svelte/</guid>
      <description>GitHub link如果你在阅读指南时遇到困难，请参考此版本。&#xA;构建应用程序 link让我们从头开始构建Svelte应用程序。&#xA;初始化一个Svelte应用程序 link我们可以使用Vite Svelte TypeScript模板来初始化一个名为supabase-svelte的应用程序。&#xA;npm create vite@latest supabase-svelte -- --template svelte-ts&#xD;cd supabase-svelte&#xD;npm install&#xD;然后让我们安装唯一的额外依赖：supabase-js&#xA;npm install @supabase/supabase-js&#xD;最后，我们要把环境变量保存在.env中。 我们所需要的是API URL和你[早些时候]复制的anon密钥（#get-theapi-keys）。&#xA;VITE_SUPABASE_URL=YOUR_SUPABASE_URL&#xD;VITE_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY&#xD;现在我们已经有了API凭证，让我们创建一个辅助文件来初始化Supabase客户端。这些变量将被暴露在 在浏览器上，这完全没有问题，因为我们的数据库已经启用了行级安全。&#xA;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;const supabaseUrl = import.meta.env.VITE_SUPABASE_URL&#xD;const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY&#xD;export const supabase = createClient(supabaseUrl, supabaseAnonKey)&#xD;还有一个可选的步骤是更新CSS文件src/app.css以使应用程序看起来漂亮。 你可以找到这个文件的全部内容这里。&#xA;设置一个登录组件 link让我们建立一个Svelte组件来管理登录和注册。我们将使用Magic Links，这样用户就可以用他们的电子邮件登录，而无需使用密码。&#xA;&amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt;&#xD;import { supabase } from &amp;#39;src/supabaseClient&amp;#39;&#xD;let loading = false&#xD;let email = &amp;#39;&amp;#39;&#xD;const handleLogin = async () =&amp;gt; {&#xD;try {&#xD;loading = true&#xD;const { error } = await supabase.</description>
    </item>
    <item>
      <title>快速入门: Ionic Vue</title>
      <link>http://localhost:1313/docs/app/quickstart/with-ionic-vue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-ionic-vue/</guid>
      <description>GitHub link如果你在阅读指南时遇到困难，请参考此版本。&#xA;构建应用程序 link让我们开始从头开始构建Vue应用程序。&#xA;初始化一个Ionic Vue应用程序 link我们可以使用Ionic CLI来初始化 一个名为supabase-ionic-vue的应用程序。&#xA;npm install -g @ionic/cli&#xD;ionic start supabase-ionic-vue blank --type vue&#xD;cd supabase-ionic-vue&#xD;然后让我们安装唯一的额外依赖：supabase-js&#xA;npm install @supabase/supabase-js&#xD;最后，我们要把环境变量保存在.env中。 我们所需要的是API URL和你[早些时候]复制的anon密钥(#get-theapi-keys)。&#xA;VUE_APP_SUPABASE_URL=YOUR_SUPABASE_URL&#xD;VUE_APP_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY&#xD;现在我们已经有了API凭证，让我们创建一个辅助文件来初始化Supabase客户端。这些变量将被暴露在 在浏览器上，这完全没有问题，因为我们的数据库已经启用了行级安全。&#xA;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;;&#xD;const supabaseUrl = process.env.VUE_APP_SUPABASE_URL as string;&#xD;const supabaseAnonKey = process.env.VUE_APP_SUPABASE_ANON_KEY as string;&#xD;export const supabase = createClient(supabaseUrl, supabaseAnonKey);&#xD;设置一个登录路由 link让我们建立一个Vue组件来管理登录和注册。我们将使用Magic Links，所以用户可以用他们的电子邮件登录，而不需要使用密码。&#xA;&amp;lt;template&amp;gt;&#xD;&amp;lt;ion-page&amp;gt;&#xD;&amp;lt;ion-header&amp;gt;&#xD;&amp;lt;ion-toolbar&amp;gt;&#xD;&amp;lt;ion-title&amp;gt;Login&amp;lt;/ion-title&amp;gt;&#xD;&amp;lt;/ion-toolbar&amp;gt;&#xD;&amp;lt;/ion-header&amp;gt;&#xD;&amp;lt;ion-content&amp;gt;&#xD;&amp;lt;div class=&amp;#34;ion-padding&amp;#34;&amp;gt;&#xD;&amp;lt;h1&amp;gt;Supabase &amp;#43; Ionic Vue&amp;lt;/h1&amp;gt;&#xD;&amp;lt;p&amp;gt;Sign in via magic link with your email below&amp;lt;/p&amp;gt;&#xD;&amp;lt;/div&amp;gt;&#xD;&amp;lt;ion-list inset=&amp;#34;true&amp;#34;&amp;gt;&#xD;&amp;lt;form @submit.</description>
    </item>
    <item>
      <title>快速入门: Expo</title>
      <link>http://localhost:1313/docs/app/quickstart/with-expo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-expo/</guid>
      <description>GitHub link如果你在阅读指南时遇到困难，请参考此版本&#xA;构建应用程序 link让我们开始从头开始构建React Native应用。&#xA;初始化一个React Native应用 link我们可以使用expo来初始化 一个名为 &amp;ldquo;expo-user-management &amp;ldquo;的应用程序。&#xA;npx create-expo-app -t expo-template-blank-typescript expo-user-management&#xD;cd expo-user-management&#xD;然后让我们安装额外的依赖项。supabase-js&#xA;npm install @supabase/supabase-js&#xD;npm install react-native-elements @react-native-async-storage/async-storage react-native-url-polyfill&#xD;现在让我们创建一个辅助文件来初始化Supabase客户端。 我们需要API URL和你[早些时候]复制的anon密钥（#get-the-api-keys）。 这些变量将被暴露在浏览器上，这完全没有问题，因为我们有 行级安全在我们的数据库上启用。&#xA;import AsyncStorage from &amp;#39;@react-native-async-storage/async-storage&amp;#39;&#xD;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;const supabaseUrl = YOUR_REACT_NATIVE_SUPABASE_URL&#xD;const supabaseAnonKey = YOUR_REACT_NATIVE_SUPABASE_ANON_KEY&#xD;export const supabase = createClient(supabaseUrl, supabaseAnonKey, {&#xD;auth: {&#xD;storage: AsyncStorage as any,&#xD;autoRefreshToken: true,&#xD;persistSession: true,&#xD;detectSessionInUrl: false,&#xD;},&#xD;})&#xD;设置一个登录组件 link让我们建立一个React Native组件来管理登录和注册。 用户将能够用他们的电子邮件和密码登录。</description>
    </item>
    <item>
      <title>快速入门: Ionic Angular</title>
      <link>http://localhost:1313/docs/app/quickstart/with-ionic-angular/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-ionic-angular/</guid>
      <description>GitHub link如果你在阅读指南时遇到困难，请参考此版本&#xA;构建应用程序 link让我们开始从头开始构建Angular应用程序。&#xA;初始化一个Ionic Angular应用程序 link我们可以使用Ionic CLI来初始化 一个名为supabase-ionic-angular的应用程序。&#xA;npm install -g @ionic/cli&#xD;ionic start supabase-ionic-angular blank --type angular&#xD;cd supabase-ionic-angular&#xD;然后让我们安装唯一的额外依赖：supabase-js&#xA;npm install @supabase/supabase-js&#xD;最后我们要在environment.ts文件中保存环境变量。 我们所需要的是API URL和你[早些时候]复制的anon密钥(#get-theapi-keys)。 这些变量将暴露在浏览器上，这完全没有问题，因为我们在数据库上启用了行级安全。&#xA;export const environment = {&#xD;production: false,&#xD;supabaseUrl: &amp;#39;YOUR_SUPABASE_URL&amp;#39;,&#xD;supabaseKey: &amp;#39;YOUR_SUPABASE_KEY&amp;#39;,&#xD;}&#xD;现在我们有了API凭证，让我们用ionic g s supabase创建一个SupabaseService，以初始化Supabase客户端，并实现与Supabase API通信的功能。&#xA;import { Injectable } from &amp;#39;@angular/core&amp;#39;&#xD;import { LoadingController, ToastController } from &amp;#39;@ionic/angular&amp;#39;&#xD;import { AuthChangeEvent, createClient, Session, SupabaseClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;import { environment } from &amp;#39;.</description>
    </item>
    <item>
      <title>快速入门: Ionic React</title>
      <link>http://localhost:1313/docs/app/quickstart/with-ionic-react/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-ionic-react/</guid>
      <description>GitHub link如果你在阅读指南时遇到困难，请参考此版本。&#xA;构建应用程序 link让我们开始从头开始构建React应用程序。&#xA;初始化一个Ionic React应用程序 link我们可以使用Ionic CLI来初始化 一个名为 supabase-ionic-react的应用程序。&#xA;npm install -g @ionic/cli&#xD;ionic start supabase-ionic-react blank --type react&#xD;cd supabase-ionic-react&#xD;然后让我们安装唯一的额外依赖：supabase-js&#xA;npm install @supabase/supabase-js&#xD;最后，我们要把环境变量保存在.env中。 我们所需要的是API URL和你[早些时候]复制的anon密钥(#get-theapi-keys)。&#xA;REACT_APP_SUPABASE_URL=YOUR_SUPABASE_URL&#xD;REACT_APP_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY&#xD;现在我们已经有了API凭证，让我们创建一个辅助文件来初始化Supabase客户端。这些变量将被暴露在 在浏览器上，这完全没有问题，因为我们的数据库已经启用了行级安全。&#xA;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;const supabaseUrl = process.env.REACT_APP_SUPABASE_URL&#xD;const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY&#xD;export const supabase = createClient(supabaseUrl, supabaseAnonKey)&#xD;设置一个登录路线 link让我们设置一个React组件来管理登录和注册。我们将使用Magic Links，所以用户可以用他们的电子邮件登录，而不使用密码。&#xA;import { useState } from &amp;#39;react&amp;#39;;&#xD;import {&#xD;IonButton,&#xD;IonContent,&#xD;IonHeader,&#xD;IonInput,&#xD;IonItem,&#xD;IonLabel,&#xD;IonList,&#xD;IonPage,&#xD;IonTitle,&#xD;IonToolbar,&#xD;useIonToast,&#xD;useIonLoading,&#xD;} from &amp;#39;@ionic/react&amp;#39;;&#xD;import { supabase } from &amp;#39;.</description>
    </item>
    <item>
      <title>快速入门: RedwoodJS</title>
      <link>http://localhost:1313/docs/app/quickstart/with-redwoodjs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-redwoodjs/</guid>
      <description>介绍 link为了与其他框架的Quickstart例子保持一致，我们将建立一个RedwoodJS，与正常情况下有点不同。&#xA;我们不使用Prisma连接到Supabase Postgres数据库或Prisma迁移，因为在Redwood应用中通常会这样做。 相反，我们将依靠Supabase客户端在网络端做一些工作，并在API端再次使用客户端来做数据获取。&#xA;这意味着你要避免运行任何 &amp;ldquo;yarn rw prisma migrate &amp;ldquo;命令，还要在部署时仔细检查你的构建命令，以确保Prisma不会重置你的数据库。&#xA;info&#xD;TLDR; Prisma目前不支持跨模式外键，所以由于你的Supabase public模式是如何引用auth.users的，反省模式失败。&#xA;这个例子提供了使用Supabase和RedwoodJS建立一个简单的用户管理应用程序的步骤（从头开始！）。它包括。&#xA;MemFire Cloud Database：一个用于存储用户数据的Postgres数据库。 MemFire Cloud Auth：用户可以用魔法链接登录（没有密码，只有电子邮件）。 MemFire Cloud Storage：用户可以上传照片。 Instant APIs。当你创建你的数据库表时，API将自动生成。 行级安全：数据受到保护，个人只能访问自己的数据。 在本指南结束时，你将拥有一个允许用户登录并更新一些基本资料细节的应用程序。&#xA;info&#xD;注意：对于RedwoodJS应用程序，端口将是8910。&#xA;GitHub link如果你在任何时候被卡住了，请看一下这个 repo。&#xA;关于RedwoodJS link一个Redwood应用程序被分成两部分：一个前端和一个后端。这表现为在一个单一的monorepo中的两个node项目。&#xA;前台项目被称为**web，后台项目被称为api**。 它们是独立的项目，因为 &amp;ldquo;web端 &amp;ldquo;的代码最终将在用户的浏览器中运行，而 api端的代码将在某个服务器上运行。&#xA;info&#xD;重要提示：当本指南提到 API时，指的是Supabase API，当它提到 api端时，指的是RedwoodJS api端。&#xA;**api端**是一个GraphQL API的实现。业务逻辑被组织成 服务，代表他们自己的内部API，可以从外部GraphQL请求和其他内部服务中调用。&#xA;网络端 &amp;ldquo;***是用React构建的。Redwood的路由器可以简单地将URL路径映射到React的 页面组件（并在每个路径上自动分割你的应用代码）。 页面可以包含一个 Layout组件来包装内容。它们还包含 单元格和常规的React组件。 单元允许你声明性地管理一个获取和显示数据的组件的生命周期。&#xA;info&#xD;为了与其他框架的Quickstart例子保持一致，我们将建立一个RedwoodJS，与正常情况下有点不同。 我们不使用Prisma来连接Supabase Postgres数据库或Prisma迁移，因为在Redwood应用中通常会这样做。 相反，我们将依靠Supabase客户端来完成**web方面的一些工作，并在api**方面再次使用客户端来进行数据获取。&#xA;项目设置 link在我们开始构建之前，我们要设置我们的数据库和API。这就像在Supabase中启动一个新项目一样简单 然后在数据库中创建一个 &amp;ldquo;模式&amp;rdquo;。&#xA;info&#xD;在设置Supabase时，你会与你的项目仪表板互动。然而，大多数RedwoodJS的设置步骤将与Redwood CLI互动，以生成路由、页面、组件等。 因此，请确保在你的项目目录中准备好一个终端。</description>
    </item>
    <item>
      <title>快速入门: SolidJS</title>
      <link>http://localhost:1313/docs/app/quickstart/with-solidjs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-solidjs/</guid>
      <description>GitHub link如果你在阅读指南时遇到困难，请参考此版本.&#xA;构建应用程序 link让我们开始从头开始构建SolidJS应用程序。&#xA;初始化一个SolidJS应用程序 link我们可以使用Degit来初始化一个名为supabase-solid的应用程序。&#xA;npx degit solidjs/templates/ts supabase-solid&#xD;cd supabase-solid&#xD;然后让我们安装唯一的额外依赖：supabase-js&#xA;npm install @supabase/supabase-js&#xD;最后，我们要把环境变量保存在.env中。 我们所需要的是API URL和你[早些时候]复制的anon密钥（#get-theapi-keys）。&#xA;VITE_SUPABASE_URL=YOUR_SUPABASE_URL&#xD;VITE_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY&#xD;现在我们已经有了API凭证，让我们创建一个辅助文件来初始化Supabase客户端。这些变量将被暴露在 在浏览器上，这完全没有问题，因为我们的数据库已经启用了行级安全。&#xA;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;const supabaseUrl = import.meta.env.VITE_SUPABASE_URL&#xD;const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY&#xD;export const supabase = createClient(supabaseUrl, supabaseAnonKey)&#xD;还有一个可选的步骤是更新CSS文件src/index.css以使应用程序看起来漂亮。 你可以找到这个文件的全部内容这里&#xA;设置一个登录组件 link让我们设置一个 SolidJS 组件来管理登录和注册。我们将使用Magic Links，因此用户可以用他们的电子邮件登录，而无需使用密码。&#xA;import { createSignal } from &amp;#39;solid-js&amp;#39;&#xD;import { supabase } from &amp;#39;./supabaseClient&amp;#39;&#xD;export default function Auth() {&#xD;const [loading, setLoading] = createSignal(false)&#xD;const [email, setEmail] = createSignal(&amp;#39;&amp;#39;)&#xD;const handleLogin = async (e: SubmitEvent) =&amp;gt; {&#xD;e.</description>
    </item>
    <item>
      <title>快速入门: SvelteKit</title>
      <link>http://localhost:1313/docs/app/quickstart/with-sveltekit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/quickstart/with-sveltekit/</guid>
      <description>GitHub link如果你在阅读指南时遇到困难，请参考此版本。&#xA;构建应用程序 link让我们从头开始构建Svelte应用程序。&#xA;初始化一个Svelte应用程序 link我们可以使用SvelteKit骨架项目来初始化 一个名为 supabase-sveltekit的应用程序（本教程中你不需要TypeScript、ESLint、Prettier或Playwright）。&#xA;npm init svelte@next supabase-sveltekit&#xD;cd supabase-sveltekit&#xD;npm install&#xD;然后让我们安装唯一的额外依赖：supabase-js&#xA;npm install @supabase/supabase-js&#xD;最后，我们要把环境变量保存在.env中。 我们所需要的是SUPABASE_URL和你[早些时候]复制的SUPABASE_KEY键(#get-the-api-keys)。&#xA;PUBLIC_SUPABASE_URL=&amp;#34;YOUR_SUPABASE_URL&amp;#34;&#xD;PUBLIC_SUPABASE_ANON_KEY=&amp;#34;YOUR_SUPABASE_KEY&amp;#34;&#xD;现在我们已经有了API凭证，让我们创建一个辅助文件来初始化Supabase客户端。这些变量将被暴露在 在浏览器上，这完全没有问题，因为我们的数据库已经启用了行级安全。&#xA;import { createClient } from &amp;#39;@supabase/auth-helpers-sveltekit&amp;#39;&#xD;import { env } from &amp;#39;$env/dynamic/public&amp;#39;&#xD;export const supabase = createClient(env.PUBLIC_SUPABASE_URL, env.PUBLIC_SUPABASE_ANON_KEY)&#xD;还有一个可选的步骤是更新CSS文件public/global.css以使应用程序看起来漂亮。 你可以找到这个文件的全部内容这里。&#xA;Supabase 认证帮助程序 linkSvelteKit是一个高度通用的框架，在构建时提供预渲染（SSG），在请求时提供服务器端渲染（SSR），API路由等。&#xA;在所有这些不同的环境中对你的用户进行认证是很有挑战性的，这就是为什么我们创建了Supabase Auth Helpers来使SvelteKit内的用户管理和数据获取尽可能简单。&#xA;安装SvelteKit的Auth助手。&#xA;npm install @supabase/auth-helpers-sveltekit&#xD;更新你的src/routes/+layout.svelte。&#xA;&amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt;&#xD;import { supabase } from &amp;#39;$lib/supabaseClient&amp;#39;&#xD;import { invalidate } from &amp;#39;$app/navigation&amp;#39;&#xD;import { onMount } from &amp;#39;svelte&amp;#39;&#xD;import &amp;#39;.</description>
    </item>
    <item>
      <title>概述</title>
      <link>http://localhost:1313/docs/app/auth/auth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth/</guid>
      <description>概述 link每个认证系统都有两个部分。&#xA;认证：这个人应该被允许进入吗？如果是的话，他们是谁？ 授权：一旦他们进入，他们被允许做什么？ Supabase Auth被设计为既可以作为一个独立的产品，也可以与其他Supabase产品深度集成。 Postgres是我们一切工作的核心，Auth系统也遵循这一原则。我们尽可能地利用Postgres的内置Auth功能。&#xA;下面是Supabase内置的Auth功能的2分钟快速浏览。&#xA;身份认证 link你可以通过几种方式来验证你的用户。&#xA;电子邮件和密码。 Magic links（一键登录）。 社交媒体登录认证服务商。 电话登录。 配置第三方服务商 link你可以通过点击一个按钮来启用第三方提供商，方法是浏览认证 &amp;gt; 设置 &amp;gt; Auth Providers，并为每个提供商输入你的 客户端ID和 密匙。&#xA;重定向URLs和通配符 link当使用第三方提供商时，Supabase客户端库将用户重定向到提供商。当第三方服务商成功认证用户时，服务商将用户重定向到Supabase Auth回调URL，在那里他们将被进一步重定向到redirectTo参数中指定的URL。这个参数默认为SITE_URL。你可以修改SITE_URL或添加额外的重定向URL。&#xA;你可以使用通配符匹配模式来支持Netlify和Vercel等服务商的预览URL。见支持模式的完整列表。&#xA;Netlify预览URLs link对于使用Netlify的部署，将SITE_URL设置为你的官方网站URL。为本地开发和部署预览添加以下额外的重定向URL。&#xA;http://localhost:3000/*/* https://**--my_org.netlify.app/* Vercel预览网址 link对于使用Vercel的部署，将SITE_URL设置为你的官方网站URL。为本地开发和部署预览添加以下额外的重定向URL。&#xA;http://localhost:3000/*/* https://**vercel.app/*/* Vercel为部署的URL提供了一个环境变量，称为NEXT_PUBLIC_VERCEL_URL。更多细节见Vercel docs。你可以使用这个变量，根据环境动态地重定向。&#xA;const { data, error } = await supabase.auth.signInWithOAuth({&#xD;provider: &amp;#39;github&amp;#39;&#xD;options: {&#xD;redirectTo: process.env.NEXT_PUBLIC_VERCEL_URL&#xD;? `https://${process.env.NEXT_PUBLIC_VERCEL_URL}`&#xD;: &amp;#34;http://localhost:3000&amp;#34;&#xD;}&#xD;}&#xD;移动端深层链接 URI link对于移动应用程序，您可以使用深度链接URI。例如，对于您的SITE_URL，您可以指定类似于com.supabase://login-callback/的内容，如果需要额外的重定向URL，则可以使用类似于com.supabase.staging://login-callback/的内容。&#xA;授权 link当你需要细化的授权规则时，没有什么比PostgreSQL的行级安全（RLS）更重要了。&#xA;策略是PostgreSQL的规则引擎。它们是非常强大和灵活的，允许你编写复杂的SQL规则，以满足你独特的业务需求。&#xA;从我们的行级安全指南开始吧。&#xA;行级安全 link认证只解决了用户身份验证的问题，但并没有涉及用户在系统中的权限和访问级别。为了解决这个问题，您需要使用到PostgreSQL的行级安全性（RLS）的特性。该特性通过打开和关闭RLS选项，使得授权变得非常简单。&#xA;策略 link策略是PostgreSQL的规则引擎。它们非常强大和灵活，允许你编写复杂的SQL规则，以适应你独特的业务需求。&#xA;如果设置了策略(Policy)，你的数据库就成了规则引擎。就不需要编写如下复杂的查询语句：</description>
    </item>
    <item>
      <title>使用电子邮件登录</title>
      <link>http://localhost:1313/docs/app/auth/authentication/auth-email/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/authentication/auth-email/</guid>
      <description>概述 link为 MemFireCloud 应用程序设置电子邮件登录。&#xA;将电子邮件验证器添加到MemFire Cloud项目 将登录代码添加到应用程序 - JavaScript | Flutter 配置电子邮件设置 link 对于 网站 URL, 输入应用程序的最终（托管）URL。 对于 身份验证服务商, 启用电子邮件提供程序. info&#xD;对于自托管，可以使用提供的文件和环境变量更新项目配置。 有关详细信息，请参阅自托管文档。&#xA;将登录代码添加到客户端应用程序 link&#xD;JavaScript&#xD;Dart&#xD;当用户登录时，使用其电子邮件地址和密码调用signInWithPassword()：&#xA;async function signInWithEmail() {&#xD;const { data, error } = await supabase.auth.signInWithPassword({&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;})&#xD;}&#xD;当用户登录时，使用其电子邮件地址和密码调用signInWithPassword()：&#xA;Future&amp;lt;void&amp;gt; signInWithEmail() async {&#xD;final AuthResponse res = await supabase.auth.signInWithPassword(&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;&#xD;);&#xD;}&#xD;JavaScript&#xD;Dart&#xD;当用户注销时，调用signOut()将其从浏览器会话和localStorage中删除：&#xA;async function signOut() {&#xD;const { error } = await supabase.</description>
    </item>
    <item>
      <title>手机登录认证</title>
      <link>http://localhost:1313/docs/app/auth/authentication/phoneauth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/authentication/phoneauth/</guid>
      <description>前言 link为了顺应国内用户的使用习惯，MemFire Cloud提供了手机号码验证的登录方式，可以兼容国内的阿里云服务商，用户可以采用手机号+短信的放式进行用户身份认证。&#xA;使用步骤 link1.开启手机验证 link进入“用户认证”-&amp;gt;“服务商”页面，启用手机号码验证，短信（SMS）服务商选择“阿里云”，依次填写好阿里云配置后点击保存。&#xA;当启用“短信验证”时，说明您需要发送短信验证码来进行手机认证，您需要填写正确的阿里云短信签名名称和短信模板CODE&#xA;2.示例教程 linkMemFire Cloud 提供两种手机登录认证方式，分别如下：&#xA;① 手机号+验证码登录认证 link用户使用手机号获取验证码。&#xA;SDK的使用教程&#xA;//获取验证码&#xD;async function getQRcode(){&#xD;let { data, error } = await _supabase.auth.signInWithOtp({&#xD;phone: phone,&#xD;})&#xD;if(error){&#xD;alert(error)&#xD;}&#xD;alert(&amp;#39;短信已发送至您的手机中，请注意查收。&amp;#39;)&#xD;}&#xD;//登录&#xD;async function sigin(){&#xD;let { data, error } = await _supabase.auth.verifyOtp({&#xD;phone: phone,&#xD;token: QRcode,&#xD;type: &amp;#39;sms&amp;#39;,&#xD;})&#xD;if(error){&#xD;alert(error)&#xD;return;&#xD;}&#xD;alert(&amp;#39;登录成功！&amp;#39;) }&#xD;② 手机号+密码+验证码认证 link图示 link先用手机号+密码获取验证码进行注册&#xA;随后会在用户列表里刚刚那条等待验证的用户信息&#xA;输入验证码，点击注册，会发现用户列表的用户已经认证成功。&#xA;SDK的使用教程&#xA;1.用户使用手机号+密码先来获取验证码进行注册。&#xA;//获取验证码（注册）&#xD;async function getQRcode(){&#xD;let { data, error } = await _supabase.</description>
    </item>
    <item>
      <title>微信小程序登录认证</title>
      <link>http://localhost:1313/docs/app/auth/authentication/wechatauth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/authentication/wechatauth/</guid>
      <description>前言 link为了顺应国内用户的使用习惯，MemFire Cloud 的SDK推出了微信可以在不同应用场景下的登录方式，以下两种场景是MemFire Cloud 推荐的微信登录方式，我们以简单的小示例来做示范，具体的实现还需要根据业务自身的场景来判断。&#xA;① 微信用户授权登录 link首次进入小程序，点击登录后会立即跳转个人中心页进行个人资料的修改，或者可以点击个人中心页面进行个人资料的修改&#xA;前提条件：&#xA;在MemFire Cloud认证服务商页面启用微信小程序认证 图例&#xA;首页代码示例：&#xA;html&#xA;&amp;lt;button style=&amp;#34;border-radius: 100rpx;margin-top: 300rpx;&amp;#34; type=&amp;#34;primary&amp;#34; bindtap=&amp;#34;login&amp;#34;&amp;gt;微信快速登录&amp;lt;/button&amp;gt;&#xD;SDK使用教程&#xA;signInWithWechat接口接受一个wx.login返回的code参数，通过code兑换openid等信息，并判断用户是否存在，不存在则自动创建&#xA;// pages/main/index.ts&#xD;import { supabase } from &amp;#39;../../lib/supabase&amp;#39;&#xD;Page({&#xD;data: {&#xD;},&#xD;login(){&#xD;wx.login({&#xD;success: async res =&amp;gt; {&#xD;const { data, error } = await supabase.auth.signInWithWechat({code:res.code})&#xD;if(error){&#xD;wx.showToast({&#xD;title: error?.error || error?.msg,&#xD;icon: &amp;#34;none&amp;#34;,&#xD;duration: 2000&#xD;})&#xD;}else if(data){&#xD;setTimeout(() =&amp;gt; {&#xD;wx.showModal({&#xD;title: &amp;#39;提示&amp;#39;,&#xD;content: &amp;#39;登录成功！去填充个人资料吧！&amp;#39;,&#xD;success (res) {&#xD;if (res.</description>
    </item>
    <item>
      <title>使用Magic Link登录</title>
      <link>http://localhost:1313/docs/app/auth/authentication/auth-magic-link/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/authentication/auth-magic-link/</guid>
      <description>Magic Link是一种无密码登录的形式，用户单击发送到其电子邮件地址的链接即可登录其帐户。 Magic Link仅适用于电子邮件地址。默认情况下，用户只能每60秒请求一次Magic Link。&#xA;概述 link为MemfireCloud应用程序提供Magic Link登录。&#xA;将登录代码添加到应用程序 - JavaScript | Flutter 将Magic Link添加到您的 MemfireCloud 项目中 link 对于网站URL, 输入应用程序的最终（托管）URL。 对于 身份验证服务商, 启用电子邮件提供商. 将登录代码添加到客户端应用程序 link&#xD;JavaScript&#xD;Dart&#xD;当您的用户登录时，使用其电子邮件地址调用signInWithOtp():&#xA;async function signInWithEmail() {&#xD;const { data, error } = await supabase.auth.signInWithOtp({&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;})&#xD;}&#xD;当您的用户登录时，使用其电子邮件地址调用signIn():&#xA;Future&amp;lt;void&amp;gt; signInWithEmail() async {&#xD;final AuthResponse res = await supabase.auth.signinwithotp(email: &amp;#39;example@email.com&amp;#39;);&#xD;}&#xD;JavaScript&#xD;Dart&#xD;当用户注销时，调用signOut()将其从浏览器会话和localStorage中删除:&#xA;async function signOut() {&#xD;const { error } = await supabase.</description>
    </item>
    <item>
      <title>使用Apple登录</title>
      <link>http://localhost:1313/docs/app/auth/authentication/auth-apple/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/authentication/auth-apple/</guid>
      <description>要为项目启用Apple Auth，您需要设置Apple OAuth应用程序，并将应用程序凭据添加到MemFire Cloud项目仪表板。&#xA;概述 linkApple OAuth包括六大步骤：&#xA;获取具有 使用Apple登录 功能的 App Id。 获取Services Id - 这将用作 client_id。 获取用于获取 client_secret的secret key。 使用 secret key生成client_secret。 将您的 client id和 client secret 密钥添加到MemFire Clpud Project。 将登录代码添加到JS客户端应用程序。 访问您的Apple Developer帐户 link 进入developer.apple.com. 点击右上方的 账户来登录。 获取应用程序ID link 跳转到Certificates, Identifiers &amp;amp; Profiles文件. 单击左侧的Identifiers。 单击左上角Identifiers旁边的+符号。 选择 App IDs并单击 继续。 选择 App 类型，然后单击继续。 填写应用程序信息： 应用程序描述。 绑定ID (苹果推荐反向域名风格，所以如果你的域名是acme.com，而您的应用程序称为roadrunner，请使用：com.acme.roadrunner)。 向下滚动并选中使用Apple登录。 单击右上角的继续。 单击右上角的注册。 获取服务ID link当您进行API调用以验证用户时，这将用作client_id。&#xA;跳转到Certificates, Identifiers &amp;amp; Profiles文件. 单击左侧的Identifiers。 单击左上角Identifiers旁边的+符号。 选择 Services IDs 并单击“继续”。 填写应用程序信息： 应用程序描述。 绑定ID (您不能使用上一步中的同一绑定的ID，但可以在开头添加一些内容，例如app.</description>
    </item>
    <item>
      <title>使用GitHub登录</title>
      <link>http://localhost:1313/docs/app/auth/authentication/auth-github/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/authentication/auth-github/</guid>
      <description>要为项目启用GitHub Auth，您需要设置一个GitHub OAuth应用程序，并将应用程序凭据添加到Supabase Dashboard。&#xA;概述 link为应用程序设置GitHub登录由三部分组成:&#xA;在GitHub上创建和配置GitHub OAuth应用程序 将GitHub OAuth密钥添加到MemFire Cloud项目 将登录代码添加到JS客户端应用程序 访问您的GitHub帐户 link 进入 github.com. 单击右上角的登录以登录。 创建GitHub Oauth应用程序 link转到GitHub开发者设置页面:&#xA;单击右上方的个人资料照片 单击菜单底部附近的设置 在左侧边栏中，单击开发人员设置（靠近底部） 在左侧边栏中，单击OAuth Apps 查找回调URL link下一步需要回调URL，如下所示：&#xA;https://&amp;lt;project-ref&amp;gt;.supabase.co/auth/v1/callback&#xA;转到MemFire Cloud项目仪表板. 单击左侧边栏底部的设置图标。 单击列表中的API。 在Config/URL下，您将找到您的API URL，您可以单击复制将其复制到剪贴板。 现在只需在末尾添加/auth/v1/callback即可获得完整的OAuth重定向URI。 注册新的OAuth应用程序 link 单击注册新应用程序。如果您以前创建过应用程序，请单击此处的新建OAuth应用程序。 在应用程序名称中，键入应用程序的名称。 在主页URL中，键入应用程序网站的完整URL。 在授权回调URL中，键入应用的回调URL。 在有效OAuth重定向URI框中输入URL。 单击右下角的保存更改。 单击注册应用程序。 复制新的OAuth凭据&#xA;复制并保存客户端ID。 单击生成新客户端密钥。 复制并保存客户端密码。 将您的GitHub凭据输入到Supabase项目中 link 转到MemFire Cloud项目仪表板 在左侧边栏中，单击身份验证图标（靠近顶部） 单击列表中的设置以转到身份验证设置页面 在站点URL下输入应用程序的最终（托管）URL（这很重要） 在外部OAuth提供程序下，将已启用GitHub设置为ON 输入上一步中保存的GitHub客户端ID 和GitHubClient Secret 单击保存 将登录代码添加到客户端应用程序 link当您的用户登录时,调用signInWithOAuth(),将github作为provider:&#xA;async function signInWithGitHub() {&#xD;const { data, error } = await supabase.</description>
    </item>
    <item>
      <title>使用GitLab登录</title>
      <link>http://localhost:1313/docs/app/auth/authentication/auth-gitlab/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/authentication/auth-gitlab/</guid>
      <description>要为项目启用GitLab Auth，您需要设置一个GitLab OAuth应用程序，并将应用程序凭据添加到Supabase Dashboard。&#xA;概述 link为应用程序设置GitLab登录由三部分组成：&#xA;在GitLab上创建和配置GitLab应用程序 将GitLab应用程序密钥添加到MemFire Cloud项目 将登录代码添加到JS客户端应用程序 访问您的GitLab帐户 link 进入 gitlab.com. 单击右上角的登录以登录。 查找回调URL link下一步需要回调URL，如下所示：&#xA;https://&amp;lt;project-ref&amp;gt;.supabase.co/auth/v1/callback&#xA;转到MemFire Cloud项目仪表板. 单击左侧边栏底部的设置图标。 单击列表中的API。 在Config/URL下，您将找到您的API URL，您可以单击复制将其复制到剪贴板。 现在只需在末尾添加/auth/v1/callback即可获得完整的OAuth重定向URI。 创建GitLab应用程序 link 单击右上角的个人资料徽标（头像）。 选择编辑配置文件。 在左侧边栏中，选择应用程序。 输入应用程序的名称。 在重定向URI框中，键入应用程序的回调URL。 选中机密旁边的复选框（确保选中）。 检查名为read_user的作用域（这是唯一需要的作用域）。 单击底部的保存应用程序。 复制并保存您稍后需要的应用程序ID（client_ID）和机密（client _Secret）。 将您的GitLab凭据添加到Suabase项目中 link 转到MemFire Cloud项目仪表板. 在左侧边栏中，单击身份验证图标（靠近顶部）。 单击列表中的设置以转到身份验证设置页面。 在站点URL下输入应用程序的最终（托管）URL（这很重要）。 在外部OAuth提供程序下，将GitLab Enabled设置为ON。 输入上一步中保存的client_id和client_secret。 单击保存。 将登录代码添加到客户端应用程序 link当您的用户登录时，调用signInWithOAuth()，并将gitlab作为provider：&#xA;async function signInWithGitLab() {&#xD;const { data, error } = await supabase.auth.signInWithOAuth({&#xD;provider: &amp;#39;gitlab&amp;#39;,&#xD;})&#xD;}&#xD;当用户注销时，调用signOut()将其从浏览器会话和localStorage中删除：&#xA;async function signout() {&#xD;const { error } = await supabase.</description>
    </item>
    <item>
      <title>行级别安全性</title>
      <link>http://localhost:1313/docs/app/auth/mandates/row-level-security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/mandates/row-level-security/</guid>
      <description>当您需要更精细的授权规则时，PostgreSQL的行级安全（RLS）是很好的选择。&#xA;策略是PostgreSQL的规则引擎。它们非常强大和灵活，允许你编写复杂的SQL规则，以满足你独特的业务需求。&#xA;策略 link每个数据库表可以添加一个或多个策略（policy），每当表被访问（增，删，改、查等操作）时，都会执行（校验）设置的策略，就好比为每个sql语句添加了一个where的查询条件。以下是一个策略的例子：&#xA;create policy &amp;#34;Individuals can view their own todos.&amp;#34;&#xD;on todos for select&#xD;using ( auth.uid() = user_id );&#xD;上面的策略在执行sql查询时被转化成以下语句(每当用户查询todos这张表时，只会查询包含自己ID的记录)：&#xA;select *&#xD;from todos&#xD;where auth.uid() = todos.user_id; -- Policy is implicitly added.&#xD;辅助函数 linkSupabase为您提供了一些简单的功能，您可以在策略中使用这些功能。&#xA;auth.uid() link返回当前前端请求的用户id值。&#xA;auth.jwt() link返回当前前端请求的用户jwt值。&#xA;示例 link下面是一些示例，向您展示PostgreSQL的RLS的强大功能。&#xA;允许读取访问 link&#xD;-- 1. Create table&#xD;create table profiles (&#xD;id uuid references auth.users,&#xD;avatar_url text&#xD;);&#xD;-- 2. Enable RLS&#xD;alter table profiles&#xD;enable row level security;&#xD;-- 3.</description>
    </item>
    <item>
      <title>RLS使用教程</title>
      <link>http://localhost:1313/docs/app/auth/mandates/row-level-security2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/mandates/row-level-security2/</guid>
      <description>前言 link在使用MemFire Cloud的BaaS服务进行应用开发时，比较困扰开发者的是RLS的使用。本篇先从基本概念入手对RLS进行简要介绍，帮助大家理解RLS的工作机制和基本使用方法。&#xA;什么是RLS ？ link全称：Row level security，行级安全，允许系统管理员为数据库表创建访问策略（policy），以约束数据的可见性。当为一个表创建了policy后，相当于为该表增加了一个高优先级的过滤器。当用户访问该表时，如果policy生效，则会根据policy中定义的过滤条件来决定用户可操作的数据集合。&#xA;如何添加RLS link我们使用MemFire Cloud开发应用时，需要关注的对象包括数据表、对象存储的bucket，可以使用RLS来设置用户的访问权限，保证用户数据安全性。&#xA;数据表 link数据表里的RLS默认是不开启的，此时注册应用的用户是可以增删改查数据表中任何数据。&#xA;当用户开启了RLS，但没有设置任何访问策略时，会拒绝用户访问该表中的任何数据。&#xA;补充说明：如果启用RLS，至少要创建一条最简单的策略（如：允许任何人访问数据），否接口调试时会查询不到数据。&#xA;以下是给指定表启用RLS的方法：&#xA;① 使用SQL命令启用RLS&#xA;RLS默认是不开启的，可针对每个表执行如下语句来对该表开启RLS功能：&#xA;ALTER TABLE &amp;lt;name&amp;gt; ENABLE ROW LEVEL SECURITY&#xD;② 新建表时默认启用行级安全策略&#xA;③ 用户认证-&amp;gt;策略-&amp;gt;给指定表启用RLS&#xA;对象存储bucket link对象存储bucket的RLS默认就是开启的，无需手动开启。新建bucket时，如果选择公开bucket，则任何人可以访问bucket中的对象文件；否则无权访问。&#xA;如何给数据表设置访问权限 link创建一个应用后，MemFire Cloud后台会默认创建一个auth.users系统表，主要用来记录用户的注册信息，其中有三个字段：id(用户唯一标识UID)、email(用户注册邮箱)、role(用户角色信息)。&#xA;应用开发者在创建数据表时，可使用一个字段来标记是哪个用户的数据，通常采用id(用户唯一标识UID)、email(用户注册邮箱)来标记。&#xA;常用函数介绍 linkMemFire Cloud封装了三个函数，用于获取向数据库发出请求的不同唯一标识，其中包括：&#xA;① auth.role() :用于获取向数据库发出请求的用户的当前角色。它可以被用于策略中，根据用户的角色限制或允许访问某些表或行。该函数返回一个代表用户角色的字符串，它可以是下列之一：已认证的（authenticated），匿名的（anon），或你定义的自定义角色。&#xA;② auth.email() **:**用于获取向数据库发出请求的用户的电子邮件。这个函数可以在策略中使用，根据用户的电子邮件限制或允许访问某些表或行。&#xA;③ auth.uid() : 用于获取向数据库提出请求的用户的唯一标识符（UID）。这个函数可以在策略中使用，根据用户的UID限制或允许访问某些表或行。&#xA;策略实例 link 为所有用户启用访问权限 为所有用户提供对数据表的访问权限&#xA;当**USING设置为true**时，表示访问数据表时不需要做任何校验&#xA;Create POLICY &amp;#34;策略名称&amp;#34; ON public.&amp;#34;表名&amp;#34;&#xD;AS PERMISSIVE&#xD;FOR SELECT&#xD;USING( true ) ;&#xD;仅允许身份验证用户启用访问权限 为所有经过身份验证的用户提供对数据表的访问权限&#xA;Create POLICY &amp;#34;策略名称&amp;#34;&#xD;ON public.</description>
    </item>
    <item>
      <title>管理用户数据</title>
      <link>http://localhost:1313/docs/app/auth/mandates/managing-user-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/mandates/managing-user-data/</guid>
      <description>出于安全目的，auth模式不会在自动生成的API上公开。&#xA;尽管MemFireCloud提供了一个auth.users表，用于存储用户身份验证信息，但是当你希望通过API访问用户数据时，创建在public模式中的其他表也是有帮助的。 这意味着你可以在公共模式中创建自定义的表格，用于存储其他与用户相关的数据，以便通过API进行访问和操作。这样可以灵活地组织和管理你的用户数据，并与auth.users表中的用户身份验证信息结合使用。&#xA;创建用户表 link当你创建用于存储用户数据的表时，参考auth.users表的主键可以确保数据完整性。 在引用auth.users时，还要指定on delete cascade子句。省略此子句可能会在删除用户时导致问题。&#xA;例如，一个public.profiles表可能如下所示：&#xA;create table public.profiles (&#xD;id uuid references auth.users not null,&#xD;first_name text,&#xD;last_name text,&#xD;primary key (id)&#xD;);&#xD;alter table public.profiles enable row level security;&#xD;info&#xD;如果设置了用户令牌使用服务密钥初始化客户端，不会覆盖行级安全（RLS）。如果用户使用客户端登录，MemFireCloud将遵循该用户的行级安全策略。&#xA;公共通道 link由于启用了行级别安全性，因此可以通过API访问此表，但除非我们设置了一些策略，否则不会返回任何数据。 如果我们希望每个人都可以读取数据，但只允许登录用户更新自己的数据，则策略如下：&#xA;create policy &amp;#34;Public profiles are viewable by everyone.&amp;#34;&#xD;on profiles for select&#xD;using ( true );&#xD;create policy &amp;#34;Users can insert their own profile.&amp;#34;&#xD;on profiles for insert&#xD;with check ( auth.</description>
    </item>
    <item>
      <title>服务器端渲染</title>
      <link>http://localhost:1313/docs/app/auth/mandates/server-side-rendering/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/mandates/server-side-rendering/</guid>
      <description>带有服务器端渲染（SSR）的单页应用程序是优化渲染的流行方法 性能和利用高级缓存策略。&#xA;当您需要访问用户时，Supbasse Auth支持服务器端呈现 信息，或者您的服务器需要代表您的 用户来呈现内容。&#xA;当用户使用Supabase Auth进行身份验证时 由服务器发布：&#xA;1.JWT形式的访问令牌。 2.刷新令牌，它是随机生成的字符串。&#xA;大多数Supabase项目的认证服务器都在监听 &amp;lt;project-ref&amp;gt;.supabase.co/auth/v1， 因此访问令牌和刷新令牌是 在上设置为sb-access-token和sb-refresh-tokencookie &amp;lt;project-ref&amp;gt;.supabase.co域。&#xA;info&#xD;这些cookie名称仅供Suabase内部使用，在没有 警告本指南中包含的内容仅供说明之用。&#xA;Web浏览器限制跨域访问cookie，与 同源政策 (SOP).&#xA;您的web应用程序无法访问这些cookie， 这些cookie也不会发送到应用程序的服务器。&#xA;了解身份验证流程 link调用其中一个signIn方法时 浏览器将请求发送到Supabase Auth服务器。 身份验证服务器确定 是否验证电话号码、电子邮件和密码组合、Magic Link， 或者使用社交登录（如果项目中有任何设置）。 成功验证用户身份后，Supabase认证 服务器将用户重定向回单页应用程序。&#xA;info&#xD;您可以配置重定向URL在Supabase Dashboard中。您可以使用通配符匹配模式 如*和**，以允许重定向到不同形式的URL。&#xA;这些重定向URL具有以下结构：&#xA;https://yourapp.com/...#access_token=&amp;lt;...&amp;gt;&amp;amp;refresh_token=&amp;lt;...&amp;gt;&amp;amp;...&#xD;成功验证后的第一次访问和刷新令牌是 包含在重定向的URL片段（#符号之后的任何内容）中 地方这是故意的，不可配置。 客户端库被设计为侦听这种类型的URL 访问令牌、刷新令牌以及其中的一些额外信息，最后 将其保存在本地存储中，供库和应用程序进一步使用。&#xA;info&#xD;Web浏览器不会将URL片段发送到服务器 请求。 由于您可能没有在以下服务器上托管单页应用 您的直接控制（例如在GitHub Pages或其他免费增值托管 提供商），我们希望阻止托管服务访问您的 默认情况下，用户的授权凭据。 即使服务器在您的 直接控制、GET请求及其完整URL经常被记录。这 该方法还避免了在请求或访问日志中泄漏凭据。&#xA;把它放在一起 link从身份验证流程可以看出，成功后的初始请求 用户登录后，浏览器登录到应用程序的服务器 包含有关用户的任何信息。 这是因为首先客户端 JavaScript库必须在生成访问和刷新令牌之前运行 可用于您的服务器。&#xA;确保在登录后立即重定向路由是非常重要的 无需任何服务器端渲染即可工作。 其他需要授权的路线 不具有相同的限制，前提是发送访问和刷新 令牌发送到服务器。&#xA;这通常是通过设置cookie来完成的。这里有一个例子 可以添加到应用程序的根目录：</description>
    </item>
    <item>
      <title>多因素身份验证</title>
      <link>http://localhost:1313/docs/app/auth/mandates/auth-mfa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/mandates/auth-mfa/</guid>
      <description>info&#xD;Multi-Factor Authentication仅在早期访问预览中。 尽管我们 相信它已经做好了生产准备，API和一些行为可能会根据 我们在预览期收到的反馈。&#xA;多因素身份验证(MFA)，有时称为双因素身份验证 (2FA)，为您的 通过验证他们的身份附加验证步骤。&#xA;将MFA用于应用程序被认为是最佳做法。密码薄弱或社交登录帐户受损的用户 容易被恶意接管账户。这些可以通过 MFA，因为他们要求用户提供 这两个：&#xA;他们知道的事情。 密码或访问社交登录帐户。&#xA;他们有的东西。 访问验证器应用程序（也称为TOTP）、手机或恢复代码。&#xA;概述 linkSupabase Auth仅实现基于时间的一次性因素（TOTP）多因素认证。这种类型的多因素身份验证使用从由用户控制的验证器应用程序。&#xA;使用MFA的应用程序需要两个重要流程：&#xA;1.报名流程 这允许用户在应用程序中设置和控制MFA。&#xA;2.认证流程 这允许用户在常规登录步骤之后使用任何因素登录。&#xA;Supabase Auth提供：&#xA;Enrollment API构建丰富的用户界面以添加和移除身份验证因素。 Challenge and Verify API安全验证用户是否具有访问因素的权限。 List Factors API构建丰富的用户界面以使用其他身份验证因素进行登录。 这些API集允许您控制适用于您的MFA体验。你可以创建MFA为可选、强制或仅为特定的流用户组。&#xA;一旦用户注册或使用某个因子登录，Supabase Auth补充道应用程序可以向用户的访问令牌（JWT）添加附加元数据用于允许或拒绝访问。&#xA;此信息由身份验证器保证级别，一个关于确保超级认证用户身份的标准措施对于该特定会话。目前公认有两个级别：&#xA;1.保证级别1:aal1 表示使用常规登录方法验证了用户的身份例如电子邮件+密码、magic link、一次性密码、电话授权或社交登录。 2.保证级别2:aal2 意味着用户的身份已使用至少一个,例如TOTP码。&#xA;该保证级别编码在与用户相关的JWT中的aal声明中。通过解码此值，您可以在前端、后端和数据库中创建自定义授权规则，以实施适用于应用程序的MFA策略。 没有aal声明的JWT属于aal1级别。&#xA;正在添加到应用程序 link将MFA添加到应用程序包括以下三个步骤：&#xA;**添加注册流程。**您需要在应用程序中提供一个用户界面，用户可以在其中设置MFA。您可以在注册后立即添加，或作为应用程序设置部分中单独流程的一部分添加。 **将挑战步骤添加到登录。**如果用户设置了MFA，您的应用程序的登录流程需要向用户显示一个挑战屏幕，要求他们证明他们可以访问附加因素。 **强制执行MFA登录规则。**一旦您的用户能够使用MFA注册和登录，您就需要在整个应用程序中强制执行授权规则：在前端、后端、API服务器或行级别安全策略上。 添加注册流程 link注册流为用户提供了一个UI，用于设置其他身份验证因素。 大多数应用程序在其应用程序中的两个位置添加注册流程：&#xA;1.登录或注册后立即。这允许用户在登录或创建MFA后立即快速设置MFA 账户如果有意义，我们建议鼓励所有用户设置MFA 用于您的应用程序。许多应用程序将此作为 努力减少上车摩擦。 2.在设置页面内。 允许用户设置、禁用或修改MFA设置。&#xA;我们建议构建一个通用流，在这两种情况下都可以通过少量修改来重用。&#xA;注册MFA使用的因子需要三个步骤：&#xA;1.调用supabase.auth.mfa.enroll()。 此方法返回QR码和密码。显示QR代码给用户，并要求他们用他们的验证器应用程序扫描它。 如果他们无法扫描二维码，请以纯文本显示秘密 他们可以键入或粘贴到他们的验证器应用程序中。&#xA;2.调用supabase.auth.mfa.challenge()API。 这将准备Supabase Auth接受用户的验证码并返回挑战ID。</description>
    </item>
    <item>
      <title>身份验证帮助程序</title>
      <link>http://localhost:1313/docs/app/auth/auth-helpers/auth-helpers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth-helpers/auth-helpers/</guid>
      <description>用于使用Supabase的特定于框架的Auth实用程序的集合。&#xA;{/* Auth UI */}&#xD;</description>
    </item>
    <item>
      <title>身份验证UI</title>
      <link>http://localhost:1313/docs/app/auth/auth-helpers/auth-ui/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth-helpers/auth-ui/</guid>
      <description>Auth UI是用于验证用户的预构建React组件。 它支持定制主题和可扩展样式，以符合您的品牌和审美。&#xA;设置身份验证UI link安装最新版本的supabase js和Auth UI包：&#xA;npm install @supabase/supabase-js @supabase/auth-ui-react&#xD;导入Auth组件 link将 @supabase/supabase-js 中的 supabaseClient 作为属性传递给组件。&#xA;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;import { Auth } from &amp;#39;@supabase/auth-ui-react&amp;#39;&#xD;const supabase = createClient(&amp;#39;&amp;lt;INSERT PROJECT URL&amp;gt;&amp;#39;, &amp;#39;&amp;lt;INSERT PROJECT ANON API KEY&amp;gt;&amp;#39;)&#xD;const App = () =&amp;gt; &amp;lt;Auth supabaseClient={supabase} /&amp;gt;&#xD;这将在没有任何样式的情况下渲染Auth组件。 我们建议使用预定义的主题之一来设置UI的样式。 导入要使用的主题并将其传递给appearence.theme属性。&#xA;import {&#xD;Auth,&#xD;// Import predefined theme&#xD;ThemeSupa,&#xD;} from &amp;#39;@supabase/auth-ui-react&amp;#39;&#xD;const App = () =&amp;gt; (&#xD;&amp;lt;Auth&#xD;supabaseClient={supabase}&#xD;{/* Apply predefined theme */}&#xD;appearance={{ theme: ThemeSupa }}&#xD;/&amp;gt;&#xD;)&#xD;自定义 link有几种自定义身份验证UI的方法：</description>
    </item>
    <item>
      <title>使用Next.js进行Supabase认证</title>
      <link>http://localhost:1313/docs/app/auth/auth-helpers/nextjs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth-helpers/nextjs/</guid>
      <description>该子模块为在Next中实现用户身份验证提供了方便的帮助Next.js应用程序。&#xA;安装Next.js助手库 link&amp;lt;Tabs scrollable size=&amp;ldquo;small&amp;rdquo; type=&amp;ldquo;underlined&amp;rdquo; defaultActiveId=&amp;ldquo;npm&amp;rdquo;&#xA;npm install @supabase/auth-helpers-nextjs&#xD;此库支持以下工具版本：&#xA;Node.js: ^10.13.0 || &amp;gt;=12.0.0 Next.js: &amp;gt;=10 注：Next.js13除了新的app目录方法外，其他都受支持。我们正在努力增加对此的支持，您可以关注此处. 此外，为可在所有基于React的框架中使用的组件和挂钩安装React Auth Helpers。&#xA;npm install @supabase/auth-helpers-react&#xD;yarn add @supabase/auth-helpers-nextjs&#xD;此库支持以下工具版本：&#xA;Node.js: ^10.13.0 || &amp;gt;=12.0.0 Next.js: &amp;gt;=10 注：Next.js13除了新的app目录方法外，其他都受支持。我们正在努力增加对此的支持，您可以关注此处. 此外，为可在所有基于React的框架中使用的组件和挂钩安装React Auth Helpers。&#xA;yarn add @supabase/auth-helpers-react&#xD;设置环境变量 link在项目的API设置中检索项目URL和匿名密钥以设置以下环境变量。对于本地开发，可以在.env.local文件。参见示例。&#xA;NEXT_PUBLIC_SUPABASE_URL=YOUR_SUPABASE_URL&#xD;NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY&#xD;基本设置 link&amp;lt;Tabs scrollable size=&amp;ldquo;small&amp;rdquo; type=&amp;ldquo;underlined&amp;rdquo; defaultActiveId=&amp;ldquo;js&amp;rdquo;&#xA;包装pages/_app.js组件与SessionContextProvider组件：&#xA;import { createBrowserSupabaseClient } from &amp;#39;@supabase/auth-helpers-nextjs&amp;#39;&#xD;import { SessionContextProvider } from &amp;#39;@supabase/auth-helpers-react&amp;#39;&#xD;function MyApp({ Component, pageProps }) {&#xD;const router = useRouter()&#xD;// Create a new supabase browser client on every first render.</description>
    </item>
    <item>
      <title>使用SveltKit进行Supabase认证</title>
      <link>http://localhost:1313/docs/app/auth/auth-helpers/sveltekit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth-helpers/sveltekit/</guid>
      <description>该子模块提供了在SvelteKit中实现用户身份验证的方便助手应用程序。&#xA;安装 link此库支持Node.js^16.15.0。&#xA;&amp;lt;Tabs scrollable size=&amp;ldquo;small&amp;rdquo; type=&amp;ldquo;underlined&amp;rdquo; defaultActiveId=&amp;ldquo;npm&amp;rdquo;&#xA;npm install @supabase/auth-helpers-sveltekit&#xD;yarn add @supabase/auth-helpers-sveltekit&#xD;入门 link配置 link设置填充环境变量。对于本地开发，您可以将其设置为.env文件。参见示例.&#xA;# Find these in your Supabase project settings &amp;gt; API&#xD;PUBLIC_SUPABASE_URL=https://your-project.supabase.co&#xD;PUBLIC_SUPABASE_ANON_KEY=your-anon-key&#xD;设置Suabase客户端 link首先创建一个db.ts文件，并实例化 supabaseClient。&#xA;import { createClient } from &amp;#39;@supabase/auth-helpers-sveltekit&amp;#39;&#xD;import { env } from &amp;#39;$env/dynamic/public&amp;#39;&#xD;// or use the static env&#xD;// import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY } from &amp;#39;$env/static/public&amp;#39;;&#xD;export const supabaseClient = createClient(env.PUBLIC_SUPABASE_URL, env.PUBLIC_SUPABASE_ANON_KEY)&#xD;要确保在服务器和客户端上初始化了客户端，请在src/hooks.server.js中包含此文件。js和src/hooks.client.js`：&#xA;import &amp;#39;$lib/db&amp;#39;&#xD;同步页面存储 link编辑+layout.svelte文件并设置客户端。&#xA;&amp;lt;script&amp;gt;&#xD;import { supabaseClient } from &amp;#39;$lib/db&amp;#39;&#xD;import { invalidate } from &amp;#39;$app/navigation&amp;#39;&#xD;import { onMount } from &amp;#39;svelte&amp;#39;&#xD;onMount(() =&amp;gt; {&#xD;const {&#xD;data: { subscription },&#xD;} = supabaseClient.</description>
    </item>
    <item>
      <title>Supabase Remix认证</title>
      <link>http://localhost:1313/docs/app/auth/auth-helpers/remix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth-helpers/remix/</guid>
      <description>该子模块为在Remix应用程序中实现用户身份验证提供了方便的帮助。&#xA;安装Remix助手库 link&amp;lt;Tabs scrollable size=&amp;ldquo;small&amp;rdquo; type=&amp;ldquo;underlined&amp;rdquo; defaultActiveId=&amp;ldquo;npm&amp;rdquo;&#xA;npm install @supabase/auth-helpers-remix&#xD;此库支持以下工具版本：&#xA;Remix: &amp;gt;=1.7.2 yarn add @supabase/auth-helpers-remix&#xD;此库支持以下工具版本：&#xA;Remix: &amp;gt;=1.7.2 设置环境变量 link在项目的API设置中检索项目URL和匿名密钥以设置以下环境变量。对于本地开发，您可以将其设置为.env文件。参见示例.&#xA;SUPABASE_URL=YOUR_SUPABASE_URL&#xD;SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY&#xD;加载器 link&amp;lt;Tabs scrollable size=&amp;ldquo;small&amp;rdquo; type=&amp;ldquo;underlined&amp;rdquo; defaultActiveId=&amp;ldquo;js&amp;rdquo;&#xA;加载器函数在组件呈现之前立即在服务器上运行。它们响应路由上的所有GET请求。您可以通过调用 createServerClient函数并将SUPABASE_URL、SUPABASE_ANON_KEY以及请求和响应传递给它，来创建经过身份验证的超级数据库客户端。&#xA;import { json } from &amp;#39;@remix-run/node&amp;#39; // change this import to whatever runtime you are using&#xD;import { createServerClient } from &amp;#39;@supabase/auth-helpers-remix&amp;#39;&#xD;export const loader = async ({ request }) =&amp;gt; {&#xD;const response = new Response()&#xD;// an empty response is required for the auth helpers&#xD;// to set cookies to manage auth&#xD;const supabaseClient = createServerClient(&#xD;process.</description>
    </item>
    <item>
      <title>第一部分:JWTS</title>
      <link>http://localhost:1313/docs/app/auth/auth-deep-dive/auth-deep-dive-jwts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth-deep-dive/auth-deep-dive-jwts/</guid>
      <description>关于 link对JWTs的介绍以及它们在Supabase Auth中的使用方法&#xA;观察 link&#xD;什么是JSON网络令牌（JWTs）？ linkJWT是JSON对象，经过编码和签名，以字符串的形式发送。它们被分发给服务或网站的用户，用户随后可以向网站或服务展示JWT，作为他们有权访问某些内容的证明。&#xA;当我们说 编码和 签名时，到底是什么意思？&#xA;JSON对象开始时看起来像这样。&#xA;{&#xD;&amp;#34;sub&amp;#34;: &amp;#34;0001&amp;#34;,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Sam Vimes&amp;#34;,&#xD;&amp;#34;iat&amp;#34;: 1516239022,&#xD;&amp;#34;exp&amp;#34;: 1518239022&#xD;}&#xD;sub是 主题，通常是用户的UUID。name是不言自明的，iat是创建令牌的Unix时间戳。许多JWT也会有一个exp，这是该令牌被设定为过期而不能再使用的日期。这些是你可能在JWT中发现的一些标准字段，但你几乎可以在其中存储任何你想要的东西，例如。&#xA;{&#xD;&amp;#34;sub&amp;#34;: &amp;#34;0002&amp;#34;,&#xD;&amp;#34;name&amp;#34;: &amp;#34;Věra Hrabánková&amp;#34;,&#xD;&amp;#34;iat&amp;#34;: 1516239022,&#xD;&amp;#34;exp&amp;#34;: 1518239022,&#xD;&amp;#34;theme&amp;#34;: {&#xD;&amp;#34;primary&amp;#34; : &amp;#34;#D80C14&amp;#34;,&#xD;&amp;#34;secondary&amp;#34; : &amp;#34;#FFFFFF&amp;#34;&#xD;}&#xD;}&#xD;只需注意，你在令牌中存储的数据越多，编码后的字符串就越长。&#xA;当我们想把JWT发送给用户时，我们首先用一种算法对数据进行编码，如HS256。有许多库（和几种不同的算法）可以用来做这种编码/解码，例如jsonwebtoken。我做了一个副本这里，所以你可以自己试试。签名的方法很简单。&#xA;// from https://replit.com/@awalias/jsonwebtokens#index.js&#xD;let token = jwt.sign({ name: &amp;#39;Sam Vimes&amp;#39; }, &amp;#39;some-secret&amp;#39;)&#xD;而产生的字符串将看起来像这样。&#xA;eyJhbGciOiJIUzI1NiJ9&#xD;.eyJzdWIiOiIwMDAxIiwibmFtZSI6IlNhbSBWaW1lcyIsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjoxNTE4MjM5MDIyfQ&#xD;.zMcHjKlkGhuVsiPIkyAkB2rjXzyzJsMMgpvEGvGtjvA&#xD;你会注意到，这个字符串实际上是由三个部分组成的，我们将逐一解决这个问题。&#xA;第一段eyJhbGciOiJIUzI1NiJ9被称为 头，在解码时只是告诉我们用哪种算法来做编码。&#xA;{&#xD;&amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;&#xD;}&#xD;第二段eyJzdWIiOiIwMDAxIiwibmFtZSI6IlNhbSBWaW1lcyIsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjoxNTE4MjM5MDIyfQ包含我们的原始有效载荷。</description>
    </item>
    <item>
      <title>第二部分:行级安全</title>
      <link>http://localhost:1313/docs/app/auth/auth-deep-dive/auth-row-level-security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth-deep-dive/auth-row-level-security/</guid>
      <description>关于 link了解如何通过启用行级安全和在Supabase仪表板中编写Postgres策略来限制对数据库表的访问。&#xA;观察 link&#xD;确保你的数据表安全 link在Supabase中，你可以直接从客户端（通常是网络浏览器）访问你的数据，你可以这样做，把你的Supabase URL和Anon密钥传递给supabase-js：&#xA;const supabase = createClient(&#xD;&amp;#39;https://qwertyuiop.supabase.co&amp;#39;,&#xD;&amp;#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c&amp;#39;&#xD;)&#xD;然而，这引起了一个有趣的问题：&amp;ldquo;如果我的匿名密钥在客户端，那么就不会有人阅读我的javascript并窃取我的密钥吗？&amp;quot;，答案是肯定的。而这正是Postgres策略的作用所在。&#xA;使用Postgres的 行级安全策略，我们可以对匿名钥匙默认允许或不允许访问的数据设置规则。&#xA;例如，我们可以说匿名钥匙只能从一个特定的表中读取，但不能写入、更新或删除。&#xA;而且这些规则可以随我们的意愿而复杂。我们可以说，匿名键只能删除在星期四下午4点到6点之间插入的行，并且id列是偶数。很奇怪，但它显示了策略的力量。&#xA;比方说，我们创建了一个排行榜表。我们希望网站上的人能够阅读排行榜，但不能写入、更新或删除它。我们首先在SQL中定义我们的表并添加一些假数据：&#xA;create table leaderboard (&#xD;name text,&#xD;score int&#xD;);&#xD;insert into leaderboard(name, score)&#xD;values (&amp;#39;Paul&amp;#39;, 100), (&amp;#39;Leto&amp;#39;, 50), (&amp;#39;Chani&amp;#39;, 200);&#xD;现在让我们设置一个客户端来读取数据，我在这里创建了一个副本来展示一个活生生的例子。https://replit.com/@awalias/supabase-leaderboard-demo#index.js。如果你复制这个片段，你可以插入你自己的Supabase URL和anon key。&#xA;你可以看到，通过使用，可以自由地从表中读取和写入。&#xA;// Writing&#xD;let { data, error } = await supabase.from(&amp;#39;leaderboard&amp;#39;).insert({ name: &amp;#39;Bob&amp;#39;, score: 99999 })&#xD;// Reading&#xD;let { data, error } = await supabase&#xD;.from(&amp;#39;leaderboard&amp;#39;)&#xD;.</description>
    </item>
    <item>
      <title>第三部分:政策</title>
      <link>http://localhost:1313/docs/app/auth/auth-deep-dive/auth-policies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth-deep-dive/auth-policies/</guid>
      <description>关于 link如何将表的访问限制在认证用户、行级策略和基于电子邮件域的访问。&#xA;观察 link&#xD;基于用户的行级策略 link现在我们知道了如何根据JWT角色来限制对表的访问，我们可以把它和用户管理结合起来，让我们更多地控制你的用户可以从你的数据库中读取和写入哪些数据。&#xA;我们将从用户会话在Supabase中的工作方式开始，然后转到编写以用户为中心的策略。&#xA;比方说，我们要把一个用户第一次注册到我们的服务中。典型的方法是在supabase-js中调用以下方法：&#xA;// see full api reference here: /docs/reference/javascript/auth-signup&#xD;supabase.auth.signUp({ email, password })&#xD;默认情况下，这将向用户发送一封确认电子邮件。当用户点击电子邮件中的链接时，他们将被重定向到你的网站（你需要在仪表板上的授权&amp;gt;设置中提供你的网站网址。默认情况下，这是http://localhost:3000），包括查询参数的完整URL将看起来像这样:&#xA;http://localhost:3000/#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjE2NDI5MDY0LCJzdWIiOiI1YTQzNjVlNy03YzdkLTRlYWYtYThlZS05ZWM5NDMyOTE3Y2EiLCJlbWFpbCI6ImFudEBzdXBhYmFzZS5pbyIsImFwcF9tZXRhZGF0YSI6eyJwcm92aWRlciI6ImVtYWlsIn0sInVzZXJfbWV0YWRhdGEiOnt9LCJyb2xlIjoiYXV0aGVudGljYXRlZCJ9.4IFzn4eymqUNYYo2AHLxNRL8m08G93Qcg3_fblGqDjo&amp;amp;expires_in=3600&amp;amp;refresh_token=RuioJv2eLV05lgH5AlJwTw&amp;amp;token_type=bearer&amp;amp;type=signup&#xD;让我们把这个问题拆开，以便更容易阅读。&#xA;// 基本网址 - 你在app.supabase.com仪表板的授权设置中设置的任何网址&#xD;http://localhost:3000/&#xD;// 注意我们使用&amp;#39;#&amp;#39;（片段）而不是&amp;#39;?&amp;#39;查询参数&#xD;// 访问令牌是发给用户的JWT。&#xD;#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjE2NDI5MDY0LCJzdWIiOiI1YTQzNjVlNy03YzdkLTRlYWYtYThlZS05ZWM5NDMyOTE3Y2EiLCJlbWFpbCI6ImFudEBzdXBhYmFzZS5pbyIsImFwcF9tZXRhZGF0YSI6eyJwcm92aWRlciI6ImVtYWlsIn0sInVzZXJfbWV0YWRhdGEiOnt9LCJyb2xlIjoiYXV0aGVudGljYXRlZCJ9.4IFzn4eymqUNYYo2AHLxNRL8m08G93Qcg3_fblGqDjo&#xD;// 默认情况下，60分钟内有效&#xD;&amp;amp;expires_in=3600&#xD;// 用来在60分钟到期前获得新的访问令牌&#xD;&amp;amp;refresh_token=RuioJv2eLV05lgH5AlJwTw&#xD;// 可以作为授权:在对你的API的请求中使用Bearer header&#xD;&amp;amp;token_type=bearer&#xD;// 这是一个注册、登录、密码重置或magic link?&#xD;&amp;amp;type=signup&#xD;如果我们把access_token放入https://jwt.io，我们会看到它被解码为:&#xA;{&#xD;&amp;#34;aud&amp;#34;: &amp;#34;authenticated&amp;#34;,&#xD;&amp;#34;exp&amp;#34;: 1616429064,&#xD;&amp;#34;sub&amp;#34;: &amp;#34;5a4365e7-7c7d-4eaf-a8ee-9ec9432917ca&amp;#34;,&#xD;&amp;#34;email&amp;#34;: &amp;#34;ant@supabase.io&amp;#34;,&#xD;&amp;#34;app_metadata&amp;#34;: {&#xD;&amp;#34;provider&amp;#34;: &amp;#34;email&amp;#34;&#xD;},&#xD;&amp;#34;user_metadata&amp;#34;: {},&#xD;&amp;#34;role&amp;#34;: &amp;#34;authenticated&amp;#34;&#xD;}&#xD;authenticated角色在Supabase中很特别，它告诉API这是一个已认证的用户，并知道将JWT与你添加到请求的资源（表或行）的任何策略进行比较。&#xA;sub声称通常是我们用来将JWT与你数据库中的行相匹配的，因为默认情况下它是auth.users表中用户的唯一标识符（作为附带说明&amp;ndash;一般不建议以任何方式改变你Supabase数据库中的auth模式，因为Auth API依靠它来正常运行）。&#xA;对于好奇心强的人来说，可以尝试进入SQL编辑器并进行查询：</description>
    </item>
    <item>
      <title>第四部分: GoTrue</title>
      <link>http://localhost:1313/docs/app/auth/auth-deep-dive/auth-gotrue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/auth/auth-deep-dive/auth-gotrue/</guid>
      <description>关于 link如何将表的访问限制在认证用户、行级策略和基于电子邮件域的访问。&#xA;观察 link&#xD;Gotrue Server linkGotrue是一个由Netlify团队用Go编写的认证API服务器，在这里可以找到Supabase的分叉：https://github.com/supabase/gotrue 可用的API端点列表可在这里。&#xA;当你部署一个新的Supabase项目时，我们会在你的数据库旁边部署一个新的服务器实例，同时也为你的数据库注入所需的auth模式。&#xA;这使得它非常容易，例如，发送神奇的链接电子邮件，你的用户可以用它来登录:&#xA;# replace &amp;lt;project-ref&amp;gt; with your own project reference&#xD;# and SUPABASE_KEY with your anon api key&#xD;curl -X POST &amp;#39;https://&amp;lt;project-ref&amp;gt;.supabase.co/auth/v1/magiclink&amp;#39; \&#xD;-H &amp;#34;apikey: SUPABASE_KEY&amp;#34; \&#xD;-H &amp;#34;Content-Type: application/json&amp;#34; \&#xD;-d &amp;#39;{&#xD;&amp;#34;email&amp;#34;: &amp;#34;someone@email.com&amp;#34;&#xD;}&amp;#39;&#xD;Gotrue负责为你的用户发放访问令牌，发送确认邮件、魔法链接和密码恢复邮件（默认情况下，我们从Supabase的SMTP服务器发送这些邮件，但你可以在仪表板的Auth &amp;gt; Settings中轻松插入你自己的邮件），也可以与第三方OAuth提供商进行交易，获得基本的用户数据。&#xA;如果你的用户需要与供应商进行更密切的互动，社区最近甚至还内置了请求自定义OAuth范围的功能。请看这里的scopes参数。https://github.com/supabase/gotrue#get-authorize。&#xA;因此，假设你想通过gmail代表用户发送电子邮件，你可能会请求gmail.send范围，把他们引导到：&#xA;https://sjvwsaokcugktsdaxxze.supabase.co/auth/v1/authorize?provider=google&amp;amp;https://www.googleapis.com/auth/gmail.send&#xD;当然，你必须确保你的谷歌应用经过验证，以便申请这些高级范围。&#xA;Gotrue-js (还有 gotrue-csharp, gotrue-py, gotrue-kt, 和 gotrue-dart) 都是对Getrue API端点的封装，使你的客户端更容易进行会话管理。&#xA;但是gotrue-js的所有功能在supabase-js中也是可用的，当你做一些事情时，supabase-js在内部使用gotrue-js。&#xA;const { user, session, error } = await supabase.auth.signIn({&#xD;email: &amp;#39;example@email.</description>
    </item>
    <item>
      <title>概述</title>
      <link>http://localhost:1313/docs/app/database/database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/database/</guid>
      <description>数据库 link每个Supabase项目都带有一个完整的Postgres数据库，这是一个免费的开源数据库，被认为是世界上最稳定的和先进的数据库之一。&#xA;Postgres 或 PostgreSQL? linkPostgreSQL数据库来自于POSTGRES项目，这是一个1986年在加州大学伯克利分校编写的软件包。 这个软件包包括一种叫做 &amp;ldquo;PostQUEL &amp;ldquo;的查询语言。&#xA;1994年，Postgres95建立在POSTGRES代码之上，增加了一个SQL语言解释器作为PostQUEL的替代。 最终，Postgres95被重新命名为PostgreSQL，以反映SQL查询能力。&#xA;在这之后，许多人把它称为Postgres，因为这样不容易混淆。Supabase的宗旨是简单，所以我们也把它称为Postgres。&#xA;功能 link表视图 link你不必是一个数据库专家就可以开始使用Supabase。我们的表视图使Postgres像电子表格一样容易使用。&#xA;关系 link挖掘你的数据中的关系.&#xA;克隆表 link你可以复制你的表格，就像你在电子表格里面一样。&#xA;SQL编辑器 linkSupabase自带一个SQL编辑器。你还可以保存你最喜欢的查询，以便以后运行!&#xA;附加功能 link Supabase使用我们的Realtime Server对Postgres进行实时功能的扩展。 每个项目都是一个完整的Postgres数据库，具有postgres级别的访问权限。 Supabase负责管理你的数据库备份。 直接从CSV或EXCEL电子表格中导入数据。 info&#xD;数据库备份不包括通过存储API存储的对象，因为数据库只包括关于这些对象的元数据。恢复一个旧的备份并不能恢复在那之后被删除的对象。&#xA;扩展 link为了扩展你的Postgres数据库的功能，你可以使用扩展。 你可以通过点击Supabase仪表板上的一个按钮来启用Postgres扩展。&#xA;了解更多关于Supabase上提供的所有扩展。&#xA;提示 link阅读关于重设数据库密码这里和改变服务器时区这里。&#xA;下一步 link 阅读更多关于Postgres 登录: MemFire Cloud </description>
    </item>
    <item>
      <title>全文搜索</title>
      <link>http://localhost:1313/docs/app/database/full-text-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/full-text-search/</guid>
      <description>Postgres有内置的功能来处理 全文搜索查询。这就像Postgres中的一个 搜索引擎。&#xA;准备工作 link在本指南中，我们将使用以下示例数据：&#xA;Data&#xD;SQL&#xD;id title author description 1 The Poky Little Puppy Janette Sebring Lowrey Puppy is slower than other, bigger animals. 2 The Tale of Peter Rabbit Beatrix Potter Rabbit eats some vegetables. 3 Tootle Gertrude Crampton Little toy train has big dreams. 4 Green Eggs and Ham Dr. Seuss Sam has changing food preferences and eats unusually colored food. 5 Harry Potter and the Goblet of Fire J.</description>
    </item>
    <item>
      <title>数据库连接</title>
      <link>http://localhost:1313/docs/app/database/connecting-to-postgres/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/connecting-to-postgres/</guid>
      <description>MemFire Cloud 提供了几种连接Postgres数据库的方式:&#xA;直接连接：使用Postgres标准连接系统直接与数据库进行连接和交互。 无服务器API连接：使用无服务器API以编程方式来访问数据库。 直接连接 link每个MemFire Cloud 应用内置一个完整的Postgres数据库，你可以使用任何支持Postgres的工具来连接到数据库。你可以在控制台内的数据库设置中获取连接信息：&#xA;来到左侧菜单栏的 设置部分 点击数据库 启用数据库直连 找到应用的连接信息 白名单 linkMemFire Cloud内置白名单功能，开启白名单后，只允许白名单内的IP地址段访问你的数据库。关闭白名单后，访问你数据库的IP地址不受限制，即任何IP地址只要有连接信息都可以与你的数据库进行直连。 在进行白名单配置时，要遵循CIDR规则。MemFire Cloud中白名单功能 默认是关闭的，需用户手动开启。&#xA;无服务器API连接 linkMemFire Cloud 提供了自动更新API，极大简化了操作数据库中数据的步骤（包括数据查询、插入、更新等等）。同时我们也提供了一些不同类型的API来满足你的业务需求。&#xA;REST：通过REST接口与你的数据库进行交互。 GraphQL：通过GraphQL接口与你的数据库互动。 Realtime：通过websockets监听数据库变化。 案例教程 link案例1 使用Navicat连接 linkNavicat是一个用于管理Postgres数据库的图形用户界面（GUI）工具。你可以使用它连接到你的数据库：&#xA;步骤1 link新建一个连接，选择:PostgreSQL 步骤2 link在你的MemFire Cloud控制台中找到“连接信息”，并添加此处。点击“测试连接”，若返回成功弹窗则表明连接建立成功。 连接成功后即可管理和查询你的数据。 案例2 使用python连接 link配置：本例中选用pycharm编辑器，python3.8版本。&#xA;步骤1 link在 MemFire Cloud 控制台中启用数据库直连，找到python的“连接字符串”。 步骤2 link在pycharm编辑器中，导入第三方库 psycopg2，psycopg2是一个流行的Python库，用于连接和操作PostgreSQL数据库。如果尚未安装此库，请通过以下命令进行安装：&#xA;pip install psycopg2&#xD;或者在pycharm的 Python Interpreter中进行设置，步骤如下：&#xA;步骤3 link完成psycopg2的安装后，将连接字符串中的[YOUR-PASSWORD]替换为数据库的实际密码。[YOUR-HOST]替换为数据库的主机地址。 [USER-NAME]替换为你的用户名。端口号默认为：10010，数据库名称默认为：postgres。建立与MemFire Cloud应用数据库连接，然后对数据库进行操作。&#xA;代码如下：&#xA;import psycopg2&#xD;# 定义连接字符串&#xD;connection_string = &amp;#34;user=[USER-NAME] password=[YOUR-PASSWORD] host=[YOUR-HOST] port=5432 dbname=postgres&amp;#34;&#xD;try:&#xD;# 连接到数据库&#xD;connection = psycopg2.</description>
    </item>
    <item>
      <title>关联查询</title>
      <link>http://localhost:1313/docs/app/database/associated-query/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/associated-query/</guid>
      <description>多表关联是指在关系型数据库中，通过多个数据表之间的字段关联，实现数据的联合查询和统计分析。使用场景包括：复杂的数据统计分析、跨部门的数据共享和协作、多维度的数据查询和分析等。一般情况下，需要设计合适的数据模型和关联规则来确保查询效率和数据准确性。其中包括：&#xA;过滤查询：eq 自定义字段查询 查询所有关联数据 条件过滤查询：filter 通过内关联/左关联查询 连接运算符：or 连接运算符：or &amp;amp; and 数据排序：order 过滤数据的条数： count 限制返回的行数： limit 本教程是通过数据表：学生课表信息表、课程信息表、学校信息表，三者之间存在的关联关系的示例来讲解如何通过JavaScript SDK的API进行多表关联查询数据的教程。&#xA;准备工作，创建数据表 link创建subject表 linksubject表主要记录课程信息，表结构字段如下： 名称 类型 描述 id int8 主键，自增，唯一标识ID teacherName text 老师 adress text 上课地点 subjectName text 科目 updated_at timeatamptz 修改时间 CREATE TABLE &amp;#34;public&amp;#34;.&amp;#34;subject&amp;#34; ( &amp;#34;id&amp;#34; BIGINT NOT NULL,&#xD;&amp;#34;teacherName&amp;#34; TEXT NOT NULL,&#xD;&amp;#34;updated_at&amp;#34; TIMESTAMP WITH TIME ZONE NOT NULL,&#xD;&amp;#34;adress&amp;#34; TEXT NOT NULL,&#xD;&amp;#34;subjectName&amp;#34; TEXT NOT NULL,&#xD;CONSTRAINT &amp;#34;subject_pkey&amp;#34; PRIMARY KEY (&amp;#34;id&amp;#34;)&#xD;);&#xD;INSERT INTO &amp;#34;public&amp;#34;.</description>
    </item>
    <item>
      <title>数据库函数</title>
      <link>http://localhost:1313/docs/app/database/functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/functions/</guid>
      <description>Postgres内置了对SQL函数的支持。 这些函数存在于你的数据库中，它们可以与API一起使用。&#xA;快速演示 link&#xD;开始使用 linkSupabase 为创建数据库函数提供了几个选项。你可以使用仪表板或直接使用 SQL 创建它们。 我们在 Dashboard 中提供了一个 SQL 编辑器，或者你可以 连接 到数据库并自己运行SQL查询。&#xA;进入 SQL编辑器栏。 点击 新查询。 输入创建或替换数据库功函数的SQL。 点击 运行或cmd+enter (ctrl+enter)。 简单的函数 link让我们创建一个基本的数据库函数，返回一个字符串 hello world.&#xA;create or replace function hello_world() -- 1&#xD;returns text -- 2&#xD;language sql -- 3&#xD;as $$ -- 4&#xD;select &amp;#39;hello world&amp;#39;; -- 5&#xD;$$; --6&#xD;显示/隐藏细节&#xD;最基本的是，一个函数有以下部分：&#xA;create or replace function hello_world()。函数声明，其中hello_world是函数的名称。你可以在创建一个新的函数时使用create，或者在替换一个现有函数时使用replace。或者你可以同时使用create或replace来处理这两种情况。 returns text: 函数返回的数据类型。如果它什么都不返回，你可以returns void。 language sql&#39;: 在函数主体中使用的语言。这也可以是一种程序性语言：plpgsql, plv8, plpython`等。 as $$: 函数包装器。任何包含在$$符号中的东西都将是函数主体的一部分。 select &#39;hello world&#39;;: 一个简单的函数体。如果函数体中的最后一条select语句后面没有语句，将被返回。 $$;: 函数封装器的结束符号。 函数创建后，我们有几种 &amp;ldquo;执行 &amp;ldquo;函数的方法&amp;ndash;可以直接在数据库中使用SQL，也可以使用其中一个客户端库。</description>
    </item>
    <item>
      <title>表格和数据</title>
      <link>http://localhost:1313/docs/app/database/tables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/tables/</guid>
      <description>表是存储数据的地方。&#xA;表格类似于Excel电子表格。它们包含列和行。 例如，这个表有3列（id, name, description）和4行的数据： id name description 1 The Phantom Menace Two Jedi escape a hostile blockade to find allies and come across a young boy who may bring balance to the Force. 2 Attack of the Clones Ten years after the invasion of Naboo, the Galactic Republic is facing a Separatist movement. 3 Revenge of the Sith As Obi-Wan pursues a new threat, Anakin acts as a double agent between the Jedi Council and Palpatine and is lured into a sinister plan to rule the galaxy.</description>
    </item>
    <item>
      <title>数据库 Webhooks</title>
      <link>http://localhost:1313/docs/app/database/webhooks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/webhooks/</guid>
      <description>数据库 Webhooks 允许您在数据库发生表事件时将实时数据发送到另一个系统。&#xA;你可以绑定三个事件: 插入、更新、 和 删除。 所有事件在数据库行更改后触发。&#xA;数据库 Webhooks 非常类似于触发器，因为数据库Webhooks使用了pg_net 扩展，这使得它看上去更像是对触发器的便捷地封装。这个扩展是异步的，因此不会阻塞数据库更改以进行长时间运行的网络请求。&#xA;该视频演示了每次向profiles表插入一行时，如何在Stripe中创建一个新客户：&#xA;info&#xD;数据库 Webhooks 以前叫做函数 Hooks。&#xA;创建 webhook link 在控制台新建一个数据库 Webhook。 给新建的 Webhook 命名。 选择一个你想绑定的数据表。 选择一个或多个您想要连接到的事件(表的插入、更新、删除) 。 我们目前支持 HTTP webhooks。它们以带有 JSON 载荷的 POST 请求的形式发送。&#xA;载荷 link载荷是从底层表记录自动生成的:&#xA;type InsertPayload = {&#xD;type: &amp;#39;INSERT&amp;#39;&#xD;table: string&#xD;schema: string&#xD;record: TableRecord&amp;lt;T&amp;gt;&#xD;old_record: null&#xD;}&#xD;type UpdatePayload = {&#xD;type: &amp;#39;UPDATE&amp;#39;&#xD;table: string&#xD;schema: string&#xD;record: TableRecord&amp;lt;T&amp;gt;&#xD;old_record: TableRecord&amp;lt;T&amp;gt;&#xD;}&#xD;type DeletePayload = {&#xD;type: &amp;#39;DELETE&amp;#39;&#xD;table: string&#xD;schema: string&#xD;record: null&#xD;old_record: TableRecord&amp;lt;T&amp;gt;&#xD;}&#xD;资源 link pg_net: 用于 PostgreSQL 的异步网络扩展。 </description>
    </item>
    <item>
      <title>总览</title>
      <link>http://localhost:1313/docs/app/database/extensions/extensions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/extensions/extensions/</guid>
      <description>扩展和它们的名字一样 - 它们用不属于Postgres核心的功能来 &amp;ldquo;扩展 &amp;ldquo;数据库。 Supabase已经预装了一些最有用的开源扩展。&#xA;启用和停用扩展功能 link&#xD;Dashboard&#xD;SQL&#xD;进入仪表板中的数据库页面。 单击侧边栏中的扩展程序。 启用或停用一个扩展。 -- Example: enable the &amp;#34;pgtap&amp;#34; extension and ensure it is installed&#xD;create extension pgtap with schema extensions;&#xD;-- Example: disable the &amp;#34;pgtap&amp;#34; extension&#xD;drop extension pgtap;&#xD;尽管SQL代码是 create extension，但它相当于&amp;quot;启用该扩展&amp;quot;。要禁用一个扩展，请调用 drop extension。&#xA;info&#xD;使用 create extension &amp;lt;extension-name&amp;gt; with schema extensions 启用某些扩展功能可能会导致权限问题（例如：dblink，http，pg_cron）。&#xA;完整的扩展列表 linkSupabase预先配置了50多个扩展。你也可以通过SQL编辑器在数据库中直接安装所需的SQL扩展。</description>
    </item>
    <item>
      <title>http: RESTful客户端</title>
      <link>http://localhost:1313/docs/app/database/extensions/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/extensions/http/</guid>
      <description>http扩展允许你在Postgres中调用RESTful端点。&#xA;快速演示 link&#xD;概述 link让我们来介绍一些基本概念：&#xA;REST：是REpresentational State Transfer的缩写。它是一种从外部服务请求数据的简单方法。 RESTful APIs是接受HTTP &amp;ldquo;调用&amp;quot;的服务器。这些调用通常是： GET - 只读访问一个资源。 POST - 创建一个新的资源。 DELETE - 移除一个资源。 PUT - 更新一个现有的资源或创建一个新的资源。 你可以使用http扩展来从Postgres进行这些网络请求。&#xA;用法 link启用扩展功能 link&#xD;Dashboard&#xD;SQL&#xD;进入仪表板中的数据库页面。 点击侧边栏中的扩展。 搜索 &amp;ldquo;http &amp;ldquo;并启用该扩展。 -- Example: enable the &amp;#34;http&amp;#34; extension&#xD;create extension http with schema extensions;&#xD;-- Example: disable the &amp;#34;http&amp;#34; extension&#xD;drop extension if exists http;&#xD;尽管SQL代码是create extension，但这相当于 &amp;ldquo;启用扩展&amp;rdquo;。 要禁用一个扩展，请调用drop extension。&#xA;好的做法是在一个单独的模式（如 extensions）中创建扩展，以保持你的数据库干净。&#xA;可用的函数 link虽然主要用法是简单的http(&#39;http_request&#39;)，但有5个封装函数用于特定功能：&#xA;http_get() http_post() http_put() http_delete() http_head() 返回值 link从http扩展中成功调用一个网络URL，会返回一个包含以下字段的记录:</description>
    </item>
    <item>
      <title>pg_cron: 作业调度</title>
      <link>http://localhost:1313/docs/app/database/extensions/pgcron/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/extensions/pgcron/</guid>
      <description>pg_cron扩展是PostgreSQL的一个简单的基于cron的工作调度器，在数据库内运行。&#xA;使用方法 link启用扩展 link&#xD;Dashboard&#xD;SQL&#xD;进入仪表板中的数据库页面。 点击侧边栏中的扩展。 搜索 &amp;ldquo;pg_cron &amp;ldquo;并启用该扩展。 -- Example: enable the &amp;#34;pg_cron&amp;#34; extension&#xD;create extension pg_cron with schema extensions;&#xD;-- If you&amp;#39;re planning to use a non-superuser role to schedule jobs,&#xD;-- ensure that they are granted access to the cron schema and its underlying objects beforehand.&#xD;-- Failure to do so would result in jobs by these roles to not run at all.&#xD;grant usage on schema cron to {{DB user}};&#xD;grant all privileges on all tables in schema cron to {{DB user}};&#xD;-- Example: disable the &amp;#34;pg_cron&amp;#34; extension&#xD;drop extension if exists pg_cron;&#xD;语法 link该计划使用标准cron语法，其中* 表示“每个时间段运行”，而特定数字表示“但仅在此时”：</description>
    </item>
    <item>
      <title>pg_graphql: 为PostgreSQL提供GraphQL功能</title>
      <link>http://localhost:1313/docs/app/database/extensions/pg_graphql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/extensions/pg_graphql/</guid>
      <description>概念 linkpg_graphql 是一款用于 与数据库进行交互的 PostgreSQL 扩展，它使用的是 GraphQL 而非 SQL 。&#xA;该扩展通过现有的 SQL 模式反映出一个 GraphQL 模式，并通过一个 SQL 函数 graphql.resolve(...) 将其公开。这使得任何能够连接到 PostgreSQL 的编程语言都可以通过 GraphQL 查询数据库，而无需额外的服务器、进程或库。&#xA;pg_graphql 的解析方法被设计为与 PostgREST 相互操作，PostgREST 是支持 Supabase API 的工具，通过 RPC 调用 graphql.resolve 函数可以安全、高效地通过 HTTP/S 公开 GraphQL API。&#xA;有关如何将 SQL 模式反映到 GraphQL 模式的更多信息，请参阅 pg_graphql 的 API 文档。&#xA;使用方法 link启用扩展 link&#xD;控制台&#xD;SQL&#xD;跳转到控制台的 数据库 。 点击侧栏中的扩展。 搜索&amp;quot;pg_graphql&amp;quot;并启用扩展。 {/* prettier-ignore */}&#xA;-- Enable the &amp;#34;pg_graphql&amp;#34; extension&#xD;create extension pg_graphql;&#xD;-- Disable the &amp;#34;pg_graphql&amp;#34; extension&#xD;drop extension if exists pg_graphql;&#xD;尽管 SQL 代码是 create extension，但它的等效操作是“启用扩展”。 要禁用扩展，您可以调用 drop extension。</description>
    </item>
    <item>
      <title>pgvector: 嵌入向量和向量相似性</title>
      <link>http://localhost:1313/docs/app/database/extensions/pgvector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/extensions/pgvector/</guid>
      <description>pgvector 是一款用于向量相似性搜索的 PostgreSQL 扩展。它还可以用于存储 嵌入向量 。&#xA;了解更多关于 Supabase 的 AI &amp;amp; Vector 服务的信息。&#xA;概念 link向量相似性 link向量相似性是指衡量两个相关项之间相似程度的度量方式。例如，如果你有一组产品列表，你可以使用向量相似性来寻找相似的产品。为了实现这个目标，你需要使用数学模型将每个产品转换为由数字组成的&amp;quot;向量&amp;quot;。对于文本、图像和其他类型的数据，你可以使用类似的模型。一旦所有这些向量都存储在数据库中，你就可以使用向量相似性来查找相似的项。&#xA;使用方法 link启用扩展 link&#xD;控制台&#xD;SQL&#xD;跳转控制台的 数据库 页面。 点击侧栏中的 扩展 。 搜索 &amp;ldquo;vector&amp;rdquo; 并启用扩展。 -- Example: enable the &amp;#34;vector&amp;#34; extension.&#xD;create extension vector&#xD;with&#xD;schema extensions;&#xD;-- Example: disable the &amp;#34;vector&amp;#34; extension&#xD;drop&#xD;extension if exists vector;&#xD;尽管 SQL 代码是 create extension，但它的等效操作是“启用扩展”。 要禁用扩展，您可以调用 drop extension。&#xA;创建一个表来存储向量 link&#xD;create table posts (&#xD;id serial primary key,&#xD;title text not null,&#xD;body text not null,&#xD;embedding vector(1536)&#xD;);&#xD;存储一个向量 link在这个示例中，我们将使用OpenAI API客户端生成一个向量，然后使用Supabase客户端将其存储在数据库中。</description>
    </item>
    <item>
      <title>pg_net: 异步网络</title>
      <link>http://localhost:1313/docs/app/database/extensions/pgnet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/extensions/pgnet/</guid>
      <description>info&#xD;pg_net的API还处于beta阶段。函数签名可能会改变。&#xA;pg_net是一个PostgreSQL扩展，为异步网络暴露了一个SQL接口，重点是可扩展性和用户体验。&#xA;它与http扩展的不同之处在于，它默认是异步的。这使得它在阻塞函数（如触发器）中很有用。&#xA;用法 link启用扩展功能 link&#xD;Dashboard&#xD;SQL&#xD;进入仪表板中的数据库页面。 点击侧边栏中的扩展. 搜索 &amp;ldquo;pg_net &amp;ldquo;并启用该扩展。 -- Example: enable the &amp;#34;pg_net&amp;#34; extension&#xD;create schema if not exists net;&#xD;create extension pg_net with schema net;&#xD;-- Example: disable the &amp;#34;plv8&amp;#34; extension&#xD;drop extension if exists pg_net;&#xD;drop schema net;&#xD;尽管SQL代码是create extension，但这相当于 &amp;ldquo;启用扩展&amp;rdquo;。 要禁用一个扩展，请调用drop extension。&#xA;程序语言会自动安装在pg_catalog中，所以你不需要指定模式。&#xA;http_get link创建一个HTTP GET请求，返回该请求的ID。在事务提交之前，HTTP请求不会被启动。&#xA;签名 link&#xD;info&#xD;这是一个Postgres安全定义函数。&#xA;net.http_get(&#xD;-- url for the request&#xD;url text,&#xD;-- key/value pairs to be url encoded and appended to the `url`&#xD;params jsonb default &amp;#39;{}&amp;#39;::jsonb,&#xD;-- key/values to be included in request headers&#xD;headers jsonb default &amp;#39;{}&amp;#39;::jsonb,&#xD;-- WARNING: this is currently ignored, so there is no timeout&#xD;-- the maximum number of milliseconds the request may take before being cancelled&#xD;timeout_milliseconds int default 1000&#xD;)&#xD;-- request_id reference&#xD;returns bigint&#xD;strict&#xD;volatile&#xD;parallel safe&#xD;language plpgsql&#xD;使用方法 link&#xD;select net.</description>
    </item>
    <item>
      <title>pgTAP:单元测试</title>
      <link>http://localhost:1313/docs/app/database/extensions/pgtap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/extensions/pgtap/</guid>
      <description>pgTAP是PostgreSQL的一个单元测试扩展。&#xA;概述 link让我们来介绍一些基本的概念：&#xA;单元测试：允许你测试一个系统的小部分（如数据库表！）。 TAP：代表Test Anything Protocol。它是一个框架，旨在简化测试期间的错误报告。 使用方法 link启用扩展 link&#xD;Dashboard&#xD;SQL&#xD;进入仪表板中的数据库页面。 点击侧边栏中的扩展。 搜索 &amp;ldquo;pgtap &amp;ldquo;并启用该扩展。 -- Enable the &amp;#34;pgtap&amp;#34; extension&#xD;create extension pgtap with schema extensions;&#xD;-- Disable the &amp;#34;pgtap&amp;#34; extension&#xD;drop extension if exists pgtap;&#xD;尽管SQL代码是create extension，但这相当于 &amp;ldquo;启用扩展&amp;rdquo;。 要禁用一个扩展，请调用drop extension。&#xA;程序语言会自动安装在pg_catalog中，所以你不需要指定模式。&#xA;测试表 link&#xD;begin;&#xD;select plan( 1 );&#xD;select has_table( &amp;#39;profiles&amp;#39; );&#xD;select * from finish();&#xD;rollback;&#xD;API：&#xA;has_table()：测试数据库中是否存在一个表。 has_index(): 检查是否存在与命名表相关的命名索引。 has_relation(): 测试数据库中是否存在一个关系。 测试列 link&#xD;begin;&#xD;select plan( 2 );&#xD;select has_column( &amp;#39;profiles&amp;#39;, &amp;#39;id&amp;#39; ); # test that the &amp;#34;id&amp;#34; column exists in the &amp;#34;profiles&amp;#34; table&#xD;select col_is_pk( &amp;#39;profiles&amp;#39;, &amp;#39;id&amp;#39; ); # test that the &amp;#34;id&amp;#34; column is a primary key&#xD;select * from finish();&#xD;rollback;&#xD;API：</description>
    </item>
    <item>
      <title>plv8: JavaScript语言</title>
      <link>http://localhost:1313/docs/app/database/extensions/plv8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/extensions/plv8/</guid>
      <description>plv8扩展允许你在Postgres中使用JavaScript。&#xA;概述 link虽然Postgres原生运行SQL，但它也可以运行其他 &amp;ldquo;程序语言&amp;rdquo;。 plv8允许你运行JavaScript代码-特别是任何在V8 JavaScript引擎上运行的代码。&#xA;它可以用于数据库函数、触发器、查询等。&#xA;使用方法 link启用扩展 link&#xD;Dashboard&#xD;SQL&#xD;进入仪表板中的数据库页面。 点击侧边栏中的扩展。 搜索 &amp;ldquo;plv8 &amp;ldquo;并启用该扩展。 -- Example: enable the &amp;#34;plv8&amp;#34; extension&#xD;create extension plv8;&#xD;-- Example: disable the &amp;#34;plv8&amp;#34; extension&#xD;drop extension if exists plv8;&#xD;尽管SQL代码是create extension，但这相当于 &amp;ldquo;启用扩展&amp;rdquo;。 要禁用一个扩展，请调用drop extension。&#xA;程序语言会自动安装在pg_catalog中，所以你不需要指定模式。&#xA;创建plv8函数 link用plv8编写的函数和其他PostgreSQL函数一样，只是 语言标识符设置为plv8。&#xA;create or replace function function_name()&#xD;returns void as $$&#xD;// V8 JavaScript&#xD;// code&#xD;// here&#xD;$$ language plv8;&#xD;你可以像其他Postgres函数一样调用plv8函数：&#xA;SQL&#xD;JavaScript&#xD;select function_name();&#xD;const { data, error } = supabase.</description>
    </item>
    <item>
      <title>uuid-ossp: 唯一标识符</title>
      <link>http://localhost:1313/docs/app/database/extensions/uuid-ossp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/extensions/uuid-ossp/</guid>
      <description>uuid-ossp扩展可用于生成UID。&#xA;概述 linkUUID是一个 通用唯一标识符，在实际应用中，它是唯一的。 这使得它们特别适合作为主键。它有时也被称为 GUID，代表 全球唯一标识符。&#xA;使用方法 link启用扩展名 link&#xD;Dashboard&#xD;SQL&#xD;进入仪表板中的数据库页面。 点击侧边栏中的扩展。 搜索 uuid-ossp并启用该扩展。 Note: 目前 uuid-ossp扩展被默认启用，不能被禁用。&#xA;-- Example: enable the &amp;#34;uuid-ossp&amp;#34; extension&#xD;create extension &amp;#34;uuid-ossp&amp;#34; with schema extensions;&#xD;-- Example: disable the &amp;#34;uuid-ossp&amp;#34; extension&#xD;drop extension if exists &amp;#34;uuid-ossp&amp;#34;;&#xD;尽管SQL代码是create extension，但这相当于 &amp;ldquo;启用扩展&amp;rdquo;。 要禁用一个扩展，请调用drop extension。&#xA;程序语言会自动安装在pg_catalog中，所以你不需要指定模式。&#xA;Note: 目前 uuid-ossp扩展被默认启用，不能被禁用。&#xA;Uuid类型 link一旦扩展被启用，你现在可以访问一个uuid类型。&#xA;uuid_generate_v1() link根据计算机的MAC地址、当前时间戳和一个随机值的组合创建一个UUID值。&#xA;info&#xD;UUIDv1泄露了可识别的细节，这可能使它不适合于某些安全敏感的应用.&#xA;uuid_generate_v4() link创建完全基于随机数的UUID值。你也可以使用Postgres内置的gen_random_uuid()函数来生成一个UUIDv4。&#xA;示例 link在一个查询中 link&#xD;select uuid_generate_v4();&#xD;作为主键 link在表中自动创建唯一的随机ID：&#xA;create table contacts (&#xD;id uuid default uuid_generate_v4(),&#xD;first_name text,&#xD;last_name text,&#xD;primary key (id)&#xD;);&#xD;资源 link 选择一个Postgres主键 PostgreSQL UID数据类型的基础知识 </description>
    </item>
    <item>
      <title>超时</title>
      <link>http://localhost:1313/docs/app/database/setting/timeouts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/setting/timeouts/</guid>
      <description>默认情况下，Suabase将使用匿名密钥访问API的用户的最大语句执行时间限制为3秒，而经过身份验证的用户的最长语句执行时间为8秒。此外，所有用户的全局限制为2分钟。这可以防止由于查询写得不好或滥用而导致的资源耗尽。&#xA;改变默认超时 link这些超时值被选为大多数情况下的合理默认值，但可以使用alter role语句进行修改。&#xA;alter role authenticated set statement_timeout = &amp;#39;15s&amp;#39;;&#xD;你也可以更新一个会话的语句超时:&#xA;set statement_timeout to 60000; -- 1 minute in milliseconds&#xD;语句优化 link所有Supabase项目都安装了pg_stat_statements扩展，它跟踪所有针对它执行的语句的计划和执行统计数据。这些统计数据可以用来诊断你的项目的性能。&#xA;这些数据可以进一步与Postgres的explain功能结合使用，以优化你的使用。</description>
    </item>
    <item>
      <title>复制</title>
      <link>http://localhost:1313/docs/app/database/setting/replication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/setting/replication/</guid>
      <description>复制是一种将数据从一个数据库复制到另一个数据库的技术。Supabase使用复制功能来提供一个实时的API。复制在以下方面很有用：&#xA;分散 &amp;ldquo;负载&amp;rdquo;。例如，如果你的数据库有大量的读数，你可能想把它分成两个数据库。 减少延时。例如，您可能希望伦敦有一个数据库为您的欧洲客户服务，而纽约有一个为美国服务。 复制是通过发布来完成的，这是一种选择将哪些变化发送到其他系统（通常是另一个Postgres数据库）的方法。发布可以在仪表板中管理，也可以用SQL来管理。&#xA;在仪表板中管理发布 link 进入仪表板中的数据库页面。 点击侧边栏中的复制。 通过切换插入、更新和删除来控制哪些数据库事件被发送。 通过选择源和切换每个表来控制哪些表被发送变化。 创建一个发布 link这个发布包含对所有表格的修改&#xA;create publication publication_name&#xD;for all tables;&#xD;创建发布以侦听各个表 link&#xD;create publication publication_name&#xD;for table table_one, table_two;&#xD;添加表到现有发布中 link&#xD;alter publication publication_name&#xD;add table table_name;&#xD;监听插入操作 link&#xD;create publication publication_name&#xD;for all tables&#xD;with (publish = &amp;#39;insert&amp;#39;);&#xD;监听更新操作 link&#xD;create publication publication_name&#xD;for all tables&#xD;with (publish = &amp;#39;update&amp;#39;);&#xD;监听删除操作 link&#xD;create publication publication_name&#xD;for all tables&#xD;with (publish = &amp;#39;delete&amp;#39;);&#xD;删除一个发布 link&#xD;drop publication if exists publication_name;&#xD;重新创建发布 link如果要重新创建发布，最好在事务中执行，以确保操作成功。</description>
    </item>
    <item>
      <title>Passwords</title>
      <link>http://localhost:1313/docs/app/database/setting/managing-passwords/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/setting/managing-passwords/</guid>
      <description>你的PostgreSQL数据库是你的Supabase项目的核心，所以在任何时候都有一个强大、安全的密码是很很重要的。&#xA;如果你在你的postgres密码中使用了特殊符号，你必须记得在以后使用postgres连接字符串时对你的密码进行%-encode，例如：postgresql://postgres:p%3Dword@db.cvwawazfelidkloqmbma.supabase.co:5432/postgres。&#xA;改变你的项目密码 link当你创建你的项目时，你也被要求输入一个密码。这实际上是你的数据库的密码，特别是 &amp;ldquo;postgres&amp;quot;用户的密码。 你可以在Dashboard的数据库设置页面下更新它。&#xA;创建一个安全的密码 link安全地存储你的客户数据是绝对关键的。这里有一些创建安全密码的提示。&#xA;使用一个密码管理器来生成密码。 制作一个长密码（至少12个字符）。 不要使用任何常见的字典中的词汇。 同时使用大写和小写字符、数字和特殊符号。 资源库 link PostgreSQL ALTER USER文档 </description>
    </item>
    <item>
      <title>时区</title>
      <link>http://localhost:1313/docs/app/database/setting/managing-timezones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/database/setting/managing-timezones/</guid>
      <description>每个 Supabase 数据库都默认设置为 UTC 时区。我们强烈建议保持这种方式，即使你的用户在不同的地方。 这是因为，如果你采用 &amp;ldquo;我的数据库中的一切都在UTC时间 &amp;ldquo;的心理模式，那么计算不同时区的差异就会容易得多。&#xA;改变时区 link&#xD;SQL&#xD;alter database postgres&#xD;set timezone to &amp;#39;America/New_York&amp;#39;;&#xD;时区的完整列表 link获取你的数据库所支持的时区的完整列表。这将返回以下列：&#xA;name: 时区名称 abbrev: 时区缩略语 utc_offset: 与UTC的偏移（正数表示格林威治以东）。 is_dst: 如果目前遵守夏令时，则为真 SQL&#xD;select name, abbrev, utc_offset, is_dst&#xD;from pg_timezone_names()&#xD;order by name;&#xD;搜索一个特定的时区 link使用ilike（不区分大小写的搜索）来寻找特定的时区。&#xA;SQL&#xD;select *&#xD;from pg_timezone_names()&#xD;where name ilike &amp;#39;%york%&amp;#39;;&#xD;</description>
    </item>
    <item>
      <title>概述</title>
      <link>http://localhost:1313/docs/app/api/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/api/api/</guid>
      <description>无服务器 API linkSupabase直接从你的数据库模式中自动生成三种类型的API。&#xA;REST - 通过restful接口连接到你的数据库。 Realtime - 监听数据库的变化。 GraphQL - 使用类似于图形查询语言操作您的数据库。 所有的API都是从您的数据库中自动生成的，其设计目的是让您无需编写一行代码就能尽可能快地构建。&#xA;您可以直接从浏览器中使用它们（两层架构），或者作为您自己的API服务器（三层架构）的补充。&#xA;特征 link 即时自动生成当您更新数据库时，可以通过API立即访问更改。&#xA;自我记录Supabase在Dashboard中生成文档，当您更改数据库时，这些文档会更新。&#xA;安全API配置为与PostgreSQL的行级安全一起工作，在启用密钥验证的API网关后面提供。&#xA;速度快我们的基本读取基准比Firebase快300%以上。API是Postgres之上的一个非常薄的层，它完成了大部分繁重的工作。&#xA;可扩展API可以同时处理数千个请求，并且适用于无服务器工作负载。&#xA;REST API [#rest-api-overview] linkSupabase使用 PostgREST 提供了一个RESTful API。这是在 Postgres 之上的一个非常薄的API层。 它提供了你在 CRUD API 中需要的一切。&#xA;Supabase的REST接口会自动根据你的数据库模式进行反射，并提供以下功能支持：&#xA;基本的CRUD操作（创建/读取/更新/删除） 深度嵌套的连接，允许你在一次获取中从多个表中获取数据 可以与Postgres视图一起使用 可以与Postgres函数一起使用 可以与Postgres的安全模型一起使用（包括行级安全、角色和授权） Supabase的REST API将所有请求解析为单个SQL语句，从而实现快速的响应时间和高吞吐量。&#xA;参考:&#xA;相关文档 开源代码 GraphQL API [#graphql-api-overview] linkSupabase使用 pg_graphql 来在 https://&amp;lt;project_ref&amp;gt;.supabase.co/graphql/v1/ 上公开GraphQL API端点。 您可以在控制台中自动检索和查询现有 Supabase项目的 GraphQL API，或手动导航到 API 文档 &amp;gt; GraphQL &amp;gt; GraphiQL。&#xA;Supabase的GraphQL接口会自动根据你的数据库模式进行反射，并提供以下功能支持：&#xA;基本的CRUD操作（创建/读取/更新/删除） 支持表、视图、材料化视图和外部表 表/视图之间任意深度的关联关系 用户定义的计算字段 Postgres安全模型（包括行级安全、角色和授权） GraphQL API在单个往返中解析所有请求，因此响应时间快且吞吐量高。</description>
    </item>
    <item>
      <title>2 分钟构建 API 路由</title>
      <link>http://localhost:1313/docs/app/api/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/api/quickstart/</guid>
      <description>我们将创建一个名为 todos 的数据库表来存储任务。这将创建一个相应的 API 路由 /rest/v1/todos，该路由可以接收 GET， POST， PATCH， 和 DELETE 请求。&#xA;开始使用 link所有的API都是由数据库表自动创建的。在你向数据库添加了表或函数后，你可以使用所提供的API。&#xA;创建API路由 link当你创建Postgres表、视图或函数时，会自动创建API路由。&#xA;让我们通过创建一个叫做todos的表来存储任务，来创建我们的第一个API路由。 这将创建一个相应的路由todos，它可以接受GET、POST、PATCH和DELETE请求。&#xA;Dashboard&#xD;SQL&#xD;进入仪表板中的表编辑器页面。 点击新表，创建一个名为todos的表。 单击保存。 点击新列，创建一个名为task的列，类型为text。 单击保存。 -- Create a table called &amp;#34;todos&amp;#34; with a column to store tasks.&#xD;create table todos (&#xD;id bigint generated by default as identity primary key,&#xD;task text check (char_length(task) &amp;gt; 3)&#xD;);&#xD;API URL和密钥 link每个Supabase项目都有一个独特的API URL。您的 API 在 API 网关后面是安全的，每次请求都需要一个 API 密钥。&#xA;转到仪表板中的设置页面。 单击侧栏中的 API。 在这个页面上找到你的APIURL、anon和service_role键。 REST API和GraphQL API都可以通过这个URL访问:</description>
    </item>
    <item>
      <title>生成类型</title>
      <link>http://localhost:1313/docs/app/api/generating-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/api/generating-types/</guid>
      <description>SubaseAPI是从数据库生成的，这意味着我们可以使用数据库来生成类型安全的API定义。&#xA;使用Suabase CLI生成类型 linkSuabase CLI是一个二进制Go应用程序，它提供了设置本地开发环境所需的一切。&#xA;你可以通过npm或其他支持的软件包管理器安装CLI。CLI的最低要求版本是v1.8.1。&#xA;npm i supabase@&amp;#34;&amp;gt;=1.8.1&amp;#34; --save-dev&#xD;用你的个人访问令牌登录:&#xA;npx supabase login&#xD;为你的项目生成类型，产生types/supabase.ts文件:&#xA;npx supabase gen types typescript --project-id &amp;#34;$PROJECT_ID&amp;#34; --schema public &amp;gt; types/supabase.ts&#xD;在你生成了你的类型后，你可以在src/index.ts中使用它们.&#xA;import { NextApiRequest, NextApiResponse } from &amp;#39;next&amp;#39;&#xD;import { createClient } from &amp;#39;@supabase/supabase-js&amp;#39;&#xD;import { Database } from &amp;#39;../types/supabase&amp;#39;&#xD;const supabase = createClient&amp;lt;Database&amp;gt;(&#xD;process.env.NEXT_PUBLIC_SUPABASE_URL,&#xD;process.env.SUPABASE_SECRET_KEY&#xD;)&#xD;export default async (req: NextApiRequest, res: NextApiResponse) =&amp;gt; {&#xD;const allOnlineUsers = await supabase.from(&amp;#39;users&amp;#39;).select(&amp;#39;*&amp;#39;).eq(&amp;#39;status&amp;#39;, &amp;#39;ONLINE&amp;#39;)&#xD;res.status(200).json(allOnlineUsers)&#xD;}&#xD;用GitHub动作自动更新类型 link让你的类型定义与数据库保持同步的一个方法是设置一个GitHub动作，按计划运行。</description>
    </item>
    <item>
      <title>GraphQL 介绍</title>
      <link>http://localhost:1313/docs/app/api/graphiql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/api/graphiql/</guid>
      <description>每个 Supabase 项目都有一个 GraphQL 端点： https://&amp;lt;project_ref&amp;gt;.supabase.co/graphql/v1。&#xA;这个端点与任何能够传递 apikey 首部的 GraphiQL 实现兼容。 以下是一些建议的应用程序：&#xA;paw.cloud insomnia.rest postman.com/graphql 自托管的 GraphiQL：GraphiQL 可以通过一个简单的 HTML 文件进行提供。有关详细信息，请参阅此讨论 </description>
    </item>
    <item>
      <title>使用Postman访问数据</title>
      <link>http://localhost:1313/docs/app/api/postman/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/api/postman/</guid>
      <description>MemFire Cloud为所有的数据表提供自动即时的API，我们可以通过Postman工具调用API来访问云数据库中数据表的数据。&#xA;前置条件 link① 注册MemFire Cloud账号；&#xA;② 存在已创建好的应用；&#xA;操作步骤 link1.创建数据表，插入数据 link在我的应用管理页面，点击具体应用，进入应用详情页面，点击左侧菜单栏“SQL执行器”，创建新查询，执行如下SQL命令。&#xA;SQL语法如下：&#xA;CREATE TABLE employees (&#xD;employee_no integer PRIMARY KEY,&#xD;name text UNIQUE,&#xD;department text NOT NULL&#xD;);&#xD;INSERT INTO employees VALUES (1, &amp;#39;lining&amp;#39;, &amp;#39;Marketing&amp;#39;),&#xD;(2, &amp;#39;lisan&amp;#39;, &amp;#39;Sales&amp;#39;),&#xD;(3, &amp;#39;zhangqi&amp;#39;, &amp;#39;Operations&amp;#39;); 2.使用API文档 link点击左侧菜单栏“API文档”，在“表和视图”里，选中所有数据表中的“employees”，右侧点击&amp;quot;Bash&amp;quot;栏，应用API key选择“anon(public)”, 则可以查看该数据表的专属API接口文档。&#xA;3.访问数据 link接下来读取该数据表“employees&amp;quot;中所有的行。&#xA;1.首先，我们在拖动文档滚动条，找到该操作的命令，如下图所示。我们可以直接获取到命令的URL信息、apikey和Authorization。&#xA;2.打开Postman工具，新建一个请求窗口，复制url并将其粘贴到请求里，请求方式选择GET，查询参数是“*”（查询全部）。配置请求Headers,将apikey和Authorization配置到请求头里面。完成配置后，点击“Send”按钮，即可获得返回结果。&#xA;4.插入数据 link接下来插入数据到数据表“employees&amp;quot;中。&#xA;1.首先，拖动文档滚动条，找到插入数据的API命令，如下图所示。可以获取到命令的URL信息、apikey和Authorization。&#xA;在Postman工具，新建一个请求窗口，请求方式选择POST，复制url并将其粘贴到请求里，配置Headers。同时在Body里面配置需要插入的数据。 3.点击“Send”按钮，返回状态码201，插入数据操作成功。&#xA;4.执行第3小节访问数据操作，即可看到新插入的数据。&#xA;5.设置RLS, 访问数据 link数据表里的RLS默认是不开启的，此时注册应用的用户是可以增删改查数据表中任何数据。接下来展示如何采用RLS来设置表的访问权限，允许经过身份验证的用户来访问数据表。&#xA;1.在用户认证-&amp;gt;策略页面，选中数据表“employees&amp;quot;，点击“启用RLS”按钮后，即可开启该数据库的RLS规则。允许经过身份验证的用户进行数据插入访问数据表。&#xA;2.接下来，给表设置访问规则，只允许经过身份验证的用户才能去插入数据。这只是其中一种规则，具体规则还得根据大家的业务需求规定。&#xA;（1）只允许经过身份验证的用户才能去插入数据。&#xA;（2）允许所有用户访问数据表。&#xA;SQL语法：&#xA;CREATE POLICY &amp;#34;Enable insert for authenticated users only&amp;#34; ON &amp;#34;public&amp;#34;.</description>
    </item>
    <item>
      <title>使用cURL工具访问数据</title>
      <link>http://localhost:1313/docs/app/api/curl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/api/curl/</guid>
      <description>除了API方式外，MemFire Cloud在线文档提供cURL命令来访问云数据库中的数据~&#xA;备注说明：cURL是一个命令行工具（客户端（Client）URL工具），通过指定的URL来上传或下载数据，并将数据展示出来。cURL功能非常强大，熟练的话可以取代Postman 这一类的图形界面工具。&#xA;前置条件 link① 注册MemFire Cloud账号；&#xA;② 存在已创建好的应用；&#xA;③ 完成建表操作，且有写入数据；&#xA;操作步骤 link1.使用API文档 link在我的应用管理页面，点击具体应用，进入应用详情页面，点击左侧菜单栏“API文档”。选中所有数据表中的“employees”，右侧点击&amp;quot;Bash&amp;quot;栏，应用API key选择“公开(anno)”, 则会出现上图所示的该数据表的专属文档。&#xA;2.访问数据 link打开Bash编译器，复制上图中的读取所有行数据命令，粘贴到编译器里，回车即可查询employees数据表的所有数据。</description>
    </item>
    <item>
      <title>开始使用</title>
      <link>http://localhost:1313/docs/app/api/securing-your-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/api/securing-your-api/</guid>
      <description>开始使用 link所有的API都是由数据库表自动创建的。在你向数据库添加了表或函数后，你可以使用所提供的API。&#xA;创建API路由 link当你创建Postgres表、视图或函数时，会自动创建API路由。&#xA;让我们通过创建一个叫做todos的表来存储任务，来创建我们的第一个API路由。 这将创建一个相应的路由todos，它可以接受GET、POST、PATCH和DELETE请求。&#xA;Dashboard&#xD;SQL&#xD;进入仪表板中的表编辑器页面。 点击新表，创建一个名为todos的表。 单击保存。 点击新列，创建一个名为task的列，类型为text。 单击保存。 -- Create a table called &amp;#34;todos&amp;#34; with a column to store tasks.&#xD;create table todos (&#xD;id bigint generated by default as identity primary key,&#xD;task text check (char_length(task) &amp;gt; 3)&#xD;);&#xD;API URL和密钥 link每个Supabase项目都有一个独特的API URL。您的 API 在 API 网关后面是安全的，每次请求都需要一个 API 密钥。&#xA;转到仪表板中的设置页面。 单击侧栏中的 API。 在这个页面上找到你的APIURL、anon和service_role键。 REST API和GraphQL API都可以通过这个URL访问:&#xA;REST: https://&amp;lt;project_ref&amp;gt;.supabase.co/rest/v1 GraphQL: https://&amp;lt;project_ref&amp;gt;.supabase.co/graphql/v1 这两重路由都需要通过apikey标头来传递anon密钥。&#xA;API密钥 link您将获得两个密钥：&#xA;一个anon 密钥, 在浏览器环境下使用是安全的。</description>
    </item>
    <item>
      <title>创建 API 路由</title>
      <link>http://localhost:1313/docs/app/api/creating-routes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/api/creating-routes/</guid>
      <description>当您创建Postgres表、视图或函数时，会自动创建API路由。&#xA;创建一个表 link我们通过创建一个名为 todos 的表来创建我们的第一个 API 路由，用于存储任务。 这个操作将创建一个相应的路由 todos ，它可以接受 GET, POST, PATCH, 和 DELETE 请求。&#xA;控制台&#xD;SQL&#xD;在控制台找到表编辑器页面。 点击 新建表 创建一个表命名为 todos. 点击 保存. 点击 插入列 创建一个名为task，text类型的列。 点击 保存。 -- Create a table called &amp;#34;todos&amp;#34; with a column to store tasks.&#xD;create table&#xD;todos (&#xD;id bigint generated by default as identity primary key,&#xD;task text check (char_length(task) &amp;gt; 3)&#xD;);&#xD;API URL 和 密钥 link每个Supabase项目都有一个唯一的API URL。你的API被放置在一个API网关后面，每个请求都需要API密钥进行身份验证。&#xA;进入控制面板中的设置页面。 单击侧栏中的 API。 在此页面找到您的API URL、anon和service_role密钥。 通过以下URL可以访问 Supabase 的 REST API 和 GraphQL API：</description>
    </item>
    <item>
      <title>概述</title>
      <link>http://localhost:1313/docs/app/functions/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/functions/overview/</guid>
      <description>MemFire Cloud云函数，是运行在云端（服务器端）的、无关联、可重复使用的函数代码。使用MemFire Cloud云函数，您无需购买、管理服务器等基础设施，只需编写和上传代码。MemFire Cloud云函数为您准备好了计算资源，可以弹性、可靠的运行任务，从而可轻松构建任何类型的应用和服务。&#xA;应用场景 link数据ETL处理&#xA;一些数据量比较大、运算成本比较高、不适合在客户端进行运算，比如数据统计、周期性/计划性的处理庞大的数据量工作。例如：统计每天有多少用户查看了商品，平均停留时长；&#xA;编写服务端逻辑&#xA;开发人员利用云函数来处理一些不适合将判断逻辑写在客户端的事件，以保证程序的安全性，如抽奖功能。&#xA;调用第三方API&#xA;在云函数中调用第三方 API ，接入第三方服务，比如调用微信支付接口。</description>
    </item>
    <item>
      <title>管理函数</title>
      <link>http://localhost:1313/docs/app/functions/function-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/functions/function-management/</guid>
      <description>本文介绍函数的属性和运行环境，以及如何通过MemFire Cloud控制台创建函数、更新函数、删除函数等操作。&#xA;云函数支持的函数运行环境列表 link&#xD;运行环境 说明 操作系统 架构 Node.js 12 Node.js 12版本 Linux x86_64 Node.js 14 Node.js 14版本 Linux x86_64 Node.js 16 Node.js 16版本 Linux x86_64 云函数的默认配置 link免费版的云函数默认配置： 运行环境 CPU 内存 磁盘 并发运行数 Node.js 14 0.2 核 256 MB 512MB 10 创建函数 link操作前提 link 已创建应用 操作说明 link1.登录MemFire Cloud平台，进入我的应用-&amp;gt;某应用-&amp;gt;云函数页；&#xA;2.在云函数页面，单击新建函数；&#xA;3.在创建云函数弹框中，点配置以下配置项，然后单击保存；&#xA;基础信息 ：设置函数的基本信息，包括函数名称、请求处理程序。 配置项 说明 函数名 函数名称，必填项；只能包含字母、数字、下划线；不能以数字开头，长度在 1-64 之间；同一应用下的云函数不能重名； 请求处理程序 即函数入口，默认为index.handler；在“运行环境”为 Node.js 时，当前值的格式为 [文件名].[函数名]； 函数配置 ：配置函数的代码和运行环境。 配置项 说明 上传代码包 支持ZIP包上传代码；ZIP文件大小不能超过20Mb, 且index.js必须在ZIP文件的根目录下，采用handler函数为入口函数； 运行环境 目前MemFire Cloud云函数仅支持JavaScript语言，支持的运行环境包括：Node.</description>
    </item>
    <item>
      <title>代码开发</title>
      <link>http://localhost:1313/docs/app/functions/code-development/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/functions/code-development/</guid>
      <description>本文介绍使用云函数编写代码的相关基础概念，包括请求处理函数、函数实例生命周期回调方法等。&#xA;请求处理程序 linkMemFire Cloud云函数的请求处理程序，是函数代码中处理请求的方法。当您的云函数被调用时，会运行您提供的Handler方法处理请求。对于Node.js语言的云函数而言，函数入口为 [文件名].[函数名]，默认为index.handler；&#xA;您可以使用HTTP请求处理程序更方便地处理HTTP请求。当调用函数时，MemFire Cloud云函数使用您提供的执行方法来处理HTTP请求。&#xA;HTTP Handler签名 linkNode.js的HTTP Handler的签名如下。您只需实现一个函数，就能响应HTTP请求。&#xA;exports.handler = (req, resp, context) =&amp;gt; {&#xD;console.log(&amp;#34;receive body: &amp;#34;, req.body.toString());&#xD;resp.setHeader(&amp;#34;Content-Type&amp;#34;, &amp;#34;text/plain&amp;#34;);&#xD;resp.send(&amp;#39;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&amp;#39;);&#xD;} 示例解析如下：&#xA;handler：HTTP Handler名称。 req：HTTP请求结构体。 resp：HTTP返回结构体。 context：上下文信息。 HTTP请求结构体 link&#xD;字段 类型 描述 headers Object 存放来自HTTP客户端的键值对。 path String 表示HTTP路径。 queries Object 存放来自HTTP路径中的查询部分的键值对，值的类型可以为字符串或数组。 method String 表示HTTP方法。 clientIP String 客户端的IP地址。 url String 请求的地址。 说明 Headers键值对中的key中包含以下字段或以x-fc-开头的key均会被忽略，因此，不支持自定义。&#xA;connection keep-alive HTTP响应结构体 link&#xD;字段 类型 描述 response.setStatusCode(statusCode) interger 设置状态码。 response.setHeader(headerKey, headerValue) String，String 设置响应头。 response.</description>
    </item>
    <item>
      <title>环境变量</title>
      <link>http://localhost:1313/docs/app/functions/variable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/functions/variable/</guid>
      <description>安全性 link创建或者更新环境变量时，函数计算会对您的环境变量使用AES256（Advanced Encryption Standard 256）标准加密存储，在初始化函数实例时，会将环境变量解密后注入到函数实例环境中。&#xA;使用限制 link 字符集规则 Key的字符集：必须以大小写字母开头，只能包含大小写字母、数字和下划线。 Value的字符集：必须是可显示的ASCII字符，不能包含中文等其他字符。 大小限制 所有环境变量的大小总和不能超过4 KB。 应用环境变量，包括： API_URL：应用访问URL地址； ANON_KEY: Anon（公开）密钥是客户端API密钥； SERVICE_ROLE_KEY: 服务端访问密钥，可以绕过任何安全策略完全访问您的数据； 通过控制台配置环境变量 link前提条件 link1、存在已创建的云函数&#xA;操作步骤 link 登录MemFire Cloud平台，进入我的应用-&amp;gt;某应用-&amp;gt;云函数页。 在函数管理页面，单击目标函数操作列的编辑。 在编辑函数配置页面的环境变量区域，按需选择配置环境变量的方式，然后单击保存。 （1）单击添加变量。&#xA;（2）配置环境变量的键值对：&#xA;变量名：自定义。 值：自定义。 （3）示例如下。&#xA;验证环境变量是否创建成功。 在代码中使用环境变量,假设配置的环境变量为{&amp;quot;key&amp;quot;:&amp;quot;val&amp;quot;}，以下为Node.js运行环境读取并打印此环境变量值的方法。&#xA;var value = process.env.keyconsole.log(value)&#xD;</description>
    </item>
    <item>
      <title>helloworld</title>
      <link>http://localhost:1313/docs/app/functions/functionexample/helloworld/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/functions/functionexample/helloworld/</guid>
      <description>本文介绍如何在MemFire Cloud控制台快速开发一个简单的 Hello World应用。MemFire Cloud为您提供一个简单的Hello World示例，你可以在下载该示例到本地，并通过控制台使用该示例创建函数。创建成功后，您可以测试该函数，查看函数执行的结果。&#xA;使用说明 link关于以下示例的使用方法，请参见对应代码库的readme.md文件。&#xA;前提条件 link 拥有MemFire Cloud账号;&#xA;创建MemFire Cloud应用开发。&#xA;操作步骤 link步骤1：准备代码包 link准备好Hello World样例，并打包ZIP文件。&#xA;Helloword的代码包地址详见：MemFire / memfire-fc-helloworld · 极狐GitLab&#xA;编写的Hello World样例，只有一个index.js文件，代码如下：&#xA;var getRawBody = require(&amp;#39;raw-body&amp;#39;);&#xD;var getFormBody = require(&amp;#39;body/form&amp;#39;);&#xD;var body = require(&amp;#39;body&amp;#39;);&#xD;/*&#xD;please implement the initializer function as below：&#xD;exports.initializer = (context, callback) =&amp;gt; {&#xD;console.log(&amp;#39;initializing&amp;#39;);&#xD;callback(null, &amp;#39;&amp;#39;);&#xD;};&#xD;*/&#xD;exports.handler = (req, resp, context) =&amp;gt; {&#xD;console.log(&amp;#39;hello world&amp;#39;);&#xD;var params = {&#xD;path: req.</description>
    </item>
    <item>
      <title>wechatpay</title>
      <link>http://localhost:1313/docs/app/functions/functionexample/wechatpay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/functions/functionexample/wechatpay/</guid>
      <description>基于MemFire云函数实现微信支付&#xA;通过MemFire BaaS将原本后端的业务逻辑迁移到前端完成，的确会提高效率，但也不可避免的带来了一些安全隐患。&#xA;背景 link现在假设要求你使用MemFire的BaaS服务实现一个“极简的卖书”应用，你该怎么设计？本文会讲解如何简单又安全的实现这个应用。&#xA;业务分析 link应用的核心业务逻辑是：用户选择喜欢的图书，加入购物车后，能够通过微信完成支付。&#xA;我们将该业务逻辑的实体对象与操作拆解出来，分别是：用户，图书，支付&#xA;如何区分用户：应用可以要求用户登录，通过登录的身份标识来区分。因此我们可以利用MemFire BaaS服务提供的认证管理工作快速实现。 如何管理图书：应用创建后，可以通过新建一张图书的表，在该表中灌入图书的初始数据。 用户如何支付：根据选择书籍的总金额，利用微信支付的接口完成支付调用。 数据表设计 link 用户表：无需设计，BaaS服务自带 书籍表：books 我们将用户下单这个操作形成的结果叫做“创建交易”。交易表：transactions 该表中的uid关联的是auth.user表中的id字段，标识用户；表中的open_id代表微信用户，一样是标识用户的，不过只有使用微信小程序完成微信支付时才需要；status标识支付状态，默认为READY。&#xA;支付接口实现 link首先思考一个问题，如何保证支付信息是不可被恶意篡改的。简单点说，如果我们直接通过前端调用微信支付，那么支付金额可能被用户通过页面调试或网络劫持的方式篡改，那如何保证用户无法修改支付信息呢（包括支付金额，支付状态）。&#xA;再思考一个问题，类似于微信支付等许多第三方接口都是异步的，它们通过你提供的回调地址将异步操作的结果返回给你，那现在你的接口都是由BaaS服务提供的，你怎么创建回调函数呢？&#xA;为了解决上述说的两个问题，MemFire提供了云函数这个模块，它允许你通过编写JavaScript函数，实现接口服务的部署。&#xA;通过上传你的代码包，配置环境变量即可快速实现微信支付的接口部署。&#xA;我们打开微信支付代码包中的index.js文件，进行分析：&#xA;const { v4: uuidv4 } = require(&amp;#39;uuid&amp;#39;);&#xD;const WxPay = require(&amp;#39;wechatpay-node-v3&amp;#39;)&#xD;const sup = require(&amp;#39;@supabase/supabase-js&amp;#39;)&#xD;// 支付客户端和supabase客户端&#xD;let pay&#xD;let supabase&#xD;// 云函数生命周期，初始化时，初始化supabase和pay&#xD;exports.initializer = (context, callback) =&amp;gt; {&#xD;const publicKeyPem = process.env.publicKey&#xD;const privateKeyPem = process.env.privateKey&#xD;try {&#xD;// 初始化支付客户端&#xD;pay = new WxPay({&#xD;appid: process.</description>
    </item>
    <item>
      <title>抽奖示例</title>
      <link>http://localhost:1313/docs/app/functions/functionexample/raffle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/functions/functionexample/raffle/</guid>
      <description>本文介绍如何在MemFire Cloud控制台快速开发一个简单的抽奖应用。MemFire Cloud为您提供一个简单的抽奖示例，你可以在下载该示例到本地，并通过控制台使用该示例创建函数。创建成功后，您可以测试该函数，查看函数执行的结果。&#xA;使用说明 link关于以下示例的使用方法，请参见对应代码库的readme.md文件。&#xA;前提条件 link 拥有MemFire Cloud账号; 创建MemFire Cloud应用开发。 操作步骤 link步骤1：准备代码包 link准备好抽奖样例，并打包ZIP文件。&#xA;抽奖的代码包地址详见：https://github.com/LucaRao/Prize&#xA;编写的抽奖样例，只有一个index.js文件，代码如下：&#xA;const prizes = [&amp;#34;特等奖&amp;#34;, &amp;#34;一等奖&amp;#34;, &amp;#34;二等奖&amp;#34;, &amp;#34;三等奖&amp;#34;, &amp;#34;参与奖&amp;#34;];&#xD;exports.handler = (req, resp, context) =&amp;gt; {&#xD;// const dotenv = require(&amp;#34;dotenv&amp;#34;);&#xD;// dotenv.config();&#xD;// const { Client } = require(&amp;#39;pg&amp;#39;)&#xD;// const client = new Client({&#xD;// user: process.env.PGUSER,&#xD;// host: process.env.PGHOST,&#xD;// database: process.env.PGDATABASE,&#xD;// password: process.env.PGPASSWORD,&#xD;// port: process.env.PGPORT,&#xD;// })&#xD;// client.connect();&#xD;var params = {&#xD;path: req.</description>
    </item>
    <item>
      <title>概述</title>
      <link>http://localhost:1313/docs/app/realtime/realtime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/realtime/realtime/</guid>
      <description>Supabase提供一个全球分布的实时服务器集群，实现了以下功能：&#xA;广播：以低延迟的方式从客户端向客户端发送短暂的信息。 Presence：跟踪和同步客户端之间的共享状态。 Postgres CDC：听取Postgres数据库的变化，并将其发送给授权客户。 频道 是实时的基本构建块，它缩小了订阅客户端的数据流范围。 你可以把一个频道想象成一个聊天室，参与者可以看到谁在网上，并发送和接收消息；类似于Discord或Slack频道。&#xA;所有客户端都可以连接到一个频道，并利用内置的广播和呈现功能，而扩展功能（如PostgresCDC）必须在使用前启用。&#xA;广播 link广播遵循发布-订阅模式，客户将消息发布到具有唯一标识符的频道。例如，一个用户可以向一个id为room-1的频道发送消息。&#xA;其他客户可以通过订阅id为`room-1&amp;rsquo;的频道来选择实时接收该消息。如果这些客户在线并订阅了，那么他们将收到该消息。&#xA;广播的工作原理是将你的客户端连接到最近的实时服务器，该服务器将与其他服务器通信，将消息转发给其他客户端。&#xA;一个常见的用例是在网络游戏中与其他客户端分享用户的光标位置。&#xA;Presence linkPresence利用内存中无冲突的复制数据类型（CRDT），以最终一致的方式跟踪和同步共享状态。它计算现有状态和新的状态变化之间的差异，并通过广播向客户端发送必要的更新。&#xA;当一个新客户端订阅了一个频道时，它将立即在一条消息中接收该频道的最新状态，而不是等待所有其他客户端发送各自的状态。&#xA;客户可以随心所欲地来来去去，只要他们都订阅了同一频道，那么他们都将拥有彼此相同的状态。&#xA;Presence的好处是，如果一个客户突然断开连接（例如，他们下线了），他们的状态将自动从共享状态中删除。如果你曾经试图建立一个处理意外断开连接的 &amp;ldquo;我在线 &amp;ldquo;功能，你就会体会到这是多么有用。&#xA;Postgres CDC linkPostgres变化数据捕获（CDC）使你能够监听数据库的变化，并根据行级安全(RLS)策略将其广播给授权客户。&#xA;这是由实时轮询你的数据库的逻辑复制槽的变化，将这些变化传递给apply_rlsSQL函数以确定哪些客户端有权限，然后使用广播将这些变化发送给客户端。&#xA;实时需要一个名为supabase_realtime的发布来确定哪些表需要轮询。你必须在客户端订阅想要监听数据库变化的频道之前，将表添加到这个发布中。&#xA;我们强烈建议你在你的数据库表上启用RLS，并制定RLS策略以防止未经授权的人访问你的数据。&#xA;参考资源 link 快速快速入门 实时：多人版本 blog post </description>
    </item>
    <item>
      <title>实时快速入门</title>
      <link>http://localhost:1313/docs/app/realtime/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/realtime/quickstart/</guid>
      <description>学习如何构建multiplayer.dev，这是一个合作应用，它展示了使用实时的广播、Presence和Postgres CDC。&#xA;安装supabase-js 客户端 link&#xD;npm install @supabase/supabase-js&#xD;光标位置 link广播允许一个客户端发送消息，多个客户端接收消息。广播的消息是短暂的。它们不会被持久化到数据库中，而是直接通过实时服务器转发。这对于发送像光标位置这样的信息是很理想的，因为最小的延迟是很重要的，但持久化则不是。&#xA;在multiplayer.dev中，客户端的光标位置被发送到房间里的其他客户端。然而，在这个例子中，光标位置将是随机生成的。&#xA;你需要从你的项目的API设置中获得公共的anon访问令牌。然后你就可以设置Supabase客户端，并开始发送一个客户端的光标位置到通道room1中的其他客户端。&#xA;const { createClient } = require(&amp;#39;@supabase/supabase-js&amp;#39;)&#xD;const supabase = createClient(&amp;#39;https://your-project-ref.supabase.co&amp;#39;, &amp;#39;anon-key&amp;#39;, {&#xD;realtime: {&#xD;params: {&#xD;eventsPerSecond: 10,&#xD;},&#xD;},&#xD;})&#xD;// Channel name can be any string.&#xD;// Create channels with the same name for both the broadcasting and receiving clients.&#xD;const channel = supabase.channel(&amp;#39;room1&amp;#39;)&#xD;// Subscribe registers your client with the server&#xD;channel.subscribe((status) =&amp;gt; {&#xD;if (status === &amp;#39;SUBSCRIBED&amp;#39;) {&#xD;// now you can start broadcasting cursor positions&#xD;setInterval(() =&amp;gt; {&#xD;channel.</description>
    </item>
    <item>
      <title>Postgres CDC</title>
      <link>http://localhost:1313/docs/app/realtime/postgres-cdc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/realtime/postgres-cdc/</guid>
      <description>实时的Postgres变更数据捕获（CDC）功能监听数据库的变更，并将其发送给客户端。客户端需要通过JWT订阅，该JWT决定了他们可以根据数据库的行级安全接收哪些变化。&#xA;任何能够访问用项目的JWT秘密签名的有效JWT的人都能够监听你的数据库的变化，除非表启用了行级安全并制定了策略。&#xA;客户端可以选择接收 INSERT、UPDATE、DELETE或 *（all）的变化，用于接收模式中的所有变化、模式中的一个表或表中的一个列的值。你的客户应该只监听public模式中的表，你必须首先启用你希望客户监听的表。&#xA;Postgres CDC对 public模式中的表是开箱即用的。你可以通过给访问令牌中的数据库角色授予表 SELECT的权限来监听你的私有模式中的表。你可以运行一个类似于以下的查询。&#xA;GRANT SELECT ON &amp;#34;private_schema&amp;#34;.&amp;#34;table&amp;#34; TO authenticated;&#xD;info&#xD;我们强烈建议你启用RLS并为私有模式中的表创建策略。否则，你所授予的任何角色都将拥有对表的不受限制的读取权限。&#xA;你可以在仪表板的Replication部分或用SQL editor来做这个。&#xA;begin;&#xD;-- remove the supabase_realtime publication&#xD;drop publication if exists supabase_realtime;&#xD;-- re-create the supabase_realtime publication with no tables&#xD;create publication supabase_realtime;&#xD;commit;&#xD;-- add a table to the publication&#xD;alter publication supabase_realtime add table messages;&#xD;默认情况下，只发送 新的记录变化，但如果你想在每次 UPDATE或 DELETE一个记录时接收 旧的记录（以前的值）。 你可以将你的表的replica identity 设置为 full。&#xA;alter table messages replica identity full;&#xD;监听public模式中的所有变化：</description>
    </item>
    <item>
      <title>实时速率限制</title>
      <link>http://localhost:1313/docs/app/realtime/rate-limits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/realtime/rate-limits/</guid>
      <description>Supabase Realtime是一个全球集群。我们已经实施了一些速率限制，以帮助确保所有客户的高可用性。&#xA;速率限制可按项目配置，我们的集群支持数百万的并发连接。联系支持如果这些限制造成了问题。&#xA;按计划限制 link免费计划和专业计划都有相应的限制。更多信息见我们的定价页。&#xA;企业计划是按使用量计费的。我们仍然对企业计划采用限制措施。如果你使用企业计划，只需联系支持，我们将根据需要增加你的限额。&#xA;企业计划的限制从以下几点开始。&#xA;500个并发客户 每秒1,000条信息 500个并发的频道 系统限制 link以下限制适用于所有项目:&#xA;每秒有500个频道加入 每个连接的客户端有100个频道 客户端限制 link一些基本的WebSocket消息速率限制在客户端实现。&#xA;例如，multiplayer.dev demo实例化了带有eventsPerSecond参数的Supabase客户端。&#xA;速率限制错误 link速率限制错误可能出现在WebSocket连接的后端日志和消息中。&#xA;info&#xD;使用Realtime Inspector来重现错误，并与Supabase支持部门分享这些连接细节。&#xA;后端日志 link如果你的项目被限制了速率，请检查你的Realtime logs。&#xA;WebSocket错误 link tenant_events。如果你的项目每秒产生太多的消息，客户将被断开连接。supabase-js应该在消息率降低到你的计划限制以下时自动重新连接。 一些限制会导致通道加入被拒绝。Realtime将以下列WebSocket消息之一作为答复：&#xA;too_many_channels：目前有太多的频道加入到一个客户端。 too_many_connections: 一个项目有太多的并发连接。 too_many_joins: 每秒有太多的频道加入。 info&#xD;使用浏览器的开发工具查找WebSocket启动请求并查看单个消息。&#xA;有效载荷的限制 link实时的信息字节大小限制为1兆字节。&#xA;Presence的局限性 link实时Presence是一个基于Phoenix Presence的CRDT支持的内存键值存储。更新一个Presence比广播一个消息更昂贵。&#xA;以下限制适用于Presence消息：&#xA;每个对象有10个键 消息速率限制是你的实时消息速率限制的10%。 </description>
    </item>
    <item>
      <title>概述</title>
      <link>http://localhost:1313/docs/app/storage/storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/storage/storage/</guid>
      <description>Supabase存储使存储和服务大文件变得简单.&#xA;文件 link文件可以是任何类型的媒体文件。这包括图像、GIF和视频。由于文件的大小，最好将其存储在数据库之外。为了安全起见，HTML文件以纯文本形式返回。&#xA;文件夹 link文件夹是组织文件的一种方式（就像在计算机上一样）。 组织文件没有正确或错误的方法。您可以将它们存储在适合项目的任何文件夹结构中。&#xA;存储桶 linkBucket是文件和文件夹的不同容器。你可以把它们想象成“超级文件夹”。 通常，您会为不同的安全和访问规则创建不同的存储桶。例如，您可以将所有视频文件保存在&amp;quot;video&amp;quot; 桶中，并将个人资料图片保存在&amp;quot;avatar&amp;quot;桶中。&#xA;开始使用 link这是一个快速指南，介绍了Supabase Storage的基本功能。查找完整的GitHub中的示例应用程序, 您可以自行部署。&#xA;info&#xD;文件、文件夹和Bucket名称必须遵循AWS对象密钥命名指南并避免使用任何其他字符。&#xA;创建一个存储桶 link你可以使用Supabase仪表板创建一个存储桶。 由于存储可与Postgres数据库互操作，您还可以使用SQL或我们的客户端库。这里我们创建一个叫做 &amp;ldquo;avatars &amp;ldquo;的桶。&#xA;Dashboard&#xD;SQL&#xD;JavaScript&#xD;Dart&#xD;1.进入存储页面。&#xA;2.单击新建Bucket并输入Bucket的名称。&#xA;3.单击创建Bucket。&#xA;-- Use Postgres to create a bucket.&#xD;insert into storage.buckets (id, name)&#xD;values (&amp;#39;avatars&amp;#39;, &amp;#39;avatars&amp;#39;);&#xD;// Use the JS library to create a bucket.&#xD;const { data, error } = await supabase.storage.createBucket(&amp;#39;avatars&amp;#39;)&#xD;Reference.&#xA;void main() async {&#xD;final supabase = SupabaseClient(&amp;#39;supabaseUrl&amp;#39;, &amp;#39;supabaseKey&amp;#39;);&#xD;final storageResponse = await supabase&#xD;.</description>
    </item>
    <item>
      <title>总览</title>
      <link>http://localhost:1313/docs/app/ai/ai/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/app/ai/ai/</guid>
      <description>随着ChatGPT的爆火，人们逐渐认识到大语言模型（LLM）和生成式人工智能在多个领域具有潜力，如文稿撰写、图像生成、代码优化和信息搜索等。LLM已成为个人和企业的有力助手，引领着新的生态系统。本文将介绍Embedding相关概念以及构建由LLM驱动的专属AI对话机器人总体流程。&#xA;背景 linkAI领域技术不断突破，越来越多的企业和个人积极探索利用大型语言模型（LLM）和生成式人工智能技术，来构建专注于特定领域的具备人工智能能力的产品。目前大型语言模型在解决通用问题方面表现出色，但由于受到训练数据和模型规模的限制，其在专业知识和时效性方面存在一定局限性。例如ChatGPT的训练的数据都是2021年及以前的，这也意味着想要咨询2021年以后的知识ChatGPT并不能给出准确的回答。&#xA;在信息时代，企业的知识库更新速度不断加快。因此，对于企业而言，如果希望在大型语言模型的基础上构建特定垂直领域的人工智能产品，就需要将自身的知识库输入到大型语言模型中进行训练。但是要知道，一个大语言模型的参数动辄上百数千亿。单单本地的一点知识库放进去就是沧海一粟。很难达到想要的效果。加之对硬条件要求过高，很少企业和个人有条件能够直接“投喂”到模型里面训练。&#xA;目前有两种常见的方法实现：&#xA;微调（Fine-tuning）：通过提供新的数据集对已有模型的权重进行微调，不断更新输入以调整输出，以达到所需的结果。这适用于数据集规模不大或针对特定类型任务或风格进行训练。 提示调整（Prompt-tuning）：通过调整输入提示而非修改模型权重，从而实现调整输出的目的。相较于微调，提示调整具有较低的计算成本，需要的资源和训练时间也较少，同时更加灵活。 但随着语言模型越来越大，Fine-tune的成本也越来越高。目前市面上已经涌现许多由大语言模型驱动的专属AI对话机器人，这些大都是通过提示调整来实现建立本地化AI知识库。 实现原理 link本文将展示开发一款专属AI对话机器人的流程：&#xA;第一阶段：数据准备&#xA;知识库信息提取和分块：从领域知识库中提取相关的文本信息，并将其分块处理。这可以包括将长文本拆分为段落或句子，提取关键词或实体等。这样可以将知识库的内容更好地组织和管理。 调用大语言模型接口生成Embedding：利用大语言模型（如OpenAI）提供的接口，将分块的文本信息输入到模型中，并生成相应的文本Embedding。这些Embedding将捕捉文本的语义和语境信息，为后续的搜索和匹配提供基础。 存储Embedding信息：将生成的文本Embedding信息、文本分块以及文本关联的metadata信息存入MemFireCloud PostgreSQL数据库中。 第二阶段：问答&#xA;用户提问。 通过OpenAI提供的Embedding接口创建该问题的Embedding。通俗的说就是你发出的提问内容A，通过OpenAI的接口，返回问题内容A的一个向量，也就是我们之前说的Embedding。 因为在步骤1我们已经将我们的本地的知识库进行分片和Embedding，我们现在只需要将A的Embedding值和我们知识库分片的Embedding值进行比对，通过pgvector这个扩展，能够帮我们过滤出PostgreSQL数据库中相似度大于一定阈值的文档块. 然后将我们的提问内容A和过滤出来的文档块，作为prompt一同发送给OpenAI，并将OpenAI结果返回给用户。这样一来，用户得到的就是逻辑严谨准确率高且符合人类语法的回答。 流程图如下： 关于产品 linkMemFire Cloud提供了一个开源工具包，用于使用Postgres和pgvector开发人工智能应用程序。使用MemFire Cloud客户端库，在规模上存储、索引和查询你的Embedding。 这个工具包含以下功能：&#xA;使用 Postgres 与 pgvector 来实现 向量存储 和嵌入支持。 提供 Python客户端 ，用于管理非结构化嵌入。 提供 数据库迁移 ，用于管理结构化嵌入。 支持与多个流行的 AI 供应商 (如 OpenAI 、 Hugging Face 、LangChain 等) 进行集成。 相关概念 | Embedding link当谈到&amp;quot;Embedding&amp;quot;时，它通常是指将高维数据转换为低维表示的过程。在自然语言处理（NLP）和机器学习领域，&amp;ldquo;Embedding&amp;quot;通常用来将单词、短语、文本或者图像数据转换为向量（也称为嵌入向量或词嵌入）。因为计算机是擅长处理数字运算的，所以将无法计算的文本数据转化为向量数据，从而便于后面的计算。 你可能会疑问这些文本数据是如何转换成向量的，这又是如何规定的。接下来我将会为您讲解。&#xA;我们描述一个人可以有很多形容词，假定我们有4个人（张三、李四、王五、赵六），给每个人都从“可爱的”、“高挑的”、“高智商的”、“善解人意的”、“多愁善感的”这5个方面进行描述。符合定义为1，不符合定义为0，那么这4个人的描述可能是：&#xA;[1,0,1,0,0]&#xD;[1,1,0,0,1]&#xD;[0,0,1,1,1]&#xD;[1,1,1,0,0]&#xD;每个向量都有5个维度，每个维度都代表一个方面的描述。从左到右的依次表示为：“可爱的”、“高挑的”、“高智商的”、“善解人意的”、“多愁善感的”。向量1-4分别代表：张三、李四、王五、赵六。如此，我可以得知张三不仅长得可爱还高智商。这种张三对应向量[1,0,1,0,0]这种对应关系不是为了某种目的进行的，它只是一种泛泛的描述，还不能叫做Embedding。 我们接着往下看。也把上面的5个维度扩展一下，增加“名校学历”、“勤奋”、“守时”、“诚实”、“外向”5个维度，构成10个维度进行考察评估，在面试考察中可能得到的结果是一组10维向量：&#xA;[1,0,1,0,0,0,1,1,1,0]&#xD;[1,1,0,0,1,1,1,0,1,0]&#xD;[0,0,1,1,1,1,1,0,0,0]&#xD;[1,1,1,0,0,0,1,1,1,1]&#xD;这个时候我们可以得出，张三是一个长得可爱，智商高，勤奋，守时，诚实的人。 当我们考虑“招聘程序员”这个场景，那么这10个维度的描述似乎不大能看出这个人的是否符合我们的职位要求。也就是说，这10个维度取的不大合适。这时候我们可能需要替换一下考察维度。比如替换为“熟悉数据结构”、“具有大型线上项目经验”、“精通C++”、“带过团队”、“持续学习”、“名校学历”、“勤奋”、“守时”、“诚实”、“外向” 这时我们得到一组新的向量。&#xA;[1,1,1,1,1,0,1,1,1,0] [0,0,1,0,1,1,1,0,1,0] [1,0,0,0,1,1,1,0,0,0]&#xD;[0,1,1,0,0,0,1,1,1,1]&#xD;此时我们可以看出张三对应[1,1,1,1,1,0,1,1,1,0]，得出张三是熟悉数据结构、具有大型线上项目经验、精通C++、带过团队、持续学习、非名校学历、勤奋、守时、诚实、不外向的人。 这么看，这个人似乎很符合岗位的需要，于是决定发offer。这种面向一定目的的描述，可以被称为Embedding</description>
    </item>
    <item>
      <title>静态托管</title>
      <link>http://localhost:1313/docs/app/hosting/static-hosting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/hosting/static-hosting/</guid>
      <description>MemFire Cloud静态托管可以为您的Web应用、静态资源提供快速、稳定的托管服务。无需自建服务器，可以一键快速地部署静态资源，提供快速的访问能力。&#xA;主要功能 link自定义域名 linkMemFire Cloud 静态网站托管支持自定义域名，用户可以通过使用您的私有域名访问静态资源。&#xA;快速分发 link静态托管将会缓存在遍布各地的CDN服务器上。无论用户身在何地，都可以快速访问网站。 备注说明：公测阶段，该功能未开放.</description>
    </item>
    <item>
      <title>快速开始</title>
      <link>http://localhost:1313/docs/app/hosting/static-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/hosting/static-start/</guid>
      <description>使用说明 link配置静态网站托管时，您需要指定网站的默认首页index.html。&#xA;├── index.html&#xD;├── error.html&#xD;├── example.txt&#xD;└── subdir/&#xD;└── index.html&#xD;准备工作 link 拥有MemFire Cloud账号; 已完成MemFire Cloud平台实名认证; 创建MemFire Cloud应用开发。 步骤1：写一个简单的HTML link下面我们创建一个简单的HTML文件，命名为index.html：&#xA;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&#xD;Hello MemFire Cloud!&#xD;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#xD;步骤2：打包压缩 link打包压缩index.html文件，其中压缩包必须为ZIP格式。&#xA;打包方式：先进入您的代码目录，在全选所有文件以后，单击鼠标右键，选择压缩为 ZIP 包，生成代码包。或者您也可以在代码包的根目录下执行zip -rq -y code.zip ./命令进行打包。&#xA;Linux，Unix的系统环境下，使用zip命令打包，不要使用tar命令； 备注说明：公测环境下，压缩包大小不超过20MB。&#xA;步骤3：上传压缩包，完成部署 link1.登录MemFire Cloud平台，进入我的应用-&amp;gt;某应用-&amp;gt;静态托管页面。&#xA;2.点击上传文件，选中网站压缩包进行上传。&#xA;完成上传操作后，用户即可通过MemFire Cloud平台提供的访问地址进行访问托管的静态网站。</description>
    </item>
    <item>
      <title>自定义域名</title>
      <link>http://localhost:1313/docs/app/hosting/static-domain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/hosting/static-domain/</guid>
      <description>MemFire Cloud 静态网站托管提供了可供开发、测试使用的默认域名，在开发期间，您可以通过默认域名访问静态网站。此外，用户还可以根据业务需要，自定义网站访问域名。&#xA;添加自定义域名 link1.登录MemFire Cloud平台，进入我的应用-&amp;gt;某应用-&amp;gt;静态托管页面。点击配置域名，输入新的域名，如下图所示。&#xA;2.单击下一步，可查看TXT域名解析记录和CNAME域名解析记录。 TXT和CNAME 域名不能直接访问，您需要在域名服务提供商处完成TXT和CNAME 配置，配置生效后，您的托管服务方可对自定义域名生效。&#xA;3.配置TXT和CNAME。登录域名解析服务商平台，并手动添加到您的域名解析记录中。 如果您的DNS服务商为阿里云，则可以通过以下步骤添加CNAM记录、TXT记录。&#xA;（1）单击添加记录，添加TXT域名解析记录。 （2）单击添加记录，添加CNAME域名解析记录。 4.配置完成后，再点击验证，来验证域名是否配置成功。如果验证提示成功，则可以通过自定义域名来访问静态托管网站。</description>
    </item>
    <item>
      <title>Flutter库</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/start/dart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/start/dart/</guid>
      <description>本参考文献记录了Supabase的同构Flutter库supabase-flutter中的每个对象和方法。&#xA;你可以使用supabase-flutter库来。&#xA;与您的Postgres数据库互动 听取数据库的变化 调用数据库函数 建立登录和用户管理功能 管理大文件 适用于非Flutter项目 link我们还有supabase-dart用于非Flutter Dart项目，如服务器端Dart或Angular-Dart。 supabase-dart与supabase-flutter共享大部分的API，而不依赖于Flutter，因此你可以在任何可以运行Dart的地方使用Supabase!&#xA;相关链接 link 源代码 已知的错误和问题 </description>
    </item>
    <item>
      <title>初始化</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/start/initializing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/start/initializing/</guid>
      <description>在使用 Supabase 的功能之前，需要先对 Supabase 进行初始化。这可以通过调用 Supabase 类的静态方法 initialize() 来实现。这个方法可能需要提供一些配置参数，以便正确地连接到 Supabase 服务。&#xA;一旦完成初始化，Supabase 客户端就是您与 Supabase 服务进行交互的主要接口。通过客户端，您可以访问 Supabase 提供的各种功能和服务。这是与 Supabase 生态系统内的其他组件交互的最简单且主要的方式，使您能够轻松地使用 Supabase 提供的各种功能。&#xA;案例教程 link案例1 （Flutter项目） link&#xD;使用方法&#xD;Future&amp;lt;void&amp;gt; main() async {&#xD;await Supabase.initialize(&#xD;url: &amp;#39;https://xyzcompany.supabase.co&amp;#39;,&#xD;anonKey: &amp;#39;public-anon-key&amp;#39;,&#xD;);&#xD;runApp(MyApp());&#xD;}&#xD;// Get a reference your Supabase client&#xD;final supabase = Supabase.instance.client;&#xD;案例2 （其他Dart项目） link&#xD;使用方法&#xD;final supabase = SupabaseClient(&#xD;&amp;#39;https://xyzcompany.supabase.co&amp;#39;,&#xD;&amp;#39;public-anon-key&amp;#39;,&#xD;);&#xD;</description>
    </item>
    <item>
      <title>安装</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/start/installing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/start/installing/</guid>
      <description>Flutter项目 link对于Flutter项目，你可以使用supabase_flutter包。&#xA;flutter pub add supabase_flutter&#xD;其他Dart项目 link对于使用Dart的非Flutter项目，如服务器端Dart或Angular-Dart，你可以使用supabase包。&#xA;dart pub add supabase&#xD;</description>
    </item>
    <item>
      <title>更新</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/start/upgrade-guide/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/start/upgrade-guide/</guid>
      <description>supabase-flutter专注于改善开发者的体验，使其更容易使用。本指南将帮助你从supabase-flutter v0升级到v1。&#xA;升级客户端库 link更新你的pubspec.yaml文件中的软件包。&#xA;supabase_flutter: ^1.0.0&#xD;错误处理 linksupabase-flutter抛出错误的方式在v1中有所改变。在v1中，错误是以异常形式抛出的。这使得作为Flutter开发者处理错误时更加直观。&#xA;Before&#xD;After&#xD;final res = await supabase.from(&amp;#39;my_table&amp;#39;).select().execute();&#xD;final error = res.error;&#xD;if (error != null) {&#xD;// handle error&#xD;}&#xD;final data = res.data;&#xD;try {&#xD;final data = supabase.from(&amp;#39;my_table&amp;#39;).select();&#xD;} catch (error) {&#xD;// handle error&#xD;}&#xD;Auth类/方法 linkSupabaseAuthState和SupabaseAuthRequiredState类的用法 link在v0中，SupabaseAuthState和SupabaseAuthRequiredState是用来处理自动令牌刷新和监听认证状态变化的。在v1版本中，SupabaseAuthState和SupabaseAuthRequiredState被弃用，令牌刷新将通过初始化Supabase自动发生。onAuthStateChange可以用来对auth状态的变化采取行动。&#xA;Before&#xD;After&#xD;await Supabase.initialize(&#xD;url: &amp;#39;SUPABASE_URL&amp;#39;,&#xD;anonKey: &amp;#39;SUPABASE_ANON_KEY&amp;#39;,&#xD;);&#xD;...&#xD;class AuthState&amp;lt;T extends StatefulWidget&amp;gt; extends SupabaseAuthState&amp;lt;T&amp;gt; {&#xD;...&#xD;}&#xD;...&#xD;class AuthRequiredState&amp;lt;T extends StatefulWidget&amp;gt; extends SupabaseAuthState&amp;lt;T&amp;gt; {&#xD;.</description>
    </item>
    <item>
      <title>Select 查询</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/select/</guid>
      <description>select()用于对表格或视图执行SELECT查询。&#xA;默认情况下，Supabase项目将返回最多1,000行。这个设置可以在项目API设置中更改。建议将其保持较低，以限制意外或恶意请求的有效负载大小。您可以使用range()查询来分页处理数据。 select()可以与过滤器Filter组合使用 select()可以与修改器Modifier组合使用 如果您正在使用Supabase平台，apikey是一个保留关键字，应避免将其作为列名。 案例教程 link案例1 (获取您的数据) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name&amp;#39;);&#xD;案例2 (选择特定的列) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;&amp;#39;&amp;#39;&#xD;name,&#xD;cities (&#xD;name&#xD;)&#xD;&amp;#39;&amp;#39;&amp;#39;);&#xD;你可以从你的表中选择特定的字段。&#xA;案例3 (查询外键表) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;&amp;#39;&amp;#39;&#xD;name,&#xD;cities (&#xD;name&#xD;)&#xD;&amp;#39;&amp;#39;&amp;#39;);&#xD;如果您的数据库有关联关系，您也可以查询相关的表。&#xA;案例4 (多次查询同一个外键表) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;messages&amp;#39;)&#xD;.</description>
    </item>
    <item>
      <title>Insert 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/insert/</guid>
      <description>insert()用于在表(table)或视图(view)执行 INSERT 操作。&#xA;案例教程 link案例1 (创建记录) link&#xD;使用方法&#xD;&gt;&#xD;await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.insert({&amp;#39;name&amp;#39;: &amp;#39;The Shire&amp;#39;, &amp;#39;country_id&amp;#39;: 554});&#xD;案例2 (批量创建) link&#xD;使用方法&#xD;&gt;&#xD;await supabase.from(&amp;#39;cities&amp;#39;).insert([&#xD;{&amp;#39;name&amp;#39;: &amp;#39;The Shire&amp;#39;, &amp;#39;country_id&amp;#39;: 554},&#xD;{&amp;#39;name&amp;#39;: &amp;#39;Rohan&amp;#39;, &amp;#39;country_id&amp;#39;: 555},&#xD;]);&#xD;案例3 (获取插入的记录) link&#xD;使用方法&#xD;&gt;&#xD;final List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; data =&#xD;await supabase.from(&amp;#39;cities&amp;#39;).insert([&#xD;{&amp;#39;name&amp;#39;: &amp;#39;The Shire&amp;#39;, &amp;#39;country_id&amp;#39;: 554},&#xD;{&amp;#39;name&amp;#39;: &amp;#39;Rohan&amp;#39;, &amp;#39;country_id&amp;#39;: 555},&#xD;]).select();&#xD;</description>
    </item>
    <item>
      <title>Update 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/update/</guid>
      <description>update()用于对表（table）或视图（view）执行 UPDATE 操作。&#xA;update()应该始终与筛选器Filters结合使用，以便定位您希望更新的项目。 案例教程 link案例1 (更新数据) link&#xD;使用方法&#xD;&gt;&#xD;await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Middle Earth&amp;#39; })&#xD;.match({ &amp;#39;name&amp;#39;: &amp;#39;Auckland&amp;#39; });&#xD;案例2 (更新JSON数据) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;await supabase&#xD;.from(&amp;#39;users&amp;#39;)&#xD;.update({&#xD;&amp;#39;address&amp;#39;: {&#xD;&amp;#39;street&amp;#39;: &amp;#39;Melrose Place&amp;#39;,&#xD;&amp;#39;postcode&amp;#39;: 90210&#xD;}&#xD;})&#xD;.eq(&amp;#39;address-&amp;gt;postcode&amp;#39;, 90210);&#xD;Postgres提供了一个 运算符的数量 用于处理JSON数据。现在，它只能更新整个JSON文档。 但我们正在研究更新单个键的想法。&#xA;案例3 (获取更新的行) link&#xD;使用方法&#xD;&gt;&#xD;final List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; data = await supabase&#xD;.from(&amp;#39;users&amp;#39;)&#xD;.update({&#xD;&amp;#39;address&amp;#39;: {&amp;#39;street&amp;#39;: &amp;#39;Melrose Place&amp;#39;, &amp;#39;postcode&amp;#39;: 90210}&#xD;})&#xD;.eq(&amp;#39;address-&amp;gt;postcode&amp;#39;, 90210)&#xD;.</description>
    </item>
    <item>
      <title>Upsert 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/upsert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/upsert/</guid>
      <description>upsert()用于对表（table）或视图（view）执行 UPSERT 操作。&#xA;在关系型数据库中，Upsert是一种结合了&amp;quot;插入（Insert）&amp;ldquo;和&amp;quot;更新（Update）&amp;ldquo;的操作,它允许我们在表或视图上执行插入或更新操作。 通常情况下，当我们想要向数据库中插入一行数据时，我们会使用INSERT语句。 但是，如果该行数据已经存在（通常通过主键来判断），我们可能希望更新该行数据而不是插入重复的数据。&#xA;Upsert通过传递列到onConflict方法，我们可以使用.upsert()来实现以下功能：&#xA;如果不存在具有相应onConflict列的行，则执行等效于.insert()的插入操作。 如果存在具有相应onConflict列的行，则根据ignoreDuplicates的设置执行另一种操作。 需要注意的是，为了使用upsert，必须在values中包含主键。主键是用于唯一标识表中每一行的一列或一组列，确保数据的唯一性和完整性。&#xA;案例教程 link案例1 (Upsert数据) link&#xD;使用方法&#xD;&gt;&#xD;await supabase&#xD;.from(&amp;#39;messages&amp;#39;)&#xD;.upsert({ &amp;#39;id&amp;#39;: 3, &amp;#39;message&amp;#39;: &amp;#39;foo&amp;#39;, &amp;#39;username&amp;#39;: &amp;#39;supabot&amp;#39; });&#xD;案例2 (将数据Upsert到带有约束的表中) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;await supabase&#xD;.from(&amp;#39;users&amp;#39;)&#xD;.upsert({ &amp;#39;username&amp;#39;: &amp;#39;supabot&amp;#39; }, { &amp;#39;onConflict&amp;#39;: &amp;#39;username&amp;#39; });&#xD;运行以下代码将使 Supabase 进行数据的 UPSERT 操作到 &amp;ldquo;users&amp;rdquo; 表中。如果用户名 &amp;lsquo;supabot&amp;rsquo; 已经存在，onConflict 参数会告诉 Supabase 根据传递给 onConflict 的列来覆盖那一行的数据。&#xA;案例3 (返回确切的行数) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final res = await supabase.from(&amp;#39;users&amp;#39;).upsert(&#xD;{&amp;#39;id&amp;#39;: 3, &amp;#39;message&amp;#39;: &amp;#39;foo&amp;#39;, &amp;#39;username&amp;#39;: &amp;#39;supabot&amp;#39;},&#xD;options: const FetchOptions(count: CountOption.</description>
    </item>
    <item>
      <title>Delete 数据</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/delete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/delete/</guid>
      <description>delete()用于在表（table）或视图（view）执行 DELETE 操作。&#xA;delete() 应始终与过滤器（filter）结合使用，以便定位要删除的项。 如果你在使用 delete() 时带有过滤器，并且启用了RLS（行级安全性），则只会删除通过 SELECT 策略可见的行。请注意，默认情况下没有行可见，因此你需要至少有一个 SELECT/ALL 策略来使行可见。 案例教程 link案例1 (删除记录) link&#xD;使用方法&#xD;await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.match({ &amp;#39;id&amp;#39;: 666 });&#xD;案例2 (找回已删除的记录) link&#xD;使用方法&#xD;final List&amp;lt;Map&amp;lt;String,dynamic&amp;gt;&amp;gt; data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.match({ &amp;#39;id&amp;#39;: 666 })&#xD;.select();&#xD;</description>
    </item>
    <item>
      <title>存储程序: rpc()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/rpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/rpc/</guid>
      <description>你可以用&amp;quot;远程程序调用&amp;quot;的方式调用存储程序。&#xA;这是一种高级的说法，即你可以把一些逻辑放入数据库，然后从任何地方调用它。 这在逻辑很少更改的情况下特别有用，比如密码重置和更新等情况。&#xA;案例教程 link案例1 (调用一个没有参数的存储程序) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final data = await supabase&#xD;.rpc(&amp;#39;hello_world&amp;#39;);&#xD;这是一个调用存储过程的示例。&#xA;案例2 (调用一个带参数的存储程序) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.rpc(&amp;#39;echo_city&amp;#39;, params: { &amp;#39;name&amp;#39;: &amp;#39;The Shire&amp;#39; });&#xD;</description>
    </item>
    <item>
      <title>使用过滤器</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/using-filters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/using-filters/</guid>
      <description>过滤器允许你只返回符合某些条件的记录。&#xA;过滤器可以用于select()、update()和delete()查询。&#xA;如果一个数据库函数返回一个表的响应，你也可以应用过滤器。&#xA;案例教程 link案例1 (使用过滤器) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;The Shire&amp;#39;); // Correct&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;The Shire&amp;#39;) // Incorrect&#xD;.select(&amp;#39;name, country_id&amp;#39;);&#xD;过滤器必须在select(), update()、upsert()、delete()和rpc()之后，并在修改器之前应用。&#xA;案例2 (链式过滤) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.gte(&amp;#39;population&amp;#39;, 1000)&#xD;.lt(&amp;#39;population&amp;#39;, 10000)&#xD;过滤器必须在select(), update()、upsert()、delete()和rpc()之后，并在修改器之前应用。&#xA;案例3 (条件链式) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final filterByName = null;&#xD;final filterPopLow = 1000;&#xD;final filterPopHigh = 10000;&#xD;var query = supabase&#xD;.</description>
    </item>
    <item>
      <title>eq()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/eq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/eq/</guid>
      <description>eq()用于匹配列值等于指定值的行。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;The shire&amp;#39;);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;San Francisco&amp;#39;);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;Mordor&amp;#39;);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>neq()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/neq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/neq/</guid>
      <description>neq()用于匹配列值不等于指定值的行。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.neq(&amp;#39;name&amp;#39;, &amp;#39;The shire&amp;#39;);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.neq(&amp;#39;name&amp;#39;, &amp;#39;San Francisco&amp;#39;);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.neq(&amp;#39;name&amp;#39;, &amp;#39;Mordor&amp;#39;);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>gt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/gt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/gt/</guid>
      <description>gt()用于查找所有在所述列（column）上的值大于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.gt(&amp;#39;country_id&amp;#39;, 250);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.gt(&amp;#39;country_id&amp;#39;, 250);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.gt(&amp;#39;country_id&amp;#39;, 250);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.rpc(&amp;#39;echo_all_cities&amp;#39;)&#xD;.</description>
    </item>
    <item>
      <title>gte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/gte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/gte/</guid>
      <description>gte()用于查找所有在所述列（column）上的值大于或等于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.gte(&amp;#39;country_id&amp;#39;, 250);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.gte(&amp;#39;country_id&amp;#39;, 250);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.gte(&amp;#39;country_id&amp;#39;, 250);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.rpc(&amp;#39;echo_all_cities&amp;#39;)&#xD;.</description>
    </item>
    <item>
      <title>lt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/lt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/lt/</guid>
      <description>lt()用于查找所有在所述列（column）上的值小于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.lt(&amp;#39;country_id&amp;#39;, 250);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.lt(&amp;#39;country_id&amp;#39;, 250);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.lt(&amp;#39;country_id&amp;#39;, 250);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.rpc(&amp;#39;echo_all_cities&amp;#39;)&#xD;.</description>
    </item>
    <item>
      <title>lte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/lte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/lte/</guid>
      <description>lte()用于查找所有在所述列（column）上的值小于或等于指定值（value）的记录。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.lte(&amp;#39;country_id&amp;#39;, 250);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.lte(&amp;#39;country_id&amp;#39;, 250);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.lte(&amp;#39;country_id&amp;#39;, 250);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.rpc(&amp;#39;echo_all_cities&amp;#39;)&#xD;.</description>
    </item>
    <item>
      <title>like()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/like/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/like/</guid>
      <description>like()用于查找所有在所述列（column）上的值与提供的 模板（pattern）相符的记录（区分大小写）。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.like(&amp;#39;name&amp;#39;, &amp;#39;%la%&amp;#39;);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.like(&amp;#39;name&amp;#39;, &amp;#39;%la%&amp;#39;);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.like(&amp;#39;name&amp;#39;, &amp;#39;%la%&amp;#39;);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>ilike()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/ilike/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/ilike/</guid>
      <description>ilike()用于查找所有在所述列（column）上的值与提供的 模板（pattern）相符的记录（不区分大小写）。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.ilike(&amp;#39;name&amp;#39;, &amp;#39;%la%&amp;#39;);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.ilike(&amp;#39;name&amp;#39;, &amp;#39;%la%&amp;#39;);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.ilike(&amp;#39;name&amp;#39;, &amp;#39;%la%&amp;#39;);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>is_()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/is_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/is_/</guid>
      <description>is_()用于检查是否完全相等(null, true, false),找到所有在所述列（column）上的值与指定的值（value）完全匹配的记录。&#xA;is_和in_过滤方法的后缀是_，以避免与保留的关键字发生冲突。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.is_(&amp;#39;name&amp;#39;, null);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.is_(&amp;#39;name&amp;#39;, null);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.is_(&amp;#39;name&amp;#39;, null);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>in_()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/in_/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/in_/</guid>
      <description>in_()用于查找所有在指定列（column）上数值存在于指定值列表（arry）中的记录&#xA;is_和in_过滤方法的后缀是_，以避免与保留的关键字发生冲突。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.in_(&amp;#39;name&amp;#39;, [&amp;#39;Rio de Janeiro&amp;#39;, &amp;#39;San Francisco&amp;#39;]);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.in_(&amp;#39;name&amp;#39;, [&amp;#39;Rio de Janeiro&amp;#39;, &amp;#39;San Francisco&amp;#39;]);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.in_(&amp;#39;name&amp;#39;, [&amp;#39;Rio de Janeiro&amp;#39;, &amp;#39;San Francisco&amp;#39;]);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.</description>
    </item>
    <item>
      <title>contains()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/contains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/contains/</guid>
      <description>案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, id, main_exports&amp;#39;)&#xD;.contains(&amp;#39;main_exports&amp;#39;, [&amp;#39;oil&amp;#39;]);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.contains(&amp;#39;main_exports&amp;#39;, [&amp;#39;oil&amp;#39;]);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.contains(&amp;#39;main_exports&amp;#39;, [&amp;#39;oil&amp;#39;]);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.rpc(&amp;#39;echo_all_countries&amp;#39;)&#xD;.</description>
    </item>
    <item>
      <title>containedBy()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/containedby/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/containedby/</guid>
      <description>案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, id, main_exports&amp;#39;)&#xD;.containedBy(&amp;#39;main_exports&amp;#39;, [&amp;#39;cars&amp;#39;, &amp;#39;food&amp;#39;, &amp;#39;machine&amp;#39;]);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.containedBy(&amp;#39;main_exports&amp;#39;, [&amp;#39;orks&amp;#39;, &amp;#39;surveillance&amp;#39;, &amp;#39;evil&amp;#39;]);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.containedBy(&amp;#39;main_exports&amp;#39;, [&amp;#39;cars&amp;#39;, &amp;#39;food&amp;#39;, &amp;#39;machine&amp;#39;]);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>rangeGt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangegt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangegt/</guid>
      <description>案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, id, population_range_millions&amp;#39;)&#xD;.rangeGt(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.rangeGt(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.rangeGt(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>rangeGte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangegte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangegte/</guid>
      <description>案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, id, population_range_millions&amp;#39;)&#xD;.rangeGte(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.rangeGte(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.rangeGte(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>rangeLt()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangelt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangelt/</guid>
      <description>案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, id, population_range_millions&amp;#39;)&#xD;.rangeLt(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.rangeLt(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.rangeLt(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>rangeLte()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangelte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangelte/</guid>
      <description>案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, id, population_range_millions&amp;#39;)&#xD;.rangeLte(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.rangeLte(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.rangeLte(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[150, 250]&amp;#39;);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>rangeAdjacent()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangeadjacent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/rangeadjacent/</guid>
      <description>案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, id, population_range_millions&amp;#39;)&#xD;.rangeAdjacent(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[70, 185]&amp;#39;);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.rangeAdjacent(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[70, 185]&amp;#39;);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.rangeAdjacent(&amp;#39;population_range_millions&amp;#39;, &amp;#39;[70, 185]&amp;#39;);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>overlaps()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/overlaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/overlaps/</guid>
      <description>案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, id, main_exports&amp;#39;)&#xD;.overlaps(&amp;#39;main_exports&amp;#39;, [&amp;#39;computers&amp;#39;, &amp;#39;minerals&amp;#39;]);&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.overlaps(&amp;#39;main_exports&amp;#39;, [&amp;#39;computers&amp;#39;, &amp;#39;minerals&amp;#39;]);&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.delete()&#xD;.overlaps(&amp;#39;main_exports&amp;#39;, [&amp;#39;computers&amp;#39;, &amp;#39;minerals&amp;#39;]);&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>textSearch()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/textsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/textsearch/</guid>
      <description>textSearch()作用是找到所有在指定列上的 tsvector 值与给定的 to_tsquery 查询条件匹配的记录。&#xA;案例教程 link案例1 (文本搜索) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;quotes&amp;#39;)&#xD;.select(&amp;#39;catchphrase&amp;#39;)&#xD;.textSearch(&amp;#39;catchphrase&amp;#39;, &amp;#34;&amp;#39;fat&amp;#39; &amp;amp; &amp;#39;cat&amp;#39;&amp;#34;,&#xD;config: &amp;#39;english&amp;#39;&#xD;);&#xD;案例2 (基本归一化) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;quotes&amp;#39;)&#xD;.select(&amp;#39;catchphrase&amp;#39;)&#xD;.textSearch(&amp;#39;catchphrase&amp;#39;, &amp;#34;&amp;#39;fat&amp;#39; &amp;amp; &amp;#39;cat&amp;#39;&amp;#34;,&#xD;type: TextSearchType.plain,&#xD;config: &amp;#39;english&amp;#39;&#xD;);&#xD;使用 PostgreSQL 的 plainto_tsquery 函数。&#xA;案例3 (全面归一化) link&#xD;使用方法&#xD;注意事项&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;quotes&amp;#39;)&#xD;.select(&amp;#39;catchphrase&amp;#39;)&#xD;.textSearch(&amp;#39;catchphrase&amp;#39;, &amp;#34;&amp;#39;fat&amp;#39; &amp;amp; &amp;#39;cat&amp;#39;&amp;#34;,&#xD;type: TextSearchType.</description>
    </item>
    <item>
      <title>match()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/match/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/match/</guid>
      <description>match()用于查找表（table）中所有列与指定的查询（query）对象相匹配的行。&#xA;案例教程 link案例1 (使用select) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.match({&amp;#39;name&amp;#39;: &amp;#39;Beijing&amp;#39;, &amp;#39;country_id&amp;#39;: 156});&#xD;案例2 (使用update) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.update({ &amp;#39;name&amp;#39;: &amp;#39;Mordor&amp;#39; })&#xD;.match({&amp;#39;name&amp;#39;: &amp;#39;Beijing&amp;#39;, &amp;#39;country_id&amp;#39;: 156});&#xD;案例3 (使用delete) link&#xD;使用方法&#xD;&gt;&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.delete()&#xD;.match({&amp;#39;name&amp;#39;: &amp;#39;Beijing&amp;#39;, &amp;#39;country_id&amp;#39;: 156});&#xD;案例4 (使用rpc) link&#xD;使用方法&#xD;&gt;&#xD;// Only valid if the Stored Procedure returns a table type.&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>.not()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/not/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/not/</guid>
      <description>找到所有不符合过滤器要求的行。&#xA;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.not(&amp;#39;name&amp;#39;, &amp;#39;eq&amp;#39;, &amp;#39;Paris&amp;#39;);&#xD;Notes link .not()希望你使用原始的PostgREST语法作为过滤器的名称和值。&#xA;.not(&amp;#39;name&amp;#39;,&amp;#39;eq&amp;#39;,&amp;#39;Paris&amp;#39;)&#xD;.not(&amp;#39;arraycol&amp;#39;,&amp;#39;cs&amp;#39;,&amp;#39;{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use Postgres array {} for array column and &amp;#39;cs&amp;#39; for contains.&#xD;.not(&amp;#39;rangecol&amp;#39;,&amp;#39;cs&amp;#39;,&amp;#39;(1,2]&amp;#39;) // Use Postgres range syntax for range column.&#xD;.not(&amp;#39;id&amp;#39;,&amp;#39;in&amp;#39;,&amp;#39;(6,7)&amp;#39;) // Use Postgres list () and &amp;#39;in&amp;#39; for in_ filter.&#xD;.not(&amp;#39;id&amp;#39;,&amp;#39;in&amp;#39;,&amp;#39;(${mylist.join(&amp;#39;,&amp;#39;)})&amp;#39;) // You can insert a Dart list array.&#xD;Examples link使用 select() link&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.</description>
    </item>
    <item>
      <title>.or()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/or/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/or/</guid>
      <description>找到所有满足至少一个过滤器的行。&#xA;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.or(&amp;#39;id.eq.20,id.eq.30&amp;#39;);&#xD;Notes link .or()希望你使用原始的PostgREST语法作为过滤器的名称和值。&#xA;.or(&amp;#39;id.in.(6,7),arraycol.cs.{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use Postgres list () and &amp;#39;in&amp;#39; for in_ filter. Array {} and &amp;#39;cs&amp;#39; for contains.&#xD;.or(&amp;#39;id.in.(${mylist.join(&amp;#39;,&amp;#39;)}),arraycol.cs.{${mylistArray.join(&amp;#39;,&amp;#39;)}}&amp;#39;)&#x9;// You can insert a Dart list for list or array column.&#xD;.or(&amp;#39;id.in.(${mylist.join(&amp;#39;,&amp;#39;)}),rangecol.cs.(${mylistRange.join(&amp;#39;,&amp;#39;)}]&amp;#39;)&#x9;// You can insert a Dart list for list or range column.&#xD;Examples link使用 select() link&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.or(&amp;#39;id.eq.20,id.eq.30&amp;#39;);&#xD;使用 or与 and。 link&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>.filter()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/filter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/filter/filter/</guid>
      <description>找到所有column符合过滤器的记录。&#xA;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.filter(&amp;#39;name&amp;#39;, &amp;#39;in&amp;#39;, &amp;#39;(&amp;#34;Paris&amp;#34;,&amp;#34;Tokyo&amp;#34;)&amp;#39;);&#xD;Notes link .filter()希望你使用原始的PostgREST语法来表示过滤器的名称和值，所以它只能作为其他过滤器不工作时的一个转义。 .filter(&amp;#39;arraycol&amp;#39;,&amp;#39;cs&amp;#39;,&amp;#39;{&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;}&amp;#39;) // Use Postgres array {} and &amp;#39;cs&amp;#39; for contains.&#xD;.filter(&amp;#39;rangecol&amp;#39;,&amp;#39;cs&amp;#39;,&amp;#39;(1,2]&amp;#39;) // Use Postgres range syntax for range column.&#xD;.filter(&amp;#39;id&amp;#39;,&amp;#39;in&amp;#39;,&amp;#39;(6,7)&amp;#39;) // Use Postgres list () and &amp;#39;in&amp;#39; for in_ filter.&#xD;.filter(&amp;#39;id&amp;#39;,&amp;#39;cs&amp;#39;,&amp;#39;{${mylist.join(&amp;#39;,&amp;#39;)}}&amp;#39;) // You can insert a Dart array list.&#xD;Examples link使用 select() link&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.filter(&amp;#39;name&amp;#39;, &amp;#39;in&amp;#39;, &amp;#39;(&amp;#34;Paris&amp;#34;,&amp;#34;Tokyo&amp;#34;)&amp;#39;);&#xD;使用 update() link&#xD;final data = await supabase&#xD;.</description>
    </item>
    <item>
      <title>Using Modifiers</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/using-modifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/using-modifiers/</guid>
      <description>过滤器在行的层面上工作&amp;ndash;它们允许你返回只符合某些条件的行，而不改变行的形状。 只符合某些条件的行，而不改变行的形状。 修改器是不符合该定义的一切，允许你 改变响应的格式（例如，返回一个CSV字符串）。&#xA;修改器必须在过滤器之后指定。有些修改器只适用于 一些修改器只适用于返回行的查询（例如，select()或rpc()在一个返回表的函数上 返回表格响应的函数）。</description>
    </item>
    <item>
      <title>order()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/order/</guid>
      <description>用指定的列对结果进行排序。&#xA;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.order(&amp;#39;id&amp;#39;, ascending: false );&#xD;Examples link使用 select() link&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.order(&amp;#39;id&amp;#39;, ascending: false );&#xD;有嵌入式资源 link&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, cities(name)&amp;#39;)&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;United States&amp;#39;)&#xD;.order(&amp;#39;name&amp;#39;, foreignTable: &amp;#39;cities&amp;#39;);&#xD;</description>
    </item>
    <item>
      <title>limit()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/limit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/limit/</guid>
      <description>用指定的计数来限制结果。&#xA;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.limit(1);&#xD;Examples link使用 select() link&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.limit(1);&#xD;有嵌入式资源 link&#xD;final data = await supabase&#xD;.from(&amp;#39;countries&amp;#39;)&#xD;.select(&amp;#39;name, cities(name)&amp;#39;)&#xD;.eq(&amp;#39;name&amp;#39;, &amp;#39;United States&amp;#39;)&#xD;.limit(1, foreignTable: &amp;#39;cities&amp;#39; );&#xD;</description>
    </item>
    <item>
      <title>range()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/range/</guid>
      <description>将结果限制在指定范围内的行，包括在内。&#xA;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.range(0,3);&#xD;Examples link使用 select() link&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.range(0,3);&#xD;</description>
    </item>
    <item>
      <title>single()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/single/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/database/modifier/single/</guid>
      <description>只从结果中检索一条记录。结果必须是一行(例如,使用limit)，否则会导致错误。&#xA;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.single();&#xD;Examples link使用 select() link&#xD;final data = await supabase&#xD;.from(&amp;#39;cities&amp;#39;)&#xD;.select(&amp;#39;name, country_id&amp;#39;)&#xD;.single();&#xD;</description>
    </item>
    <item>
      <title>signUp()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signup/</guid>
      <description>创建一个新的用户。&#xA;final AuthResponse res = await supabase.auth.signUp(&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;);&#xD;final Session? session = res.session;&#xD;final User? user = res.user;&#xD;Notes link 默认情况下，用户在登录前需要验证他们的电子邮件地址。要关闭这个功能，请在你的项目中禁用确认电子邮件。 确认电子邮件决定了用户在注册后是否需要确认他们的电子邮件地址。 如果确认电子邮件被启用，将返回一个用户，但会话为空。 如果确认电子邮件被禁用，则同时返回一个用户&#39;和一个会话`。 当用户确认他们的电子邮件地址时，他们默认会被重定向到SITE_URL。你可以修改你的SITE_URL或在你的项目中添加额外的重定向URL。 如果为一个现有的确认用户调用signUp()。 如果在你的项目中启用了确认邮件，将返回一个混淆的/假的用户对象。 如果确认电子邮件被禁用，将返回错误信息 &amp;ldquo;用户已经注册&amp;rdquo;。 Examples linkSign up. link&#xD;final AuthResponse res = await supabase.auth.signUp(&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;);&#xD;final Session? session = res.session;&#xD;final User? user = res.user;&#xD;与第三方供应商签约。 link如果你使用Flutter，你可以使用supabase_flutter上的signInWithOAuth()`方法与OAuth提供商签约。</description>
    </item>
    <item>
      <title>signInWithPassword()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signinwithpassword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signinwithpassword/</guid>
      <description>使用电子邮件或电话号码与密码登录现有用户。&#xA;final AuthResponse res = await supabase.auth.signInWithPassword(&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;);&#xD;final Session? session = res.session;&#xD;final User? user = res.user;&#xD;Notes link 需要电子邮件和密码或电话号码和密码。 Examples link用电子邮件和密码登录 link&#xD;final AuthResponse res = await supabase.auth.signInWithPassword(&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;);&#xD;final Session? session = res.session;&#xD;final User? user = res.user;&#xD;用电话和密码登录 link&#xD;final AuthResponse res = await supabase.auth.signInWithPassword(&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;password: &amp;#39;example-password&amp;#39;,&#xD;);&#xD;final Session? session = res.session;&#xD;final User? user = res.</description>
    </item>
    <item>
      <title>signInWithOtp()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signinwithotp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signinwithotp/</guid>
      <description>&#xD;await supabase.auth.signInWithOtp(&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;emailRedirectTo: kIsWeb ? null : &amp;#39;io.supabase.flutter://signin-callback/&amp;#39;,&#xD;);&#xD;Notes link 要求提供电子邮件或电话号码。 这种方法用于无密码登录，OTP被发送到用户的电子邮件或电话号码。 如果你使用电子邮件，你可以配置你是否想让用户收到一个魔术链接或OTP。 如果你使用电话，你可以配置你是否希望用户收到OTP。 魔法链接的目标URL是由SITE_URL决定的。你可以修改SITE_URL或在你的项目中添加额外的重定向url。 Examples link用电子邮件登录。 link用户将被发送一封电子邮件，其中包含一个magiclink或OTP或两者。默认情况下，一个用户每60秒只能请求一次OTP。 你可以通过emailRedirectTo和动态链接，使用户在点击魔法链接后回到你的应用程序。&#xA;await supabase.auth.signInWithOtp(&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;emailRedirectTo: kIsWeb ? null : &amp;#39;io.supabase.flutter://signin-callback/&amp;#39;,&#xD;);&#xD;用短信OTP登录。 link用户将被发送一条包含OTP的短信。默认情况下，一个特定的用户只能每60秒请求一次OTP。&#xA;await supabase.auth.signInWithOtp(&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;);&#xD;</description>
    </item>
    <item>
      <title>signInWithOAuth()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signinwithoauth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signinwithoauth/</guid>
      <description>使用第三方OAuth提供商对用户进行签名。&#xA;await supabase.auth.signInWithOAuth(Provider.github);&#xD;Notes link 这种方法用于使用第三方提供商进行登录。 Supabase支持许多不同的第三方提供商。 Examples link使用第三方供应商登录 link&#xD;await supabase.auth.signInWithOAuth(Provider.github);&#xD;使用 redirectTo link指定重定向链接，通过深层链接把用户带回来。 注意，对于Flutter Web，redirectTo应该是空的。&#xA;await supabase.auth.signInWithOAuth(&#xD;Provider.github,&#xD;redirectTo: kIsWeb ? null : &amp;#39;io.supabase.flutter://reset-callback/&amp;#39;,&#xD;);&#xD;使用 scopes link如果你需要OAuth提供商的额外数据，你可以在你的请求中包括一个空格分隔的范围列表，以获得OAuth提供商的令牌。 你可能还需要在提供者的OAuth应用设置中指定范围，这取决于提供者。&#xA;await supabase.auth.signInWithOAuth(&#xD;Provider.github,&#xD;scopes: &amp;#39;repo gist notifications&amp;#39;&#xD;);&#xD;...&#xD;// after user comes back from signin flow&#xD;final Session? session = supabase.auth.currentSession;&#xD;final String? oAuthToken = session?.providerToken;&#xD;</description>
    </item>
    <item>
      <title>signOut()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-signout/</guid>
      <description>退出当前用户，如果有一个登录的用户。&#xA;await supabase.auth.signOut();&#xD;Notes link 为了使用signOut()方法，用户需要先退出。 Examples linkSign out link&#xD;await supabase.auth.signOut();&#xD;</description>
    </item>
    <item>
      <title>verifyOtp()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-verifyotp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-verifyotp/</guid>
      <description>final AuthResponse res = await supabase.auth.verifyOTP(&#xD;type: OtpType.sms,&#xD;token: &amp;#39;111111&amp;#39;,&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;);&#xD;final Session? session = res.session;&#xD;final User? user = res.user;&#xD;Notes link verifyOtp方法接受不同的验证类型。如果使用电话号码，类型可以是sms或phone_change。如果使用的是电子邮件地址，类型可以是下列之一。signup, magiclink, recovery, invite 或 email_change. 使用的验证类型应该根据在verifyOtp之前调用的相应的auth方法来确定，以注册/登录一个用户。 Examples link验证短信一次性密码(OTP) link&#xD;final AuthResponse res = await supabase.auth.verifyOTP(&#xD;type: OtpType.sms,&#xD;token: &amp;#39;111111&amp;#39;,&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;);&#xD;final Session? session = res.session;&#xD;final User? user = res.user;&#xD;验证注册 一次性密码(OTP) link&#xD;final AuthResponse res = await supabase.auth.verifyOTP(&#xD;type: OtpType.signup,&#xD;token: token,&#xD;phone: &amp;#39;&amp;#43;13334445555&amp;#39;,&#xD;);&#xD;final Session?</description>
    </item>
    <item>
      <title>currentSession</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-currentsession/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-currentsession/</guid>
      <description>如果有一个活动的会话，返回会话数据。&#xA;final Session? session = supabase.auth.currentSession;&#xD;Examples link获取会话数据 link&#xD;final Session? session = supabase.auth.currentSession;&#xD;</description>
    </item>
    <item>
      <title>currentUser</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-currentuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-currentuser/</guid>
      <description>返回用户数据，如果有一个登录的用户。&#xA;final User? user = supabase.auth.currentUser;&#xD;Examples link获取登录的用户 link&#xD;final User? user = supabase.auth.currentUser;&#xD;</description>
    </item>
    <item>
      <title>updateUser()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-updateuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-updateuser/</guid>
      <description>更新用户数据，如果有一个登录的用户。&#xA;final UserResponse res = await supabase.auth.updateUser(&#xD;UserAttributes(&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;),&#xD;);&#xD;final User? updatedUser = res.user;&#xD;Notes link 为了使用updateUser()方法，用户需要先登录。 默认情况下，电子邮件更新会向用户的当前和新的电子邮件发送一个确认链接。 要想只向用户的新邮箱发送确认链接，请在你的项目的email auth provider settings中禁用安全的邮件变更。 Examples link更新已认证用户的电子邮件 link向新的电子邮件地址发送一封 &amp;ldquo;确认电子邮件变更 &amp;ldquo;的电子邮件。&#xA;final UserResponse res = await supabase.auth.updateUser(&#xD;UserAttributes(&#xD;email: &amp;#39;example@email.com&amp;#39;,&#xD;),&#xD;);&#xD;final User? updatedUser = res.user;&#xD;更新一个已认证用户的密码 link&#xD;final UserResponse res = await supabase.auth.updateUser(&#xD;UserAttributes(&#xD;password: &amp;#39;new password&amp;#39;,&#xD;),&#xD;);&#xD;final User? updatedUser = res.user;&#xD;更新用户的元数据 link&#xD;final UserResponse res = await supabase.</description>
    </item>
    <item>
      <title>onAuthStateChange()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-onauthstatechange/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-onauthstatechange/</guid>
      <description>每次发生认证事件时都会收到通知。&#xA;final authSubscription = supabase.auth.onAuthStateChange.listen((data) {&#xD;final AuthChangeEvent event = data.event;&#xD;final Session? session = data.session;&#xD;});&#xD;Notes link 认证事件的类型: AuthChangeEvent.passwordRecovery, AuthChangeEvent.signedIn, AuthChangeEvent.signedOut, AuthChangeEvent.tokenRefreshed, AuthChangeEvent.userUpdatedand AuthChangeEvent.userDeleted Examples link监听认证变化 link&#xD;final authSubscription = supabase.auth.onAuthStateChange.listen((data) {&#xD;final AuthChangeEvent event = data.event;&#xD;final Session? session = data.session;&#xD;});&#xD;监听一个特定的事件 link&#xD;final authSubscription = supabase.auth.onAuthStateChange.listen((data) {&#xD;final AuthChangeEvent event = data.event;&#xD;if (event == AuthChangeEvent.signedIn) {&#xD;// handle signIn&#xD;}&#xD;});&#xD;退订自动订阅 link&#xD;final authSubscription = supabase.</description>
    </item>
    <item>
      <title>resetPasswordForEmail()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-resetpasswordforemail/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/auth/auth-resetpasswordforemail/</guid>
      <description>向电子邮件地址发送重置请求。&#xA;redirectTo is used to open the app via deeplink when user opens the password reset email.&#xA;await supabase.auth.resetPasswordForEmail(&#xD;&amp;#39;sample@email.com&amp;#39;,&#xD;redirectTo: kIsWeb ? null : &amp;#39;io.supabase.flutter://reset-callback/&amp;#39;,&#xD;);&#xD;Notes link向一个电子邮件地址发送一个密码重置请求。当用户点击邮件中的重置链接时，他们会被重定向到你的应用程序。提示用户输入新的密码并调用auth.updateUser()。&#xA;await supabase.auth.resetPasswordForEmail(&#xD;&amp;#39;sample@email.com&amp;#39;,&#xD;redirectTo: kIsWeb ? null : &amp;#39;io.supabase.flutter://reset-callback/&amp;#39;,&#xD;);&#xD;Examples link重置Flutter的密码 linkredirectTo is used to open the app via deeplink when user opens the password reset email.&#xA;await supabase.auth.resetPasswordForEmail(&#xD;&amp;#39;sample@email.com&amp;#39;,&#xD;redirectTo: kIsWeb ? null : &amp;#39;io.supabase.flutter://reset-callback/&amp;#39;,&#xD;);&#xD;</description>
    </item>
    <item>
      <title>invoke()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/function/invoke/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/function/invoke/</guid>
      <description>调用一个Supabase函数。请参阅指南，了解关于编写函数的详细信息。&#xA;final res = await supabase.functions.invoke(&amp;#39;hello&amp;#39;, body: {&amp;#39;foo&amp;#39;: &amp;#39;baa&amp;#39;});&#xD;final data = res.data;&#xD;Notes link 需要一个授权标头。 调用参数通常符合Fetch API规范。 Examples link基本调用。 link&#xD;final res = await supabase.functions.invoke(&amp;#39;hello&amp;#39;, body: {&amp;#39;foo&amp;#39;: &amp;#39;baa&amp;#39;});&#xD;final data = res.data;&#xD;指定响应类型。 link默认情况下，invoke()将把响应解析为JSON。你可以用以下格式解析响应。json, blob, text, 和arrayBuffer.&#xA;final res = await supabase.functions.invoke(&#xD;&amp;#39;hello&amp;#39;,&#xD;body: {&amp;#39;foo&amp;#39;: &amp;#39;baa&amp;#39;},&#xD;responseType: ResponseType.text,&#xD;);&#xD;final data = res.data;&#xD;解析自定义头信息。 link任何 headers信息都将被传递给该函数。一个常见的模式是将登录用户的JWT令牌作为授权标头传递。&#xA;final res = await supabase.functions.invoke(&#xD;&amp;#39;hello&amp;#39;,&#xD;body: {&amp;#39;foo&amp;#39;: &amp;#39;baa&amp;#39;},&#xD;headers: {&#xD;&amp;#39;Authorization&amp;#39;: &amp;#39;Bearer ${supabase.</description>
    </item>
    <item>
      <title>stream()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/realtime/stream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/realtime/stream/</guid>
      <description>通知被查询表的数据。&#xA;supabase.from(&amp;#39;countries&amp;#39;)&#xD;.stream(primaryKey: [&amp;#39;id&amp;#39;])&#xD;.listen((List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; data) {&#xD;// Do something awesome with the data&#xD;});&#xD;Notes link stream()通过结合Postgrest和Realtime，将初始数据以及数据库上的任何进一步变化作为List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;的Stream发出。 接受一个主键列的列表作为其参数。 Examples link监听一个特定的表 link&#xD;supabase.from(&amp;#39;countries&amp;#39;)&#xD;.stream(primaryKey: [&amp;#39;id&amp;#39;])&#xD;.listen((List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; data) {&#xD;// Do something awesome with the data&#xD;});&#xD;监听表格中的特定行数 link你可以使用{table}:{col}=eq.{val}的格式来监听个别行，其中{col}是列名，{val}是你想要匹配的值。 这种语法与你在Realtime中过滤数据的方式相同&#xA;supabase.from(&amp;#39;countries&amp;#39;)&#xD;.stream(primaryKey: [&amp;#39;id&amp;#39;])&#xD;.eq(&amp;#39;id&amp;#39;, &amp;#39;120&amp;#39;)&#xD;.listen((List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; data) {&#xD;// Do something awesome with the data&#xD;});&#xD;使用 order() link&#xD;supabase.from(&amp;#39;countries&amp;#39;)&#xD;.stream(primaryKey: [&amp;#39;id&amp;#39;])&#xD;.order(&amp;#39;name&amp;#39;, ascending: true)&#xD;.listen((List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; data) {&#xD;// Do something awesome with the data&#xD;});&#xD;使用 limit() link&#xD;supabase.</description>
    </item>
    <item>
      <title>on().subscribe()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/realtime/subscribe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/realtime/subscribe/</guid>
      <description>订阅你的数据库中的实时变化。&#xA;supabase.channel(&amp;#39;*&amp;#39;).on(&#xD;RealtimeListenTypes.postgresChanges,&#xD;ChannelFilter(event: &amp;#39;*&amp;#39;, schema: &amp;#39;*&amp;#39;),&#xD;(payload, [ref]) {&#xD;print(&amp;#39;Change received: ${payload.toString()}&amp;#39;);&#xD;},&#xD;).subscribe();&#xD;Notes link 为了提高数据库性能和安全性，新项目的实时性默认是禁用的。你可以通过管理复制打开它。 如果你想在更新和删除时接收 &amp;ldquo;以前的&amp;quot;数据，你需要将REPLICA IDENTITY设置为FULL，像这样。ALTER TABLE your_table REPLICA IDENTITY FULL;。 Examples link监听所有的数据库变化 link&#xD;supabase.channel(&amp;#39;*&amp;#39;).on(&#xD;RealtimeListenTypes.postgresChanges,&#xD;ChannelFilter(event: &amp;#39;*&amp;#39;, schema: &amp;#39;*&amp;#39;),&#xD;(payload, [ref]) {&#xD;print(&amp;#39;Change received: ${payload.toString()}&amp;#39;);&#xD;},&#xD;).subscribe();&#xD;监听一个特定的表 link&#xD;supabase.channel(&amp;#39;public:countries&amp;#39;).on(&#xD;RealtimeListenTypes.postgresChanges,&#xD;ChannelFilter(event: &amp;#39;*&amp;#39;, schema: &amp;#39;public&amp;#39;, table: &amp;#39;countries&amp;#39;),&#xD;(payload, [ref]) {&#xD;print(&amp;#39;Change received: ${payload.toString()}&amp;#39;);&#xD;},&#xD;).subscribe();&#xD;监听插入 link&#xD;supabase.channel(&amp;#39;public:countries&amp;#39;).on(&#xD;RealtimeListenTypes.postgresChanges,&#xD;ChannelFilter(event: &amp;#39;INSERT&amp;#39;, schema: &amp;#39;public&amp;#39;, table: &amp;#39;countries&amp;#39;),&#xD;(payload, [ref]) {&#xD;print(&amp;#39;Change received: ${payload.</description>
    </item>
    <item>
      <title>removeChannel()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/realtime/removechannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/realtime/removechannel/</guid>
      <description>取消订阅并从Realtime客户端删除Realtime频道。&#xA;final status = await supabase.removeChannel(channel);&#xD;Notes link 如果你在监听Postgres的变化，删除一个通道是保持你项目的Realtime服务以及你的数据库性能的一个好方法。Supabase会在客户端断开连接后的30秒内自动处理清理工作，但未使用的通道可能会因为更多的客户端同时订阅而导致性能下降。 Examples link删除一个通道 link&#xD;final status = await supabase.removeChannel(channel);&#xD;</description>
    </item>
    <item>
      <title>removeAllChannels()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/realtime/removeallchannels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/realtime/removeallchannels/</guid>
      <description>取消订阅并从Realtime客户端删除所有Realtime频道。&#xA;final statuses = await supabase.removeAllChannels();&#xD;Notes link 如果你在监听Postgres的变化，移除通道是保持你项目的Realtime服务以及数据库性能的一个好方法。Supabase会在客户端断开连接后的30秒内自动处理清理工作，但未使用的通道可能会因为更多的客户端同时订阅而导致性能下降。 Examples link删除所有通道 link&#xD;final statuses = await supabase.removeAllChannels();&#xD;</description>
    </item>
    <item>
      <title>getChannels()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/realtime/getchannels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/realtime/getchannels/</guid>
      <description>返回所有的Realtime通道。&#xA;final channels = supabase.getChannels();&#xD;Examples link获取所有通道 link&#xD;final channels = supabase.getChannels();&#xD;</description>
    </item>
    <item>
      <title>createBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-createbucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-createbucket/</guid>
      <description>创建一个新的存储桶&#xA;final String bucketId = await supabase&#xD;.storage&#xD;.createBucket(&amp;#39;avatars&amp;#39;);&#xD;Notes link 需要的政策权限。 buckets的权限。insert的权限 objects的权限: 没有 Examples link创建桶 link&#xD;final String bucketId = await supabase&#xD;.storage&#xD;.createBucket(&amp;#39;avatars&amp;#39;);&#xD;</description>
    </item>
    <item>
      <title>getBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-getbucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-getbucket/</guid>
      <description>检索现有存储桶的详细信息。&#xA;final Bucket bucket = await supabase&#xD;.storage&#xD;.getBucket(&amp;#39;avatars&amp;#39;);&#xD;Notes link 需要的政策权限。 buckets的权限。select 的权限 objects权限: 无 Examples link获取桶 link&#xD;final Bucket bucket = await supabase&#xD;.storage&#xD;.getBucket(&amp;#39;avatars&amp;#39;);&#xD;</description>
    </item>
    <item>
      <title>listBuckets()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-listbuckets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-listbuckets/</guid>
      <description>检索一个现有产品中所有存储桶的详细信息。&#xA;final List&amp;lt;Bucket&amp;gt; buckets = await supabase&#xD;.storage&#xD;.listBuckets();&#xD;Notes link 需要的政策权限。 buckets的权限。select的权限 objects权限: 无 Examples link列表中的桶 link&#xD;final List&amp;lt;Bucket&amp;gt; buckets = await supabase&#xD;.storage&#xD;.listBuckets();&#xD;</description>
    </item>
    <item>
      <title>updateBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-updatebucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-updatebucket/</guid>
      <description>更新一个新的存储桶&#xA;final res = await supabase&#xD;.storage&#xD;.updateBucket(&amp;#39;avatars&amp;#39;, const BucketOptions(public: false));&#xD;Notes link 需要的政策权限。 buckets的权限。update的权限 objects 的权限: 没有 Examples link更新桶 link&#xD;final res = await supabase&#xD;.storage&#xD;.updateBucket(&amp;#39;avatars&amp;#39;, const BucketOptions(public: false));&#xD;</description>
    </item>
    <item>
      <title>deleteBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-deletebucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-deletebucket/</guid>
      <description>删除一个现有的桶。一个桶不能在其内部存在对象的情况下被删除。你必须首先empty()该桶。&#xA;final String result = await supabase&#xD;.storage&#xD;.deleteBucket(&amp;#39;avatars&amp;#39;);&#xD;Notes link 需要的政策权限。 buckets的权限。select and delete。 objects的权限: 没有 Examples link删除桶 link&#xD;final String result = await supabase&#xD;.storage&#xD;.deleteBucket(&amp;#39;avatars&amp;#39;);&#xD;</description>
    </item>
    <item>
      <title>emptyBucket()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-emptybucket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-emptybucket/</guid>
      <description>删除单个桶内的所有对象。&#xA;final String result = await supabase&#xD;.storage&#xD;.emptyBucket(&amp;#39;avatars&amp;#39;);&#xD;Notes link 需要的政策权限。 buckets的权限。 select 的权限 objects的权限: select和delete的权限 Examples link清空存储桶 link&#xD;final String result = await supabase&#xD;.storage&#xD;.emptyBucket(&amp;#39;avatars&amp;#39;);&#xD;</description>
    </item>
    <item>
      <title>from.upload()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-upload/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-upload/</guid>
      <description>将一个文件上传到一个现有的桶。&#xA;final avatarFile = File(&amp;#39;path/to/file&amp;#39;);&#xD;final String path = await supabase.storage.from(&amp;#39;avatars&amp;#39;).upload(&#xD;&amp;#39;public/avatar1.png&amp;#39;,&#xD;avatarFile,&#xD;fileOptions: const FileOptions(cacheControl: &amp;#39;3600&amp;#39;, upsert: false),&#xD;);&#xD;Notes link 需要的政策权限。 buckets权限: 无 objects的权限: insert Examples link上传文件 link&#xD;final avatarFile = File(&amp;#39;path/to/file&amp;#39;);&#xD;final String path = await supabase.storage.from(&amp;#39;avatars&amp;#39;).upload(&#xD;&amp;#39;public/avatar1.png&amp;#39;,&#xD;avatarFile,&#xD;fileOptions: const FileOptions(cacheControl: &amp;#39;3600&amp;#39;, upsert: false),&#xD;);&#xD;</description>
    </item>
    <item>
      <title>from.download()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-download/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-download/</guid>
      <description>下载文件&#xA;final Uint8List file = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.download(&amp;#39;avatar1.png&amp;#39;);&#xD;Notes link 需要的政策权限。 buckets权限: 无 objects的权限: select Examples link下载文件 link&#xD;final Uint8List file = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.download(&amp;#39;avatar1.png&amp;#39;);&#xD;</description>
    </item>
    <item>
      <title>from.list()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-list/</guid>
      <description>列出一个桶内的所有文件。&#xA;final List&amp;lt;FileObject&amp;gt; objects = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.list();&#xD;Notes link 需要的政策权限。 buckets权限: 无 objects的权限: select Examples link在一个桶中列出文件 link&#xD;final List&amp;lt;FileObject&amp;gt; objects = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.list();&#xD;</description>
    </item>
    <item>
      <title>from.update()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-update/</guid>
      <description>用一个新的文件替换指定路径下的一个现有文件。&#xA;final avatarFile = File(&amp;#39;path/to/local/file&amp;#39;);&#xD;final String path = await supabase.storage.from(&amp;#39;avatars&amp;#39;).update(&#xD;&amp;#39;public/avatar1.png&amp;#39;,&#xD;avatarFile,&#xD;fileOptions: const FileOptions(cacheControl: &amp;#39;3600&amp;#39;, upsert: false),&#xD;);&#xD;Notes link 需要的政策权限。 buckets权限: 无 objects 的权限: update and select Examples link更新文件 link&#xD;final avatarFile = File(&amp;#39;path/to/local/file&amp;#39;);&#xD;final String path = await supabase.storage.from(&amp;#39;avatars&amp;#39;).update(&#xD;&amp;#39;public/avatar1.png&amp;#39;,&#xD;avatarFile,&#xD;fileOptions: const FileOptions(cacheControl: &amp;#39;3600&amp;#39;, upsert: false),&#xD;);&#xD;</description>
    </item>
    <item>
      <title>from.move()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-move/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-move/</guid>
      <description>移动一个现有的文件，同时也可以选择重命名。&#xA;final String result = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.move(&amp;#39;public/avatar1.png&amp;#39;, &amp;#39;private/avatar2.png&amp;#39;);&#xD;Notes link 需要的政策权限。 buckets权限: 无 objects的权限: update和 select的权限 Examples link移动文件 link&#xD;final String result = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.move(&amp;#39;public/avatar1.png&amp;#39;, &amp;#39;private/avatar2.png&amp;#39;);&#xD;</description>
    </item>
    <item>
      <title>from.remove()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-remove/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-remove/</guid>
      <description>删除同一桶内的文件&#xA;final List&amp;lt;FileObject&amp;gt; objects = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.remove([&amp;#39;avatar1.png&amp;#39;]);&#xD;Notes link 需要的政策权限。 buckets权限: 无 objects的权限: delete和 select权限 Examples link删除文件 link&#xD;final List&amp;lt;FileObject&amp;gt; objects = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.remove([&amp;#39;avatar1.png&amp;#39;]);&#xD;</description>
    </item>
    <item>
      <title>from.createSignedUrl()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-createsignedurl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-createsignedurl/</guid>
      <description>创建签名的网址，下载文件而不需要权限。这个URL可以在设定的秒数内有效。&#xA;final String signedUrl = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrl(&amp;#39;avatar1.png&amp;#39;, 60);&#xD;Notes link 需要的政策权限。 buckets权限: 无 objects的权限: select Examples link创建签名的URL link&#xD;final String signedUrl = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrl(&amp;#39;avatar1.png&amp;#39;, 60);&#xD;</description>
    </item>
    <item>
      <title>from.createSignedUrls()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-createsignedurls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-createsignedurls/</guid>
      <description>&#xD;final List&amp;lt;String&amp;gt; signedUrls = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrls([&amp;#39;folder/avatar1.png&amp;#39;, &amp;#39;folder/avatar2.png&amp;#39;], 60);&#xD;Notes link 需要RLS策略权限。 buckets表的权限: 没有 objects表的权限: select. 请参考存储指南中关于访问控制的工作方法 Examples link创建签名的URL link&#xD;final List&amp;lt;String&amp;gt; signedUrls = await supabase&#xD;.storage&#xD;.from(&amp;#39;avatars&amp;#39;)&#xD;.createSignedUrls([&amp;#39;folder/avatar1.png&amp;#39;, &amp;#39;folder/avatar2.png&amp;#39;], 60);&#xD;</description>
    </item>
    <item>
      <title>from.getPublicUrl()</title>
      <link>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-getpublicurl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/sdkdocs/dart/storage/storage-from-getpublicurl/</guid>
      <description>检索公共资源库中资产的URL&#xA;final String publicUrl = supabase&#xD;.storage&#xD;.from(&amp;#39;public-bucket&amp;#39;)&#xD;.getPublicUrl(&amp;#39;avatar1.png&amp;#39;);&#xD;Notes link 水桶需要被设置为公开，可以通过updateBucket()或通过进入app.supabase.com的存储，点击水桶上的溢出菜单并选择 &amp;ldquo;Make public&amp;rdquo; 需要的策略权限。 buckets权限: 无 objects权限: 无 Examples link返回公共桶中资产的URL。 link&#xD;final String publicUrl = supabase&#xD;.storage&#xD;.from(&amp;#39;public-bucket&amp;#39;)&#xD;.getPublicUrl(&amp;#39;avatar1.png&amp;#39;);&#xD;</description>
    </item>
    <item>
      <title>Super课表小程序</title>
      <link>http://localhost:1313/docs/app/example/wechat/timetable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/example/wechat/timetable/</guid>
      <description>此示例提供了使用 MemFire Cloud 构建一个课表的小程序的步骤。小程序用到的MemFire Cloud的功能包括：&#xA;云数据库：存储小程序数据表的信息。&#xA;用户验证：小程序使用MemFire Cloud提供的用户认证的API接口，快速完成用户注册登录操作。&#xA;对象存储：存储小程序的注册用户上传的头像。&#xA;行级安全策略：采用RLS策略来限制用户访问行为，用户可以修改个人信息，上传个人头像。&#xA;即时API：创建数据表时会自动生成 API。&#xA;创建应用 link目的：通过创建的一个MemFire Cloud应用来获得数据库、对象存储等一系列资源，并将获得该应用专属的API访问链接和访问密钥，用户可以轻松的调用API接口与以上资源进行交互。&#xA;登录https://cloud.MemFiredb.com/auth/login, 在“我的应用”页面创建一个新应用&#xA;创建数据表 link点击进入应用详情页面，在“数据表”页面可视化建表。&#xA;1.创建school表 link在数据表页面，点击“新建数据表”，创建school表。school表主要记录学校信息，表结构字段如下： 名称 类型 描述 id int8 主键，自增，唯一标识ID schoolName text 学校名称（唯一） updated_at timeatamptz 修改时间 建表页面配置：&#xA;数据表创建完后可在school表中手动插入几条学校信息数据 ，如下图。&#xA;sql操作如下:&#xA;CREATE TABLE &amp;#34;public&amp;#34;.&amp;#34;school&amp;#34; ( &amp;#34;id&amp;#34; BIGINT NOT NULL,&#xD;&amp;#34;updated_at&amp;#34; TIMESTAMP WITH TIME ZONE NOT NULL,&#xD;&amp;#34;schoolName&amp;#34; TEXT NOT NULL,&#xD;CONSTRAINT &amp;#34;school_pkey&amp;#34; PRIMARY KEY (&amp;#34;id&amp;#34;),&#xD;CONSTRAINT &amp;#34;school_schoolName_key&amp;#34; UNIQUE (&amp;#34;schoolName&amp;#34;)&#xD;);&#xD;INSERT INTO &amp;#34;public&amp;#34;.&amp;#34;school&amp;#34; (&amp;#34;id&amp;#34;, &amp;#34;updated_at&amp;#34;, &amp;#34;schoolName&amp;#34;) VALUES (&amp;#39;1&amp;#39;, &amp;#39;2022-08-12 18:43:53.</description>
    </item>
    <item>
      <title>BBS论坛小程序</title>
      <link>http://localhost:1313/docs/app/example/wechat/hellobbs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/example/wechat/hellobbs/</guid>
      <description>helloBBS是一个发布个人心情，查看别人发表的论坛，可以评论回复点赞的论坛小程序。论坛小程序后端服务使用了MemFire Cloud，其中使用到的MemFire Cloud功能包括：&#xA;云数据库：存储论坛小程序数据表的信息。&#xA;用户验证：论坛小程序使用MemFire Cloud提供的用户认证的API接口，快速完成用户注册登录操作。&#xA;即时API：创建数据表时会自动生成 API。&#xA;对象存储：存储用户发布帖子中的图片。&#xA;创建应用 link目的：通过创建的一个MemFire Cloud应用来获得数据库、对象存储等一系列资源，并将获得该应用专属的API访问链接和访问密钥，用户可以轻松的调用API接口与以上资源进行交互。&#xA;登录https://cloud.MemFiredb.com/auth/login， 在“我的应用”页面创建一个新应用&#xA;创建数据表 link第一种：点击进入应用详情页面，在“数据表”页面可视化建表。&#xA;第二种：在首页的数据库管理找到该应用的数据库的&amp;quot;SQL查询&amp;quot;，用MemFire Cloud 自带的sql编辑器进行建表。&#xA;1.创建post_list表 link在数据表页面，点击“新建数据表”，创建post_list表。post_list表主要记录发表的帖子的列表，表结构字段如下： 名称 类型 描述 id int8 主键，自增，唯一标识ID userName text 用户名 times timetamptz 创建时间 content text 内容 avatar text 头像资料 content_imgs text 发表的图片资源 tag_val text 帖子类型 建表页面配置：&#xA;sql操作如下:&#xA;CREATE TABLE &amp;#34;public&amp;#34;.&amp;#34;post_list&amp;#34; ( &amp;#34;id&amp;#34; SERIAL,&#xD;&amp;#34;times&amp;#34; TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT &amp;#39;2022-09-20 11:10:55.482198&amp;#43;08&amp;#39;::timestamp with time zone ,&#xD;&amp;#34;userName&amp;#34; TEXT NOT NULL,&#xD;&amp;#34;content&amp;#34; TEXT NOT NULL,&#xD;&amp;#34;avatar&amp;#34; TEXT NULL,&#xD;&amp;#34;content_imgs&amp;#34; TEXT NULL,&#xD;&amp;#34;tag_val&amp;#34; TEXT NULL,&#xD;CONSTRAINT &amp;#34;post_list_pkey&amp;#34; PRIMARY KEY (&amp;#34;id&amp;#34;)&#xD;);&#xD;2.</description>
    </item>
    <item>
      <title>别踩白块游戏小程序</title>
      <link>http://localhost:1313/docs/app/example/wechat/notclickwhite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/example/wechat/notclickwhite/</guid>
      <description>“踩白块会输”是一个简单的微信小程序游戏，灵感来自当年火热的别踩白块游戏，程序内分成三个模块：手残模式、经典模式和极速模式，分别对应由易到难的三种玩法，可以查看游戏排名。动画效果采用JS实现，小程序后端服务使用了MemFire Cloud，其中使用到的MemFire Cloud功能包括：&#xA;云数据库：存储小程序数据表的信息。&#xA;用户验证：小程序使用MemFire Cloud提供的用户认证的API接口，快速完成用户注册登录操作。&#xA;即时API：创建数据表时会自动生成 API。&#xA;创建应用 link目的：通过创建的一个MemFire Cloud应用来获得数据库、对象存储等一系列资源，并将获得该应用专属的API访问链接和访问密钥，用户可以轻松的调用API接口与以上资源进行交互。&#xA;登录https://cloud.MemFiredb.com/auth/login， 在“我的应用”页面创建一个新应用&#xA;创建数据表 link点击进入应用详情页面，在“数据表”页面可视化建表。&#xA;1.创建gamer表 link在数据表页面，点击“新建数据表”，创建gamer表。gamer表主要记录游戏玩家信息和各个游戏模式的最高分信息，表结构字段如下： 名称 类型 描述 id int8 主键，自增，唯一标识ID user_name text 用户名（唯一） created_at timetamptz 创建时间 get_started_highscore int8 手残模式最高分数（可空） classic_highscore int8 经典模式最高分数（可空） extreme_speed_highscore int8 极速模式最高分数（可空） 建表页面配置：&#xA;sql操作如下:&#xA;CREATE TABLE &amp;#34;public&amp;#34;.&amp;#34;gamer&amp;#34; ( &amp;#34;id&amp;#34; SERIAL,&#xD;&amp;#34;created_at&amp;#34; TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT &amp;#39;2022-09-16 15:23:36.89768&amp;#43;08&amp;#39;::timestamp with time zone ,&#xD;&amp;#34;user_name&amp;#34; TEXT NOT NULL,&#xD;&amp;#34;get_started_highscore&amp;#34; BIGINT NULL,&#xD;&amp;#34;classic_highscore&amp;#34; BIGINT NULL,&#xD;&amp;#34;extreme_speed_highscore&amp;#34; BIGINT NULL,&#xD;CONSTRAINT &amp;#34;gamer_pkey&amp;#34; PRIMARY KEY (&amp;#34;id&amp;#34;)&#xD;);&#xD;2.</description>
    </item>
    <item>
      <title>微信小程序聊天室</title>
      <link>http://localhost:1313/docs/app/example/wechat/wechatroom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/example/wechat/wechatroom/</guid>
      <description>本示例是一个可以实现多人互动的角色扮演聊天室的微信小程序，小程序后端服务使用了MemFire Cloud，其中使用到的MemFire Cloud功能包括：&#xA;其中使用到的MemFire Cloud功能包括：&#xA;云数据库：存储聊天室小程序数据表的信息。 即时API：创建数据表时会自动生成 API。 对象存储：存储用户发布帖子中的图片。 Realtime：轻松构建任何类型的实时应用程序 创建应用 link目的：通过创建的一个MemFire Cloud应用来获得数据库、对象存储等一系列资源，并将获得该应用专属的API访问链接和访问密钥，用户可以轻松的调用API接口与以上资源进行交互。&#xA;登录MemFire Cloud， 在“我的应用”页面创建一个新应用&#xA;创建数据表 link创建messages表 link建表操作如下：&#xA;在“表编辑器”页面，点击“新建表”，创建messages表。messages表主要记录用户发送的每一条信息，表结构字段如下： 名称 类型 描述 id bigint 主键，自动为列分配一个连续的唯一编号，唯一标识ID username varchar 用户名 bgColor varchar 头像背景颜色 created_at timetamptz 创建时间 text text 消息 sql建表语句&#xA;CREATE TABLE messages (&#xD;id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,&#xD;username VARCHAR NOT NULL,&#xD;bgColor VARCHAR NOT NULL,&#xD;text TEXT NOT NULL,&#xD;timestamp timestamp default now() NOT NULL&#xD;);&#xD;创建策略 link接下来，需要给messages表创建两条策略，分别是允许所有用户可以查询和插入messages表数据，在“SQL执行器”页面，点击“新查询”按钮，新建一个SQL Query，执行以下操作：</description>
    </item>
    <item>
      <title>Posts社交网络论坛</title>
      <link>http://localhost:1313/docs/app/example/web/postsforum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/example/web/postsforum/</guid>
      <description>MemFire Cloud是一款提供云数据库，用户可以创建云数据库，并对数据库进行管理，还可以对数据库进行备份操作。它还提供后端即服务，用户可以在1分钟内新建一个应用，使用自动生成的API和SDK，访问云数据库、对象存储、用户认证与授权等功能，可专注于编写前端应用程序代码，加速WEB或APP应用开发。&#xA;本篇文章将会教大家手把手使用MemFire Cloud做一个Posts社交网络论坛应用。我们基于Posts社交网络论坛应用做了一个详细的教程，来讲一讲在通过MemFire Cloud开发Posts社交网络论坛应用的开发步骤及注意事项，希望能真正解决用户使用MemFire Cloud过程中遇到的问题和提供一些应用实现的小技巧。&#xA;开发前需要知道的一些事 link应用介绍&#xA;一个开放的社交网络论坛，任何人都可以在这里分享他们的想法和意见。&#xA;应用基础&#xA;Posts社交网络论坛是基于supabase官网的一个todo-list应用示例为基础，在这个基础上进行修改，删除，增加一些代码逻辑及功能的应用。&#xA;开发条件&#xA;您需要对vue3及ts有一定的了解；&#xA;您需要对sql语法有一定的了解；&#xA;开发依赖&#xA;&amp;ldquo;@supabase/supabase-js&amp;rdquo;: &amp;ldquo;^1.1.2&amp;rdquo;&#xA;&amp;ldquo;vue&amp;rdquo;: &amp;ldquo;^3.0.0&amp;rdquo;&#xA;“node.js”:&amp;ldquo;14.19.0&amp;rdquo;&#xA;&amp;ldquo;npm&amp;rdquo;:&amp;ldquo;6.14.16&amp;rdquo;&#xA;1.准备工作 link创建应用&#xA;登录https://cloud.memfiredb.com 创建应用，打开应用后，查看并获取服务地址以及token信息&#xA;创建应用的一步很关键，我们的posts应用就是通过在这里创建的应用来获得数据库、对象存储等一系列资源，并将获得该应用专属的API访问链接和访问密钥，用户可以轻松的与以上资源进行交互。想知道关于应用更详细的内容请查看查看文档&#xA;进入应用，我们在这里可以看到，Anon public是客户端API密钥。它允许“匿名访问”您的数据库，直到用户登录。登录后，密钥将切换到用户自己的登录令牌。这将为数据启用行级安全性。&#xA;注意：service_role secret可以绕过任何安全策略完全访问您的数据。这些密钥必须保密，并且要在服务器环境中使用，决不能在客户端或浏览器上使用。&#xA;在后续示例代码中，需要提供supabaseUrl和supabaseKey。&#xA;supabaseUrl就是上图的网址链接，supabaseKey就是Anon API密钥&#xA;想知道关于应用的连接更详细的内容请查看文档&#xA;下载代码&#xA;todo-list模板代码（需要下载,选择项目为supabase /examples/vue3-ts-todo-list）：&#xA;git clone https://gitee.com/memfiredb/supabase&#xA;Posts最终代码&#xA;git clone https://github.com/LucaRao/memfire-post.git&#xA;2.修改项目名称 link将项目名vue3-ts-todo-list改为Posts&#xA;3.配置访问密钥 link每个Supabase项目都有一个独特的API URL。您的 API 在一个 API 网关的保护下，每次请求都需要一个 API 密钥。&#xA;将上一步中获取的anon public和网址分别设置到supabaseUrl和supabaseKey中&#xA;（1）将根目录下的.env.local.example改为.env.local&#xA;（2）supabaseUrl和supabaseKey分别赋值给VUE_APP_SUPABASE_URL和VUE_APP_SUPABASE_KEY&#xA;4.表结构初始化 link接下来我们需要创建数据表，posts表是用来存储用户论坛评论的数据，likes表用来存储用户点赞的某条评论的数据。&#xA;数据表结构：&#xA;posts（论坛评论列表） 名称 类型 描述 id in8 主键，自增，每条评论的唯一标识ID task text 评论 email text 用户名 created_at timestamptz 日期，可为空 likes（点赞表） 名称 类型 描述 id int8 主键，自增，每条评论的唯一标识ID email_name text 用户名 post_id int8 每条评论的唯一id created_at timestamptz 日期，可为空 sql初始化语句</description>
    </item>
    <item>
      <title>Discussbase论坛</title>
      <link>http://localhost:1313/docs/app/example/web/discussbaseforum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/example/web/discussbaseforum/</guid>
      <description>Discussbase是一个开源的简单论坛。使用“技术栈”（MemFire Cloud 、 Nextjs）构建和运行。&#xA;下载代码 link执行如下命令，获取Discussbase论坛应用的代码。&#xA;git clone https://github.com/LucaRao/discussbase&#xA;创建应用 link下载Discussbase代码后，登录memfire cloud,创建一个MemFire Cloud应用，为Discussbase提供后端服务，包括云数据库、对象存储、授权认证等。&#xA;在应用-&amp;gt;概括页面，获取服务地址以及token信息。&#xA;Anon（公开）密钥是客户端API密钥。它允许“匿名访问”您的数据库，直到用户登录。登录后，密钥将切换到用户自己的登录令牌。这将为数据启用行级安全性。&#xA;注意：service_role（秘密）密钥可以绕过任何安全策略完全访问您的数据。这些密钥必须保密，并且要在服务器环境中使用，决不能在客户端或浏览器上使用。 在后续示例代码中，需要提供supabaseUrl和supabaseKey。&#xA;配置访问密钥 link在根目录下创建新的 .env文件，在 .env 中添加您的 MemFire Cloud 配置；将上一步中获取的Anon（公开）密钥、service_role和网址、以及JWT密钥分别设置到该文件中，如下图所示：&#xA;NEXT_PUBLIC_SUPABASE_URL=&#xD;NEXT_PUBLIC_SUPABASE_ANON_KEY=&#xD;JWT_SECRET=&#xD;NEXT_PUBLIC_SUPABASE_SERVICE_KEY=&#xD;如图样例所示。&#xA;创建数据表 link接下来我们会创建三张表，包括&#xA;profiles (用户信息表)&#xA;posts (帖子)&#xA;replies (回复信息表)&#xA;创建profiles表 link你可以在MemFire Cloud的Discussbase_db的SQL编辑器运行如下SQL语法，涉及操作包括：&#xA;1、创建profiles表, 开启Profiles的RLS数据安全访问规则;&#xA;其中profiles表字段id和auth.users表中的uuid外键关联。&#xA;相关操作的SQL命令：&#xA;-- Create a table for Public Profiles&#xD;create table profiles (&#xD;id uuid references auth.users not null,&#xD;updated_at timestamp with time zone,&#xD;username text unique not null,&#xD;avatar_url text,&#xD;website text,&#xD;point INTEGER DEFAULT 0,&#xD;primary key (id),&#xD;unique(username),&#xD;constraint username_length check (char_length(username) &amp;gt;= 3)&#xD;);&#xD;alter table profiles enable row level security;&#xD;2、允许每个用户可以查看公共的个人信息资料, 仅允许用户增删改查本人的个人资料信息；</description>
    </item>
    <item>
      <title>实时游戏场</title>
      <link>http://localhost:1313/docs/app/example/web/playground/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/app/example/web/playground/</guid>
      <description>Realtime 游戏场是一个可以多人互动，鼠标位置共享并且可以实时聊天的小应用。应用的前端采用vue3框架，应用后端服务使用了MemFire Cloud，其中使用到的MemFire Cloud功能包括：&#xA;云数据库：存储小程序数据表的信息。 用户验证：小程序使用MemFire Cloud提供的用户认证的API接口，快速完成用户注册登录操作。 即时API：创建数据表时会自动生成 API。 Realtime：轻松构建任何类型的实时应用程序 创建应用 link目的：通过创建的一个MemFire Cloud应用来获得数据库、对象存储等一系列资源，并将获得该应用专属的API访问链接和访问密钥，用户可以轻松的调用API接口与以上资源进行交互。&#xA;登录MemFire Cloud， 在“我的应用”页面创建一个新应用&#xA;创建数据表 link点击进入应用详情页面，在“表编辑器”页面可视化建表。&#xA;1.创建realtime_user表 link在“SQL执行器”/“创建表”，创建realtime_user表。realtime_user表主要记录用户的资料，表结构字段如下： 名称 类型 描述 id uuid 主键，唯一标识ID name text 用户名 x real 用户光标的横坐标 y real 用户光标的纵坐标 message text 用户发送的消息 online boolean 用户是否在线 color text 用户头像颜色 mobile boolean 是否手机在线 last_active timestamp 最后在线时间 sql建表语句&#xA;create table realtime_user (&#xD;id uuid default uuid_generate_v4() primary key,&#xD;name text,&#xD;x real,&#xD;y real,&#xD;message text,&#xD;online boolean,&#xD;color text,&#xD;mobile boolean,&#xD;last_active timestamp default now()&#xD;);&#xD;2.</description>
    </item>
    <item>
      <title>介绍</title>
      <link>http://localhost:1313/docs/db/db-introduction/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/db-introduction/</guid>
      <description>MemFire Cloud致力于提供一站式数据库自助服务，隐藏复杂、专业的工作（比如：复杂的配置、数据库扩展、备份、运维等），实现开箱即用、按需使用、动态扩容、运维托管。&#xA;了解功能 link&#xD;云数据库&#xA;兼容PG协议，开箱即用&#xA;数据备份与恢复&#xA;支持自动、手动恢复方式&#xA;在线SQL编辑器&#xA;简单的数据库操作入口&#xA;多种开发语言，轻松使用 link不论是那种编程语言或框架，都可以快速使用MemFire Cloud云数据库。&#xA;python示例&#xA;Java示例&#xA;Golang示例&#xA;Spring示例&#xA;Node示例&#xA;C++示例&#xA;C#示例</description>
    </item>
    <item>
      <title>数据库管理</title>
      <link>http://localhost:1313/docs/db/database-management/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/database-management/</guid>
      <description>新用户完成注册登录后，可以自助式的获得数据库资源。MemFire Cloud用户可以根据需要自助的进行数据库管理，包括创建数据库、删除、连接、备份等功能。&#xA;创建数据库 link前置条件 link创建数据库前置条件：&#xA;用户名下需要有数据库账号，才可以创建数据库; 用户有足够的资源额度； 操作步骤 link 用户登录MemFire Cloud后，进入数据库管理页面； 单击“创建数据库”按钮，弹出“创建数据库”弹框； 输入要创建数据库名称，选择数据库账号，其中： 数据库名称由小写字母、大写字母、数字、下划线组成，以字母开头，字母或数字结尾，最多28个字符； 认证方式包括证书认证、密码认证两种。 前者需要下载证书并进行配置，采用加密的方式连接数据库； 后者采用账号+密码的方式连接数据库； 创建数据库名称不可重复; 选择数据库认证方式； 单击“创建”按钮，则可以完成数据库创建操作，并在列表中查看新建的数据库信息。 删除数据库 link前置条件 link删除数据库前提条件：&#xA;该数据库没有关联的备份计划； 该数据库处于“运行中”、“资源耗尽”、“异常”三种状态中任意一种； 操作步骤 link 选中要数据库列表中要删除的数据库所在行，单击数据库名称，进入数据库详情页面； 点击“释放按钮”，弹出“释放数据库”弹框； 单击“获取验证码”按钮，请在5min中内输入注册手机收到6位短信验证码； 单击“确定”按钮，完成数据库的删除操作，该数据库、数据库中所有数据表以及数据都将会被删除。 查看连接信息 link 用户登录MemFire Cloud后，进入数据库管理页面； 选中数据库列表中某个数据库所在列，单击“在线连接”按钮，弹出“连接信息”弹框； 若数据库为密码认证，则其连接信息如下所示： 当数据库为证书认证方式时，则提供证书下载链接，包括DER格式、PEM格式证书，默认勾选DER格式； ① 采用JAVA使用JDBC连接访问MemFire Cloud数据库时，请下载PEM格式证书； ② 其他方式连接访问MemFire Cloud数据库时，请下载DER格式证书； 查看数据库详情 link 用户登录MemFire Cloud后，进入数据库管理页面； 单击数据库列表中某个数据库名称，进入数据库详情页面。 数据库性能指标，最近1小时、最近6小时、最近12小时、最近1天、最近1周的读写OPS，平均延时； 数据库已用容量，数据表数目，备份计划数、 备份数量； | </description>
    </item>
    <item>
      <title>账号管理</title>
      <link>http://localhost:1313/docs/db/account-management/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/account-management/</guid>
      <description>MemFire Cloud用户可以根据需要自助的进行账号管理，包括创建账号、删除账号、重置账号密码等功能，便于管理与维护。&#xA;创建账号 link 用户登录MemFire Cloud后，进入左侧导航栏账号管理页面； 单击“创建账号”按钮，弹出“创建账号弹框； 设置参数如下：&#xA;由小写字母、大写字母、数字、下划线组成，以字母开头，以字母或数字结尾，最多16个字符，且不能以pg开头; 小写字母、大写字母、数字、特殊字符占三种，长度为8－32位；特殊字符为! @ # $ % ^ &amp;amp; * () _ + - = ; 单击“确定”按钮，完成账号创建操作，可以在账号列表中查看新建的账号信息；&#xA;删除账号 link前置条件 link删除账号的前提条件：&#xA;当且仅当该数据库账号名下无绑定的数据库资源后，才能删除该账号； 数据库账号名下的资源包括，①平台中存在其名下的数据库资源，②名下有备份的数据库资源； 操作步骤 link 用户登录MemFire Cloud后，进入账号管理页面； 选中要删除账号列表中所在行，单击“删除”按钮，弹出“删除账号”弹框； 单击“确定”按钮，完成账号的删除操作； 重置账号密码 link 用户登录MemFire Cloud后，进入账号管理页面； 选中要删除账号列表中所在行，单击“重置密码”按钮，弹出“重置密码”弹框；&#xA;在输入框内输入新的账号密码，并进行二次确认； 密码必须是小写字母、大写字母、数字、特殊字符占三种，长度为8－32位；特殊字符为! @ # $ % ^ &amp;amp; * () _ + - =； 说明：两次输入密码必须一致; 单击“确定”按钮，完成账号的密码重置操作； </description>
    </item>
    <item>
      <title>备份恢复</title>
      <link>http://localhost:1313/docs/db/backup-and-recovery/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/backup-and-recovery/</guid>
      <description>MemFire Cloud 提供灵活的数据备份计划，支持手动备份、自动备份两种方式，将关键核心的数据备份到第三方存储，为用户的云上数据库提供强有力的保护，保证数据不丢失。&#xA;手动备份 link 用户登录MemFire Cloud后，进入数据库管理页面； 选中数据库列表中某个数据库所在列，单击“备份”按钮，则将手动为该数据库创建一个备份任务； 完成创建操作后，备份任务将会立即执行，可在“备份恢复”-“数据备份”中查看任务进展；&#xA;设置备份计划 link 用户登录MemFire Cloud后，进入备份恢复页面； 单击“创建备份计划”按钮，弹出“创建备份计划”弹框； 在输入框内输入相关信息，包括： 备份计划名称:输入备份计划名称，最长为32个字符； 备份数据库名称: 选择一个备份的数据库名称； 备份周期: 周一，周二，周三，周四，周五，周六，周日，默认勾选周一，周三，周五，周日 备份时间段: 可选择一天中某个时间端运行备份任务;默认选择05：00-06：00； 保留天数: 正整数，默认7天 单击“确定”按钮，则完成创建备份计划操作； 修改备份计划 link 用户登录MemFire Cloud后，进入备份恢复页面； 选中要修改的备份计划，单击编辑图标； 弹出“编辑备份计划”弹框； 可编辑项如下： 备份周期: 周一，周二，周三，周四，周五，周六，周日，默认勾选周一，周三，周五，周日 备份时间段: 可选择一天中某个时间端运行备份任务;默认选择05：00-06：00; 保留天数: 正整数，默认7天; 单击“修改”按钮，则完成编辑备份计划操作； 删除备份计划 link当不需要定期进行数据备份时，普通用户可以删除自动备份计划；&#xA;用户登录MemFire Cloud后，进入备份恢复页面； 选中要删除的备份计划，单击删除图标； 单击“确认”，则可删除备份计划，该计划对应的数据库定期备份任务将不再执行； 恢复数据 link前置条件 link数据恢复的前提条件：数据备份为“成功”状态；&#xA;不同状态数据备份的操作说明：&#xA;*数据备份 恢复 手动删除 自动删除 “失败”备份 不支持 支持 仅支持删除自动备份操作后的“失败”的备份 “成功”备份 支持 支持 仅支持删除自动备份操作后的“成功”的备份 “删除中”备份 不支持 不支持 不支持 “备份中”备份 不支持 不支持 不支持 “恢复中”备份 不支持 不支持 不支持 操作步骤 link用户要恢复备份数据，可按照如下流程执行操作。</description>
    </item>
    <item>
      <title>在线SQL编辑器</title>
      <link>http://localhost:1313/docs/db/online-sql-editor/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/online-sql-editor/</guid>
      <description>MemFire Cloud提供了在线可视化SQL编辑器，以树形结构来展示数据库，数据表结构信息，提供可视化SQL编辑界面，开发人员可便捷编辑SQL命令并执行，查看执行结果，将执行结果以CSV等多种结构导出到本地。&#xA;前置条件 link 注册MemFire Cloud账号; 存在已创建的数据库。 操作步骤 link 用户登录MemFire Cloud后，进入数据库管理页面； 单击“SQL查询”按钮, 在浏览器打开的新登录页面输入正确的数据库密码， 并点击“连接数据库”按钮； 连接在线SQL编辑器后，可以查看数据库中的表结构信息，并在SQL编辑界面输入SQL命令。&#xA;输入编辑SQL命令并执行，查看执行结果，将执行数据结果以CSV、xlsx、json格式导出到本地。 </description>
    </item>
    <item>
      <title>客户端工具</title>
      <link>http://localhost:1313/docs/db/client-connection/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/client-connection/</guid>
      <description>MemFireDB兼容兼容PostgreSQL 11.2版本, MemFire Cloud几乎兼容所有PostgreSQL的客户端，目前已确认支持的客户端工具如下:&#xA;客户端名称 运行环境 安装、下载地址 psql Linux环境 命令：yum -y install postgresql11 DbGate Windows、Linux、MacOS环境 https://dbgate.org/ dbeaver Windows、MacOS环境 https://dbeaver.io/files/7.1.0/ datagrip Windows、Linux、MacOS环境 https://www.jetbrains.com/datagrip/download/#section=windows Navicat Premium Windows、Linux、MacOS环境 链接：https://pan.baidu.com/s/17r_oHwjeiC6Pqdq2c8yFLQ 提取码：s4l7 beekeeper-studio Windows、Linux、MacOS环境 https://www.beekeeperstudio.io/get HeidiSQL Windows环境 https://www.heidisql.com/ MemFire Cloud提供密码认证、证书认证两种云数据库服务，接下来本文会举例介绍不同的环境下，如何安装、配置客户端来连接访问MemFire Cloud数据库。&#xA;Windows环境 linkdbeaver使用SSL连接MemFireDB link以dbeaver7.1.0为例，介绍如何进行配置SSL连接MemFireDB。&#xA;下载软件。dbeaver7.1.0软件:下载地址&#xA;注册登录MemFire Cloud平台。 登录MemFire Cloud平台完成新用户的注册。&#xA;创建数据库。&#xA;进入数据库管理页面，点击“创建数据库”按钮，在”创建数据库“弹框中填写“数据库名称”，选择数据库账号，勾选“证书认证”，最后点击“确定”完成数据库创建操作。&#xA;备注说明： ① 创建数据库名称不能和已有数据库重复； ② 如果没有数据库账号，则先创建数据库账号; 取连接信息。&#xA;选中数据库列表中某个数据库所在列，点击“在线连接”按钮，弹出“连接信息”弹框；&#xA;可以查看该数据库的访问IP以及端口信息，当数据库为证书认证方式时，则提供证书下载链接，包括DER格式、PEM格式证书；&#xA;① 采用JAVA使用JDBC连接访问MemFire Cloud数据库时，请下载PEM格式证书；&#xA;② 其他方式连接访问MemFire Cloud数据库时，请下载DER格式证书；&#xA;鉴于dbeaver使用jdbc连接数据库，选择”PEM“的证书，点击”下载证书“按钮，将证书下载到本地。&#xA;解压下载证书。&#xA;解压文件中包括：“root.crt”，“memfiredb.crt”和“memfiredb.key”三个文件；&#xA;配置连接数据库。&#xA;在dbeaver中点击“数据库”-“新建连接”，驱动类型选择PostgreSQL。在“常规”下面填写主机、端口、数据库、用户名和密码。如下图：&#xA;在“SSL”标签下勾选“使用SSL”，证书一栏中选择之前下载的证书文件，“SSL模式”一栏中选择“verify-ca”，如下图： 点击“完成”创建数据库连接&#xA;最后，数据库连接建立之后，可以继续操作数据库。 dbeaver连接MemFireDB link以dbeaver7.1.0为例，介绍如何进行配置SSL连接MemFireDB。</description>
    </item>
    <item>
      <title>SQL操作入门</title>
      <link>http://localhost:1313/docs/db/introduction-to-sql-operation/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/introduction-to-sql-operation/</guid>
      <description>MemFireDB兼容PostgreSQL 11.2版本，具体可以参考兼容性说明。&#xA;新建数据库后，您可以使用在线编辑器、兼容的客户端工具连接数据库并执行SQL语句建表存储数据。&#xA;SQL 是一门声明性语言，它是数据库用户与数据库交互的方式。它更像是一种自然语言，好像在用英语与数据库进行对话。本文档介绍基本的SQL操作。&#xA;分类 linkSQL主要组件包括数据定义语言（DDL）、数据操作语言（DML）、数据控制语言（DCL）。&#xA;DDL (Data Definition Language)：数据定义语言，用来定义数据库对象，包括库、表、视图和索引等。DDL语句通过CREATE、ALTER和DROP命令来定义数据库中的结构、更改定义以及删除定义。 DML (Data Manipulation Language)：数据操作语言，用来操作和业务相关的记录。 DML语句主要包括增、删、查、改操作。 DCL (Data Control Language)：数据控制语言，用来定义访问权限和安全级别。 TCL（Transaction control language ）：TCL语句管理数据库上的操作事务。 创建、查看、删除表 link创建表 link要创建一个表，我们要用到CREATE TABLE命令。在这个命令中 我们需要为新表至少指定一个名字、列的名字及数据类型。例如：&#xA;让我们创建一个简单的表，如下所示。&#xA;CREATE TABLE employees (&#xD;employee_no integer,&#xD;name text,&#xD;department text&#xD;);&#xD;查询表结构 link要描述我们刚刚创建的表，请执行以下操作。&#xA;\d employees&#xD;输出：&#xA;Table &amp;#34;public.employees&amp;#34;&#xD;Column | Type | Collation | Nullable | Default -------------&amp;#43;---------&amp;#43;-----------&amp;#43;----------&amp;#43;---------&#xD;employee_no | integer | | | name | text | | | department | text | | | 删除表 link一个表能够拥有的列的数据是有限的，根据列的类型，这个限制介于250和1600之间。但是，极少会定义一个接近这个限制的表，即便有也是一个值的商榷的设计。 如果我们不再需要一个表，我们可以通过使用DROP TABLE命令来移除它。例如：</description>
    </item>
    <item>
      <title>Python示例</title>
      <link>http://localhost:1313/docs/db/example/python-example/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/example/python-example/</guid>
      <description>MemFire Cloud 提供Python、Java、spring、golang、nodejs、小程序开发示例，讲述如何编译执行程序，帮助用户如何采用多种语言来使用连接MemFire Cloud的云数据库。&#xA;示例下载地址&#xA;python示例下载地址：https://gitee.com/memfiredb/memfiredb-example-python&#xA;环境描述&#xA;•&#x9;python 2.7&#xA;•&#x9;pip install sqlalchemy==1.3.23&#xA;•&#x9;pip install psycopg2-binary&#xA;创建示例应用&#xA;1、加密连接&#xA;•&#x9;登录cloud.memfiredb.com创建证书认证数据库test，并下载证书，python程序请选择“常规”类型的证书&#xA;•&#x9;下载证书时，会下载三个文件，有的浏览器可能会进行拦截，取消拦截即可&#xA;•&#x9;证书下载后上传的linux服务器之后，要确保memfiredb.key文件的权限是0600，否则程序会抛出异常&#xA;•&#x9;sslmode选择“verify-ca”&#xA;（1）编辑代码文件main.py，文件内容如下：&#xA;# -*- coding: utf-8 -*-&#xD;&amp;#34;&amp;#34;&amp;#34;&#xD;Copyright (c) 2020, Nimblex Co .,Ltd.&#xD;Created on 2020-12-11 11:28&#xD;&amp;#34;&amp;#34;&amp;#34;&#xD;import sys&#xD;from sqlalchemy.ext.declarative import declarative_base&#xD;from sqlalchemy import Column, Integer&#xD;from sqlalchemy import create_engine&#xD;from sqlalchemy.orm import sessionmaker&#xD;import sqlalchemy.engine.url as url&#xD;Base = declarative_base()&#xD;class Counter(Base):&#xD;__tablename__ = &amp;#39;counters&amp;#39;&#xD;id = Column(Integer, primary_key=True)&#xD;counter = Column(Integer)&#xD;engine = None&#xD;def init_db_engine(host, port, dbname, user, passwd, ssl_ca, ssl_cert, ssl_key):&#xD;global engine&#xD;uri = url.</description>
    </item>
    <item>
      <title>Java示例</title>
      <link>http://localhost:1313/docs/db/example/java-example/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/example/java-example/</guid>
      <description>MemFire Cloud 提供Python、Java、spring、golang、nodejs、小程序开发示例，讲述如何编译执行程序，帮助用户如何采用多种语言来使用连接MemFire Cloud的云数据库。&#xA;示例下载地址&#xA;Java示例下载地址：https://gitee.com/memfiredb/memfiredb-example-java&#xA;环境描述&#xA;•&#x9;Java Development Kit (JDK) 1.8, or later&#xA;•&#x9;Apache Maven 3.3 or later&#xA;创建示例应用&#xA;1、创建POM&#xA;&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;&#xD;&amp;lt;project&#xD;xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&#xD;xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&#xD;xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&amp;gt;&#xD;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&#xD;&amp;lt;groupId&amp;gt;cn.nimblex.apps&amp;lt;/groupId&amp;gt;&#xD;&amp;lt;artifactId&amp;gt;mfsample&amp;lt;/artifactId&amp;gt;&#xD;&amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;&#xD;&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;&#xD;&amp;lt;dependencies&amp;gt;&#xD;&amp;lt;dependency&amp;gt;&#xD;&amp;lt;groupId&amp;gt;org.postgresql&amp;lt;/groupId&amp;gt;&#xD;&amp;lt;artifactId&amp;gt;postgresql&amp;lt;/artifactId&amp;gt;&#xD;&amp;lt;version&amp;gt;42.2.5&amp;lt;/version&amp;gt;&#xD;&amp;lt;/dependency&amp;gt;&#xD;&amp;lt;/dependencies&amp;gt;&#xD;&amp;lt;build&amp;gt;&#xD;&amp;lt;plugins&amp;gt;&#xD;&amp;lt;plugin&amp;gt;&#xD;&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;&#xD;&amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;&#xD;&amp;lt;version&amp;gt;3.7.0&amp;lt;/version&amp;gt;&#xD;&amp;lt;configuration&amp;gt;&#xD;&amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;&#xD;&amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;&#xD;&amp;lt;/configuration&amp;gt;&#xD;&amp;lt;/plugin&amp;gt;&#xD;&amp;lt;plugin&amp;gt;&#xD;&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;&#xD;&amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt;&#xD;&amp;lt;version&amp;gt;2.1&amp;lt;/version&amp;gt;&#xD;&amp;lt;executions&amp;gt;&#xD;&amp;lt;execution&amp;gt;&#xD;&amp;lt;id&amp;gt;copy-dependencies&amp;lt;/id&amp;gt;&#xD;&amp;lt;phase&amp;gt;prepare-package&amp;lt;/phase&amp;gt;&#xD;&amp;lt;goals&amp;gt;&#xD;&amp;lt;goal&amp;gt;copy-dependencies&amp;lt;/goal&amp;gt;&#xD;&amp;lt;/goals&amp;gt;&#xD;&amp;lt;configuration&amp;gt;&#xD;&amp;lt;outputDirectory&amp;gt;${project.build.directory}/lib&amp;lt;/outputDirectory&amp;gt;&#xD;&amp;lt;overWriteReleases&amp;gt;true&amp;lt;/overWriteReleases&amp;gt;&#xD;&amp;lt;overWriteSnapshots&amp;gt;true&amp;lt;/overWriteSnapshots&amp;gt;&#xD;&amp;lt;overWriteIfNewer&amp;gt;true&amp;lt;/overWriteIfNewer&amp;gt;&#xD;&amp;lt;/configuration&amp;gt;&#xD;&amp;lt;/execution&amp;gt;&#xD;&amp;lt;/executions&amp;gt;&#xD;&amp;lt;/plugin&amp;gt;&#xD;&amp;lt;/plugins&amp;gt;&#xD;&amp;lt;/build&amp;gt;&#xD;&amp;lt;/project&amp;gt;&#xD;执行如下命令，创建目录</description>
    </item>
    <item>
      <title>Golang示例</title>
      <link>http://localhost:1313/docs/db/example/golang-example/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/example/golang-example/</guid>
      <description>MemFire Cloud 提供Python、Java、spring、golang、nodejs、小程序开发示例，讲述如何编译执行程序，帮助用户如何采用多种语言来使用连接MemFire Cloud的云数据库。&#xA;示例下载地址&#xA;Golang示例下载地址：https://gitee.com/memfiredb/memfiredb-example-golang&#xA;环境描述 •&#x9;Go version 1.8 , or later&#xA;•&#x9;Go PostgreSQL driver 已经安装&#xA;go get github.com/lib/pq 创建示例应用&#xA;1、加密连接&#xA;•&#x9;在MemFire Cloud平台上完成注册操作，并创建证书认证的数据库test&#xA;•&#x9;点击数据库test的连接信息，下载访问证书，需要包括memfiredb.crt memfiredb.key root.crt，并拷贝到运行go程序的环境下；&#xA;创建源码文件main.go，文件内容如下:&#xA;/**&#xD;Copyright (c) 2020, Nimblex Co .,Ltd.&#xD;Created on 2020-07-21 19:35&#xD;**/&#xD;package main&#xD;import (&#xD;&amp;#34;database/sql&amp;#34;&#xD;_ &amp;#34;github.com/lib/pq&amp;#34;&#xD;&amp;#34;log&amp;#34;&#xD;)&#xD;func main() {&#xD;db, err := sql.Open(&amp;#34;postgres&amp;#34;, &amp;#34;user=test password=test dbname=test host=192.168.80.161 port=5433 sslmode=require sslcert=./memfiredb.crt sslkey=./memfiredb.key sslrootcert=./ca.crt&amp;#34;)&#xD;if err !</description>
    </item>
    <item>
      <title>Spring示例</title>
      <link>http://localhost:1313/docs/db/example/spring-example/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/example/spring-example/</guid>
      <description>MemFire Cloud 提供Python、Java、spring、golang、nodejs、小程序开发示例，讲述如何编译执行程序，帮助用户如何采用多种语言来使用连接MemFire Cloud的云数据库。&#xA;示例下载地址 Spring示例下载地址：https://gitee.com/memfiredb/mefiredb-example-spring&#xA;1、下载证书【可选-如果创建数据库时未勾选证书认证则不需要】&#xA;2、登录cloud.memfiredb.com 创建数据库并下载证书，证书类型选择“jdbc” 将下载的证书保存到合适的路径，本示例例中保存到/home/.memfiredb/中 查看数据库信息，包括服务器地址、数据库名、用户名、密码&#xA;3、修改配置文件中datasource【如果创建数据库时未勾选证书认证则url中不需要配置ssl相关内容】&#xA;src/main/resources/application.properties&#xA;# Data-source config.&#xD;# 请修改服务器地址、数据库名、用户名、密码&#xD;spring.datasource.platform=postgres&#xD;spring.datasource.url=jdbc:postgresql://192.168.80.5:5433/d0000005e2e1ead563d7e1b07a9a444cspring?ssl=true&amp;amp;sslmode=verify-ca&amp;amp;sslcert=/home/.memfiredb/memfiredb.crt&amp;amp;sslkey=/home/.memfiredb/memfiredb.key&amp;amp;sslrootcert=/home/.memfiredb/root.crt&#xD;spring.datasource.username=spring&#xD;spring.datasource.password=spring_123&#xD;4、编译&#xA;$ mvn -DskipTests package&#xD;5、运行&#xA;$ mvn spring-boot:run </description>
    </item>
    <item>
      <title>Node示例</title>
      <link>http://localhost:1313/docs/db/example/node-example/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/example/node-example/</guid>
      <description>MemFire Cloud 提供Python、Java、spring、golang、nodejs、小程序开发示例，讲述如何编译执行程序，帮助用户如何采用多种语言来使用连接MemFire Cloud的云数据库。&#xA;示例下载地址 Node示例下载地址：https://gitee.com/memfiredb/memfiredb-example-nodejs&#xA;环境描述 • node 12&#xA;创建示例应用 1、非加密连接 • 登录cloud.memfiredb.com创建非证书认证数据库test，点击“连接信息”按钮，获取数据库的连接信息。 （1）编辑代码文件，文件内容如下： controller.js:&#xA;const { Client } = require(&amp;#34;pg&amp;#34;);&#xD;let dbUrl = &amp;#39;&amp;#39;&#xD;exports.configuration = (req, res) =&amp;gt; {&#xD;// Validate request&#xD;if (!req.body) {&#xD;res.status(200).send({&#xD;message: &amp;#34;Req body is empty!&amp;#34;&#xD;});&#xD;return;&#xD;}&#xD;const d = req.body;&#xD;// console.log(d)&#xD;dbUrl = `postgresql://${d.username}:${d.passwd}@${d.host}:${d.port}/${d.dbname}`;&#xD;res.status(200).send({&#xD;message: dbUrl&#xD;});&#xD;return;&#xD;}&#xD;exports.sync = async (req, res) =&amp;gt; {&#xD;// Validate request&#xD;if (!</description>
    </item>
    <item>
      <title>C&#43;&#43;示例</title>
      <link>http://localhost:1313/docs/db/example/c&#43;&#43;-example/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/example/c&#43;&#43;-example/</guid>
      <description>MemFire Cloud 提供Python、Java、spring、golang、nodejs、小程序开发示例，讲述如何编译执行程序，帮助用户如何采用多种语言来使用连接MemFire Cloud的云数据库。&#xA;MemFireDB兼容PostgreSQL11.2，在PostgreSQL发行版中只包含两个客户端接口: libpq 和 ECPG。接下来我们会介绍如何编写C++程序，通过libpq客户端来连接访问MemFire Cloud云数据库。&#xA;编译安装libpq linklibpq是主要的C语言接口，而且许多其他客户端接口都是在它之上构建的。&#xA;文档地址： https ://libpqxx.readthedocs.io&#xA;Github 上地址： https ://github.com/jtv/libpqxx&#xA;gitee上地址： https://gitee.com/mirrors/libpqxx/tree/master&#xA;注意，使用libpqxx 7.x版本的需要C++ 17，本次样例使用旧版本的libpqxx(4.0.1)。&#xA;老版本libpqxx-4.0.1下载地址:http://pqxx.org/download/software/libpqxx/libpqxx-4.0.1.tar.gz&#xA;下载源码编译安装：&#xA;wget http://pqxx.org/download/software/libpqxx/libpqxx-4.0.1.tar.gz&#xD;tar -xzf libpqxx-4.0.1.tar.gz&#xD;cd libpqxx-4.0.1&#xD;./configure&#xD;make &amp;amp;&amp;amp; make install&#xD;创建MemFire Cloud云数据库 link登录MemFire Cloud平台，新建数据库，在数据库管理栏中，点击该数据库的“连接信息”，如下图所示，可以获得该数据库的连接配置信息。&#xA;编写程序 link下面是一段C++语言连接MemFire Cloud云数据库，创建数据表，插入数据的一段代码。&#xA;#include &amp;lt;iostream&amp;gt;&#xD;#include &amp;lt;pqxx/pqxx&amp;gt; using namespace std;&#xD;using namespace pqxx;&#xD;int main(int argc, char* argv[])&#xD;{&#xD;const char* sql;&#xD;try{&#xD;/* Establish database connection */&#xD;connection conn(&amp;#34;dbname=db338ea9abb2ed4fadb2cc228002f58899yingyong_db user=aaaa123 password=XXXXX hostaddr=139.</description>
    </item>
    <item>
      <title>C#示例</title>
      <link>http://localhost:1313/docs/db/example/c-example/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/example/c-example/</guid>
      <description>MemFire Cloud 提供Python、Java、spring、golang、node.js、C++、C#、小程序开发示例，讲述如何编译执行程序，帮助用户如何采用多种语言来使用连接MemFire Cloud的云数据库。&#xA;MemFireDB兼容PostgreSQL11.2，采用C# 连接 MemFire Cloud云数据库需使用Npgsql驱动。Npgsql 完全由C# 实现，是免费且开源的。接下来我们会介绍如何编写C#程序，通过Npgsql驱动来连接访问MemFire Cloud云数据库。&#xA;安装Npgsql linkNpgsql是 PostgreSQL 数据库的 ADO.NET 规范的实现,采用 C# 语言编写的驱动程序，适用于所有 .NET 语言。&#xA;1、通过VSCode的管理NuGet安装。&#xA;（1）在VSCode的扩展插件中，搜索并且安装NuGet Package Manager扩展插件；&#xA;（2）使用CTRL + SHIFT + P，输入&amp;gt; NuGet ，在下拉框中选择&amp;gt;NuGet Package Manager:Add Package&#xA;（3）选择浏览，搜索Npgsql，选择合适的版本进行安装。&#xA;2、采用命令行的方式进行安装： 在 Windows、Linux 和 macOS 上安装 .NET Core、.NET 5 及更高版本，参考地址：https://docs.microsoft.com/zh-cn/dotnet/core/install/ 安装完成后，可以通过 .NET CLI 的通用驱动程序dotnet来安装Npgsql。&#xA;dotnet add package Npgsql&#xD;创建MemFire Cloud云数据库 link登录MemFire Cloud平台，新建数据库，在数据库管理栏中，点击该数据库的“连接信息”，如下图所示，可以获得该数据库的连接配置信息。 编写程序 link1、新建文件夹HelloWord，启动 Visual Studio Code，从主菜单中选择“文件”-&amp;gt;“打开文件夹”打开HelloWord文件夹；&#xA;2、在“终端”中输入以下命令：&#xA;dotnet new console --framework net6.0&#xD;3、将 Program.</description>
    </item>
    <item>
      <title>C示例</title>
      <link>http://localhost:1313/docs/db/example/c2-example/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/example/c2-example/</guid>
      <description>MemFire Cloud 提供Python、Java、spring、golang、node.js、C++、C#、小程序开发示例，讲述如何编译执行程序，帮助用户如何采用多种语言来使用连接MemFire Cloud的云数据库。&#xA;MemFireDB兼容PostgreSQL11.2，采用C语言连接 MemFire Cloud云数据库构建应用程序，则需使用 libpq C 驱动程序。接下来我们会介绍如何编写C程序，通过 libpq C驱动来连接访问MemFire Cloud云数据库。&#xA;安装libpq C驱动程序 linklibpq C是用于连接到 PostgreSQL 数据库并与之交互的 C 客户端库。有关该库的详细介绍文档，可以参考：https://www.postgresql.org/docs/11/libpq.html&#xA;① 不同环境下，可根据官方文档下载PostgreSQL库和源代码地址：https://www.postgresql.org/download/。&#xA;② linux环境下，可以使用如下命令安装连接postgresql 相关的库libpq C库。&#xA;yum install postgresql-devel&#xD;更多示例可以查看：https://www.postgresql.org/docs/11/libpq-example.html&#xA;创建MemFire Cloud云数据库 link登录MemFire Cloud平台，新建数据库，在数据库管理栏中，点击该数据库的“连接信息”，如下图所示，可以获得该数据库的连接配置信息。 编写程序 link依赖条件：gcc 4.1.2 或更高版本；&#xA;1、新建文件test.c，并编写test.c文件，代码如下：&#xA;备注说明：使用新创建的数据库连接信息替换以下代码中的数据库配置信息，包括数据库连接IP、端口、用户名、密码、数据库名称；&#xA;使用libpq的客户端程序必须包含头文件libpq-fe.h，并且必须与libpq库链接。&#xA;#include &amp;lt;stdio.h&amp;gt;&#xD;#include &amp;lt;stdlib.h&amp;gt;&#xD;#include &amp;#34;libpq-fe.h&amp;#34;&#xD;int&#xD;main(int argc, char **argv)&#xD;{&#xD;const char *conninfo;&#xD;PGconn *conn;&#xD;PGresult *res;&#xD;int nFields;&#xD;int i, j;&#xD;/* connection string */&#xD;conninfo = &amp;#34;host=xx.</description>
    </item>
    <item>
      <title>数据迁移</title>
      <link>http://localhost:1313/docs/db/memfiredb-data-migration/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/memfiredb-data-migration/</guid>
      <description>前言 linkMemFireDB支持数据表的导入导出操作。为了提升系统易用性，本文档主要针对客户端Navicat和DBeaver对MemFireDB的导入导出功能进行说明。重点关注csv文件的导入导出功能。&#xA;Navicat导入数据表 link 选择数据类型&#xA;打开Navicat客户端，根据MemFire Cloud给出的连接信息连接好数据库。&#xA;点击Navicat客户端的Table下的Import Wizard，选择导入数据的类型，可以看到Navicat支持txt、csv、xls、xml、json等多种文件类型导入，本文档主要针对csv类型进行说明： 选择待导入文件&#xA;点击“continue”，进入选择文件页面，如下所示。&#xA;点击“add file”按钮，选择上要导入的数据文件源，Navicat支持一次性导入多个文件。 格式选项修改&#xA;可对源文件定义一些附加选项，例如字段之间分隔符，若无特殊要求，可直接跳过。 选择目标表&#xA;选择源文件数据待导入的目标数据库表，可以选择已创建的数据表或者输入新的数据表名称。 设置字段映射&#xA;用户可以自定义源文件与目标数据表的字段映射关系。 (1) 目标表为已创建数据表时，可修改对应关系，例如：修改对应主键(Primary Key); (2) 目标表是待创建新表时，还可以修改对应列名。 选择导入模式&#xA;如果是新数据表的话，选择第一项。根据具体导入情况，选择不同的选项。 导入数据&#xA;开始导入源数据，导入结果受源文件内容影响。Navicat会展示数据导入的进度，包括数据表数目、错误数量、消耗时间等以及日志信息。 DBeaver导入数据表 link 选择数据类型&#xA;打开DBeaver客户端，根据MemFire Cloud给出的连接信息连接好数据库。&#xA;点击DBeaver客户端的Tables下的Import Data，选择导入数据的类型，目前DBeaver支持csv格式文件导入： 选择待导入文件&#xA;点击“next”，进入选择文件页面，配置待导入文件或目录，如下所示。&#xA;选择要导入的文件源，DBeaver支持一次性导入多个文件。 格式选项修改&#xA;可对源文件定义一些附加选项，若无特殊要求，可直接跳过。 导入数据&#xA;开始导入，导入结果受源文件内容影响。 Navicat导出数据表 link 选择导出数据类型 打开Navicat客户端，根据MemFire Cloud给出的连接信息连接好数据库。 (1) 点击选中待导出的数据表;&#xA;(2) 点击Export Wizard，选择待导出的文件类型，可以看到Navicat支持txt、csv、xls、xml、json等多种文件格式导出。本文档主要针对csv格式进行说明。 选择保存地址&#xA;用户可以点击“change”按钮， 选择导出文件的保存地址。 选择导出表项&#xA;用户可根据实际需求，灵活勾选要导出数据表中的那些字段列信息。 选择导出格式&#xA;可以自定义某些选中，包括出错是否继续、字段之间分隔符等。 导出数据 完成以上所有选择配置后，点击“start”按钮，开始进行数据表导出操作。 DBeaver导出数据表 link 选择导出数据类型 打开DBeaver客户端，根据MemFire Cloud给出的连接信息连接好数据库。 (1) 点击选中待导出的数据表; (2) 右击选择“import data”，选择待导出的文件类型，DBeaver导出操作与导入操作不同，支持txt、csv、SQL、html、xml、json等多种文件格式导出。 选择导出格式</description>
    </item>
    <item>
      <title>兼容性说明</title>
      <link>http://localhost:1313/docs/db/guides/compatibility/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/guides/compatibility/</guid>
      <description>MemFireDB 支持符合ANSI标准的结构化查询语言。兼容PostgreSQL 11.2版本。MemFireDB复用了PostgresSQL的原生查询层。MemFire支持所有的传统关系模型功能，例如引用完整性（例如外键）、JOIN、分布式事务、部分索引、触发器和存储过程。&#xA;PostgreSQL总共有182条SQL语句，MemFireDB 支持79条，有49条语句的语法（参数）是完全相同的，有29条语句的部分语法（参数）MemFireDB 不支持，只有一条（ SHOW TRANSACTION 显示事务等级）是MemFireDB自创的，CREATE DATABASE 和 DROP FUNCTION 语句 MemFireDB 在 PG 的基础上多设了一个参数。详细对比见下表（左侧为 PG 全部SQL语句，中间为MemFireDB支持的语句，右侧表示该语句的语法是否完全相同）：&#xA;PostgreSQL MemFireDB same 182 79 49 ABORT — 中止当前事务 ABORT ALTER AGGREGATE — 更改一个聚集函数的定义 ALTER COLLATION — 更改一个排序规则的定义 ALTER CONVERSION — 改变一个转换的定义 ALTER DATABASE — 更改一个数据库 ALTER DATABASE ALTER DEFAULT PRIVILEGES — 定义默认访问特权 ALTER DEFAULT PRIVILEGES ALTER DOMAIN — 更改一个域的定义 ALTER DOMAIN no ALTER EVENT TRIGGER — 更改一个事件触发器的定义 ALTER EXTENSION — 更改一个扩展的定义 ALTER FOREIGN DATA WRAPPER — 更改一个外部数据包装器的定义 ALTER FOREIGN TABLE — 更改一个外部表的定义 ALTER FUNCTION — 更改一个函数的定义 ALTER GROUP — 更改角色名称或者成员关系 ALTER GROUP ALTER INDEX — 更改一个索引的定义 ALTER LANGUAGE — 更改一种过程语言的定义 ALTER LARGE OBJECT — 更改一个大对象的定义 ALTER MATERIALIZED VIEW — 更改一个物化视图的定义 ALTER OPERATOR — 更改一个操作符的定义 ALTER OPERATOR CLASS — 更改一个操作符类的定义 ALTER OPERATOR FAMILY — 更改一个操作符族的定义 ALTER POLICY — 更改一条行级安全性策略的定义 ALTER POLICY ALTER PROCEDURE — change the definition of a procedure ALTER PUBLICATION — 修改发布的定义 ALTER ROLE — 更改一个数据库角色 ALTER ROLE no ALTER ROUTINE — 更改一个例程的定义 ALTER RULE — 更改一个规则定义 ALTER SCHEMA — 更改一个模式的定义 ALTER SEQUENCE — 更改一个序列发生器的定义 ALTER SEQUENCE no ALTER SERVER — 更改一个外部服务器的定义 ALTER STATISTICS — 更改扩展统计对象的定义 ALTER SUBSCRIPTION — 修改订阅的定义 ALTER SYSTEM — 更改一个服务器配置参数 ALTER TABLE — 更改一个表的定义 ALTER TABLE no ALTER TABLESPACE — 更改一个表空间的定义 ALTER TEXT SEARCH CONFIGURATION — 更改一个文本搜索配置的定义 ALTER TEXT SEARCH DICTIONARY — 更改一个文本搜索字典的定义 ALTER TEXT SEARCH PARSER — 更改一个文本搜索解析器的定义 ALTER TEXT SEARCH TEMPLATE — 更改一个文本搜索模板的定义 ALTER TRIGGER — 更改一个触发器的定义 ALTER TYPE — 更改一个类型的定义 ALTER USER — 更改一个数据库角色 ALTER USER ALTER USER MAPPING — 更改一个用户映射的定义 ALTER VIEW — 更改一个视图的定义 ANALYZE — 收集有关一个数据库的统计信息 BEGIN — 开始一个事务块 BEGIN no CALL — 调用一个过程 CHECKPOINT — 强制一个事务日志检查点 CLOSE — 关闭一个游标 CLUSTER — 根据一个索引聚簇一个表 COMMENT — 定义或者更改一个对象的注释 COMMENT COMMIT — 提交当前事务 COMMIT COMMIT PREPARED — 提交一个早前为两阶段提交预备的事务 COPY — 在一个文件和一个表之间复制数据 COPY CREATE ACCESS METHOD — 定义一种新的访问方法 CREATE AGGREGATE — 定义一个新的聚集函数 CREATE AGGREGATE CREATE CAST — 定义一种新的造型 CREATE CAST CREATE COLLATION — 定义一种新排序规则 CREATE CONVERSION — 定义一种新的编码转换 CREATE DATABASE — 创建一个新数据库 CREATE DATABASE no CREATE DOMAIN — 定义一个新的域 CREATE DOMAIN no CREATE EVENT TRIGGER — 定义一个新的事件触发器 CREATE EXTENSION — 安装一个扩展 CREATE EXTENSION no CREATE FOREIGN DATA WRAPPER — 定义一个新的外部数据包装器 CREATE FOREIGN TABLE — 定义一个新的外部表 CREATE FUNCTION — 定义一个新函数 CREATE FUNCTION CREATE GROUP — 定义一个新的数据库角色 CREATE GROUP no CREATE INDEX — 定义一个新索引 CREATE INDEX no CREATE LANGUAGE — 定义一种新的过程语言 CREATE MATERIALIZED VIEW — 定义一个新的物化视图 CREATE OPERATOR — 定义一个新的操作符 CREATE OPERATOR CREATE OPERATOR CLASS — 定义一个新的操作符类 CREATE OPERATOR CLASS no CREATE OPERATOR FAMILY — 定义一个新的操作符族 CREATE POLICY — 为一个表定义一条新的行级安全性策略 CREATE POLICY CREATE PROCEDURE — 定义一个新的过程 CREATE PROCEDURE CREATE PUBLICATION — 定义一个新的发布 CREATE ROLE — 定义一个新的数据库角色 CREATE ROLE no CREATE RULE — 定义一条新的重写规则 CREATE RULE CREATE SCHEMA — 定义一个新模式 CREATE SCHEMA CREATE SEQUENCE — 定义一个新的序列发生器 CREATE SEQUENCE no CREATE SERVER — 定义一个新的外部服务器 CREATE STATISTICS — 定义扩展统计 CREATE SUBSCRIPTION — 定义一个新的订阅 CREATE TABLE — 定义一个新表 CREATE TABLE no CREATE TABLE AS — 从一个查询的结果创建一个新表 CREATE TABLE AS no CREATE TABLESPACE — 定义一个新的表空间 CREATE TEXT SEARCH CONFIGURATION — 定义一个新的文本搜索配置 CREATE TEXT SEARCH DICTIONARY — 定义一个新的文本搜索字典 CREATE TEXT SEARCH PARSER — 定义一个新的文本搜索解析器 CREATE TEXT SEARCH TEMPLATE — 定义一种新的文本搜索模板 CREATE TRANSFORM — 定义一个新的转换 CREATE TRIGGER — 定义一个新触发器 CREATE TRIGGER no CREATE TYPE — 定义一种新的数据类型 CREATE TYPE no CREATE USER — 定义一个新的数据库角色 CREATE USER no CREATE USER MAPPING — 定义一个用户到一个外部服务器的新映射 CREATE VIEW — 定义一个新视图 CREATE VIEW no DEALLOCATE — 释放一个预备语句 DEALLOCATE DECLARE — 定义一个游标 DELETE — 删除一个表的行 DELETE no DISCARD — 抛弃会话状态 DO — 执行一个匿名代码块 DO DROP ACCESS METHOD — 移除一种访问方法 DROP AGGREGATE — 移除一个聚集函数 DROP AGGREGATE DROP CAST — 移除一个造型 DROP CAST DROP COLLATION — 移除一个排序规则 DROP CONVERSION — 移除一个转换 DROP DATABASE — 移除一个数据库 DROP DATABASE DROP DOMAIN — 移除一个域 DROP DOMAIN DROP EVENT TRIGGER — 移除一个事件触发器 DROP EXTENSION — 移除一个扩展 DROP EXTENSION DROP FOREIGN DATA WRAPPER — 移除一个外部数据包装器 DROP FOREIGN TABLE — 移除一个外部表 DROP FUNCTION — 移除一个函数 DROP FUNCTION no DROP GROUP — 移除一个数据库角色 DROP GROUP DROP INDEX — 移除一个索引 DROP LANGUAGE — 移除一个过程语言 DROP MATERIALIZED VIEW — 移除一个物化视图 DROP OPERATOR — 移除一个操作符 DROP OPERATOR DROP OPERATOR CLASS — 移除一个操作符类 DROP OPERATOR CLASS DROP OPERATOR FAMILY — 移除一个操作符族 DROP OWNED — 移除一个数据库角色拥有的数据库对象 DROP OWNED DROP POLICY — 从一个表移除一条行级安全性策略 DROP POLICY DROP PROCEDURE — 移除一个过程 DROP PROCEDURE DROP PUBLICATION — 删除一个发布 DROP ROLE — 移除一个数据库角色 DROP ROLE DROP ROUTINE — 删除一个例程 DROP RULE — 移除一个重写规则 DROP RULE DROP SCHEMA — 移除一个模式 DROP SEQUENCE — 移除一个序列 DROP SEQUENCE DROP SERVER — 移除一个外部服务器描述符 DROP STATISTICS — 删除扩展统计 DROP SUBSCRIPTION — 删除一个订阅 DROP TABLE — 移除一个表 DROP TABLE no DROP TABLESPACE — 移除一个表空间 DROP TEXT SEARCH CONFIGURATION — 移除一个文本搜索配置 DROP TEXT SEARCH DICTIONARY — 移除一个文本搜索字典 DROP TEXT SEARCH PARSER — 移除一个文本搜索解析器 DROP TEXT SEARCH TEMPLATE — 移除一个文本搜索模板 DROP TRANSFORM — 移除转换 DROP TRIGGER — 移除一个触发器 DROP TRIGGER DROP TYPE — 移除一个数据类型 DROP TYPE DROP USER — 移除一个数据库角色 DROP USER DROP USER MAPPING — 移除一个用于外部服务器的用户映射 DROP VIEW — 移除一个视图 END — 提交当前事务 END EXECUTE — 执行一个预备语句 EXECUTE EXPLAIN — 显示一个语句的执行计划 EXPLAIN FETCH — 使用游标从查询中检索行 GRANT — 定义访问特权 GRANT no IMPORT FOREIGN SCHEMA — 从一个外部服务器导入表定义 INSERT — 在一个表中创建新行 INSERT no LISTEN — 监听一个通知 LOAD — 载入一个共享库文件 LOCK — 锁定一个表 LOCK MOVE — 定位一个游标 NOTIFY — 生成一个通知 PREPARE — 为执行准备一个语句 PREPARE PREPARE TRANSACTION — 为两阶段提交准备当前事务 REASSIGN OWNED — 更改一个数据库角色拥有的数据库对象的拥有关系 REASSIGN OWNED REFRESH MATERIALIZED VIEW — 替换一个物化视图的内容 REINDEX — 重建索引 RELEASE SAVEPOINT — 销毁一个之前定义的保存点 RESET — 把一个运行时参数的值恢复到默认值 RESET REVOKE — 移除访问特权 REVOKE no ROLLBACK — 中止当前事务 ROLLBACK ROLLBACK PREPARED — 取消一个之前为两阶段提交准备好的事务 ROLLBACK TO SAVEPOINT — 回滚到一个保存点 SAVEPOINT — 在当前事务中定义一个新的保存点 SECURITY LABEL — 定义或更改应用到一个对象的安全标签 SELECT — 从一个表或视图检索行 SELECT no SELECT INTO — 从一个查询的结果定义一个新表 SET — 更改一个运行时参数 SET SET CONSTRAINTS — 为当前事务设置约束检查时机 SET CONSTRAINTS no SET ROLE — 设置当前会话的当前用户标识符 SET ROLE SET SESSION AUTHORIZATION — 设置当前会话的会话用户标识符和当前用户标识符 SET SESSION AUTHORIZATION SET TRANSACTION — 设置当前事务的特性 SET TRANSACTION SHOW — 显示一个运行时参数的值 SHOW SHOW TRANSACTION - START TRANSACTION — 开始一个事务块 TRUNCATE — 清空一个表或者一组表 TRUNCATE no UNLISTEN — 停止监听一个通知 UPDATE — 更新一个表的行 UPDATE no VACUUM — 垃圾收集并根据需要分析一个数据库 VALUES — 计算一个行集合 </description>
    </item>
    <item>
      <title>关键字</title>
      <link>http://localhost:1313/docs/db/guides/keyword/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/guides/keyword/</guid>
      <description>关键字是在SQL中有意义的字，本节介绍MemFireDB特有的关键字。关键字里有保留字和非保留字之分。根据标准，保留字决不能用做其他标识符。非保留字只是在特定的环境里有特殊的含义，而在其他环境里是可以用做标识符的。&#xA;表 关键字 关键字 用法 例外情况 ABORT 非保留 无 ABSOLUTE 非保留 无 ACCESS 非保留 无 ACTION 非保留 无 ADD 非保留 无 ADMIN 非保留 无 AFTER 非保留 无 AGGREGATE 非保留 无 ALL 保留 无 ALSO 非保留 无 ALTER 非保留 无 ALWAYS 非保留 无 ANALYSE 保留 无 ANALYZE 保留 无 AND 保留 无 ANY 保留 无 ARRAY 保留 无 AS 保留 无 ASC 保留 无 ASSERTION 非保留 无 ASSIGNMENT 非保留 无 ASYMMETRIC 保留 无 AT 非保留 无 ATTACH 非保留 无 ATTRIBUTE 非保留 无 AUTHORIZATION 保留 可以是函数或类型 BACKWARD 非保留 无 BEFORE 非保留 无 BEGIN 非保留 无 BETWEEN 非保留 可以是函数或类型 BIGINT 非保留 可以是函数或类型 BINARY 保留 可以是函数或类型 BIT 非保留 不能是函数或类型 BOOLEAN 非保留 不能是函数或类型 BOTH 保留 无 BY 非保留 无 CACHE 非保留 无 CALLED 非保留 无 CASCADE 非保留 无 CASCADED 非保留 无 CASE 保留 无 CAST 保留 无 CATALOG 非保留 无 CHAIN 非保留 无 CHAR 非保留 不能是函数或类型 CHARACTER 非保留 不能是函数或类型 CHARACTERISTICS 非保留 无 CHECK 保留 无 CHECKPOINT 非保留 无 CLASS 非保留 无 CLOSE 非保留 无 CLUSTER 非保留 无 COALESCE 非保留 不能是函数或类型 COLLATE 保留 无 COLLATION 保留 可以用于函数，类型或别名 COLUMN 保留 无 COLUMNS 非保留 无 COMMENT 非保留 无 COMMENTS 非保留 无 COMMIT 非保留 无 COMMITTED 非保留 无 CONCURRENTLY 保留 可以用于函数，类型或别名 CONFIGURATION 非保留 无 CONFLICT 非保留 无 CONNECTION 非保留 无 CONSTRAINT 保留 无 CONSTRAINTS 非保留 无 CONTENT 非保留 无 CONTINUE 非保留 无 CONVERSION 非保留 无 COPY 非保留 无 COST 非保留 无 CREATE 保留 无 CROSS 保留 可以用于函数，类型或别名 CSV 非保留 无 CUBE 非保留 无 CURRENT 非保留 无 CURRENT_CATALOG 保留 无 CURRENT_DATE 保留 无 CURRENT_ROLE 保留 无 CURRENT_SCHEMA 保留 可以用于函数，类型或别名 CURRENT_TIME 保留 无 CURRENT_TIMESTAMP 保留 无 CURRENT_USER 保留 无 CURSOR 非保留 无 CYCLE 非保留 无 DATA 非保留 无 DATABASE 非保留 无 DAY 非保留 无 DEALLOCATE 非保留 无 DEC 非保留 不能是函数或类型名称 DECIMAL 非保留 不能是函数或类型名称 DECLARE 非保留 无 DEFAULT 保留 无 DEFAULTS 非保留 无 DEFERRABLE 保留 无 DEFERRED 非保留 无 DEFINER 非保留 无 DELETE 非保留 无 DELIMITER 非保留 无 DELIMITERS 非保留 无 DEPENDS 非保留 无 DESC 保留 无 DETACH 非保留 无 DICTIONARY 非保留 无 DISABLE 非保留 无 DISCARD 非保留 无 DISTINCT 保留 无 DO 保留 无 DOCUMENT 非保留 无 DOMAIN 非保留 无 DOUBLE 非保留 无 DROP 非保留 无 EACH 非保留 无 ELSE 保留 无 ENABLE 非保留 无 ENCODING 非保留 无 ENCRYPTED 非保留 无 END 保留 无 ENUM 非保留 无 ESCAPE 非保留 无 EVENT 非保留 无 EXCEPT 保留 无 EXCLUDE 非保留 无 EXCLUDING 非保留 无 EXCLUSIVE 非保留 无 EXECUTE 非保留 无 EXISTS 非保留 不能是函数或类型名称 EXPLAIN 非保留 无 EXTENSION 非保留 无 EXTERNAL 非保留 无 EXTRACT 非保留 不能是函数或类型名称 FALSE 保留 无 FAMILY 非保留 无 FETCH 保留 无 FILTER 非保留 无 FIRST 非保留 无 FLOAT 非保留 不能是函数或类型名称 FOLLOWING 非保留 无 FOR 保留 无 FORCE 非保留 无 FOREIGN 保留 无 FORWARD 非保留 无 FREEZE 保留 可以用于函数，类型或别名 FROM 保留 无 FULL 保留 可以用于函数，类型或别名 FUNCTION 非保留 无 FUNCTIONS 非保留 无 GENERATED 非保留 无 GLOBAL 非保留 无 GRANT 保留 无 GRANTED 非保留 无 GREATEST 非保留 不能是函数或类型名称 GROUP 保留 无 GROUPING 非保留 不能是函数或类型名称 HANDLER 非保留 无 HAVING 保留 无 HEADER 非保留 无 HOLD 非保留 无 HOUR 非保留 无 IDENTITY 非保留 无 IF 非保留 无 ILIKE 保留 可以用于函数，类型或别名 IMMEDIATE 非保留 无 IMMUTABLE 非保留 无 IMPLICIT 非保留 无 IMPORT 非保留 无 IN 保留 无 INCLUDING 非保留 无 INCREMENT 非保留 无 INDEX 非保留 无 INDEXES 非保留 无 INHERIT 非保留 无 INHERITS 非保留 无 INITIALLY 保留 无 INLINE 非保留 无 INNER 保留 可以用于函数，类型或别名 INOUT 非保留 不能是函数或类型名称 INPUT 非保留 无 INSENSITIVE 非保留 无 INSERT 非保留 无 INSTEAD 非保留 无 INT 非保留 不能是函数或类型名称 INTEGER 非保留 不能是函数或类型名称 INTERSECT 保留 无 INTERVAL 非保留 不能是函数或类型名称 INTO 保留 无 INVOKER 非保留 无 IS 保留 可以用于函数，类型或别名 ISNULL 保留 可以用于函数，类型或别名 ISOLATION 非保留 无 JOIN 保留 可以用于函数，类型或别名 KEY 非保留 无 LABEL 非保留 无 LANGUAGE 非保留 无 LARGE 非保留 无 LAST 非保留 无 LATERAL 保留 无 LEADING 保留 无 LEAKPROOF 非保留 无 LEAST 非保留 不能是函数或类型名称 LEFT 保留 可以用于函数，类型或别名 LEVEL 非保留 无 LIKE 保留 可以用于函数，类型或别名 LIMIT 保留 无 LISTEN 非保留 无 LOAD 非保留 无 LOCAL 非保留 无 LOCALTIME 保留 无 LOCALTIMESTAMP 保留 无 LOCATION 非保留 无 LOCK 非保留 无 LOCKED 非保留 无 LOGGED 非保留 无 MAPPING 非保留 无 MATCH 非保留 无 MATERIALIZED 非保留 无 MAXVALUE 非保留 无 METHOD 非保留 无 MINUTE 非保留 无 MINVALUE 非保留 无 MODE 非保留 无 MONTH 非保留 无 MOVE 非保留 无 NAME 非保留 无 NAMES 非保留 无 NATIONAL 非保留 不能是函数或类型名称 NATURAL 保留 可以用于函数，类型或别名 NCHAR 非保留 不能是函数或类型名称 NEW 非保留 无 NEXT 非保留 无 NO EXCEPTION 非保留 无 NONE 非保留 不能是函数或类型名称 NOT 保留 无 NOTHING 非保留 无 NOTIFY 非保留 无 NOTNULL 保留 可以用于函数，类型或别名 NOWAIT 非保留 无 NULL 保留 无 NULLIF 非保留 不能是函数或类型名称 NULLS 非保留 无 NUMERIC 非保留 不能是函数或类型名称 OBJECT 非保留 无 OF 非保留 无 OFF 非保留 无 OFFSET 保留 无 OIDS 非保留 无 OLD 非保留 无 ON 保留 无 ONLY 保留 无 OPERATOR 非保留 无 OPTION 非保留 无 OPTIONS 非保留 无 OR 保留 无 ORDER 保留 无 ORDINALITY 非保留 无 OUT 非保留 不能是函数或类型名称 OUTER 保留 可以用于函数，类型或别名 OVER 非保留 无 OVERLAPS 保留 可以用于函数，类型或别名 OVERLAY 非保留 不能是函数或类型名称 OVERRIDING 非保留 无 OWNED 非保留 无 OWNER 非保留 无 PARALLEL 非保留 无 PARSER 非保留 无 PARTIAL 非保留 无 PARTITION 非保留 无 PASSING 非保留 无 PASSWORD 非保留 无 PLACING 保留 无 PLANS 非保留 无 POLICY 非保留 无 POSITION 非保留 不能是函数或类型名称 PRECEDING 非保留 无 PRECISION 非保留 不能是函数或类型名称 PREPARE 非保留 无 PREPARED 非保留 无 PRESERVE 非保留 无 PRIMARY 保留 无 PRIOR 非保留 无 PRIVILEGES 非保留 无 PROCEDURAL 非保留 无 PROCEDURE 非保留 无 PROGRAM 非保留 无 PUBLICATION 非保留 无 QUOTE 非保留 无 RANGE 非保留 无 READ 非保留 无 REAL 非保留 不能是函数或类型名称 REASSIGN 非保留 无 RECHECK 非保留 无 RECURSIVE 非保留 无 REF 非保留 无 REFERENCES 保留 无 REFERENCING 非保留 无 REFRESH 非保留 无 REINDEX 非保留 无 RELATIVE 非保留 无 RELEASE 非保留 无 RENAME 非保留 无 REPEATABLE 非保留 无 REPLACE 非保留 无 REPLICA 非保留 无 RESET 非保留 无 RESTART 非保留 无 RESTRICT 非保留 无 RETURNING 保留 无 RETURNS 非保留 无 REVOKE 非保留 无 RIGHT 保留 可以用于函数，类型或别名 ROLE 非保留 无 ROLLBACK 非保留 无 ROLLUP 非保留 无 ROW 非保留 不能是函数或类型名称 ROWS 非保留 无 RULE 非保留 无 SAVEPOINT 非保留 无 SCHEMA 非保留 无 SCHEMAS 非保留 无 SCROLL 非保留 无 SEARCH 非保留 无 SECOND 非保留 无 SECURITY 非保留 无 SELECT 保留 无 SEQUENCE 非保留 无 SEQUENCES 非保留 无 SERIALIZABLE 非保留 无 SERVER 非保留 无 SESSION 非保留 无 SESSION_USER 保留 无 SET 非保留 无 SETOF 非保留 不能是函数或类型名称 SETS 非保留 无 SHARE 非保留 无 SHOW 非保留 无 SIMILAR 保留 可以用于函数，类型或别名 SIMPLE 非保留 无 SKIP 非保留 无 SMALLINT 非保留 不能是函数或类型名称 SNAPSHOT 非保留 无 SOME 保留 无 SQL 非保留 无 STABLE 非保留 无 STANDALONE 非保留 无 START 非保留 无 STATEMENT 非保留 无 STATISTICS 非保留 无 STDIN 非保留 无 STDOUT 非保留 无 STORAGE 非保留 无 STRICT 非保留 无 STRIP 非保留 无 SUBSCRIPTION 非保留 无 SUBSTRING 非保留 不能是函数或类型名称 SYMMETRIC 保留 无 SYSID 非保留 无 SYSTEM 非保留 无 TABLE 保留 无 TABLES 非保留 无 TABLESAMPLE 保留 可以用于函数，类型或别名 TABLESPACE 非保留 无 TEMP 非保留 无 TEMPLATE 非保留 无 TEMPORARY 非保留 无 TEXT 非保留 无 THEN 保留 无 TIME 非保留 不能是函数或类型名称 TIMESTAMP 非保留 不能是函数或类型名称 TO 保留 无 TRAILING 保留 无 TRANSACTION 非保留 无 TRANSFORM 非保留 无 TREAT 非保留 不能是函数或类型名称 TRIGGER 非保留 无 TRIM 非保留 不能是函数或类型名称 TRUE 保留 无 TRUNCATE 非保留 无 TRUSTED 非保留 无 TYPE 非保留 无 TYPES 非保留 无 UNBOUNDED 非保留 无 UNCOMMITTED 非保留 无 UNENCRYPTED 非保留 无 UNION 保留 无 UNIQUE 保留 无 UNKNOWN 非保留 无 UNLISTEN 非保留 无 UNLOGGED 非保留 无 UNTIL 非保留 无 UPDATE 非保留 无 USER 保留 无 USING 保留 无 VACUUM 非保留 无 VALID 非保留 无 VALIDATE 非保留 无 VALIDATOR 非保留 无 VALUE 非保留 无 VALUES 非保留 不能是函数或类型 VARCHAR 非保留 不能是函数或类型 VARIADIC 保留 无 VARYING 非保留 无 VERBOSE 保留 可以用于函数，类型或别名 VERSION 非保留 无 VIEW 非保留 无 VIEWS 非保留 无 VOLATILE 非保留 无 WHEN 保留 无 WHERE 保留 无 WHITESPACE 非保留 无 WINDOW 保留 无 WITH 保留 无 WITHIN 非保留 无 WITHOUT 非保留 无 WORK 非保留 无 WRAPPER 非保留 无 WRITE 非保留 无 XML 非保留 无 XMLATTRIBUTES 非保留 不能是函数或类型 XMLCONCAT 非保留 不能是函数或类型 XMLELEMENT 非保留 不能是函数或类型 XMLEXISTS 非保留 不能是函数或类型 XMLFOREST 非保留 不能是函数或类型 XMLNAMESPACES 非保留 不能是函数或类型 XMLPARSE 非保留 不能是函数或类型 XMLPI 非保留 不能是函数或类型 XMLROOT 非保留 不能是函数或类型 XMLSERIALIZE 非保留 不能是函数或类型 XMLTABLE 非保留 不能是函数或类型 YEAR 非保留 无 YES 非保留 无 ZONE 非保留 无 </description>
    </item>
    <item>
      <title>数据类型</title>
      <link>http://localhost:1313/docs/db/guides/data-type/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/guides/data-type/</guid>
      <description>数据类型汇总 link下表列出了MemFireDB支持的原始和复合数据类型。显示了所有内建的普通数据类型。大部分在“别名”列里列出的可选名字都是因历史原因在内部使用的名字。&#xA;表 数据类型&#xA;数据类型 别名 描述 bigint int8 有符号8字节整数 bigserial serial8 自动增长的8字节整数 bit [ (n) ] 定长位串 bit varying [ (n) ] varbit [ (n) ] 变长位串 boolean bool 逻辑布尔值（真/假） box 平面上的普通方框 bytea 二进制数据（“字节数组”） character [ (n) ] char [ (n) ] 定长字符串 character varying [ (n) ] varchar [ (n) ] 变长字符串 cidr IPv4或IPv6网络地址 circle 平面上的圆 date 日历日期（年、月、日） double precision float8 双精度浮点数（8字节） inet IPv4或IPv6主机地址 integer int， int4 有符号4字节整数 interval [ fields ] [ (p) ] 时间段 json 文本JSON数据 jsonb 二进制JSON数据，已分解 line 平面上的无限长的线 lseg 平面上的线段 macaddr MAC（Media Access Control）地址 macaddr8 MAC（Media Access Control）地址（EUI-64格式） money 货币数量 numeric [ (p, s) ] decimal [ (p, s) ] 可选择精度的精确数字 path 平面上的几何路径 pg_lsn 日志序号 point 平面上的几何点 polygon 平面上的封闭几何路径 real float4 单精度浮点数（4字节） smallint int2 有符号2字节整数 smallserial serial2 自动增长的2字节整数 serial serial4 自动增长的4字节整数 text 变长字符串 time [ (p) ] [ without time zone ] 一天中的时间（无时区） time [ (p) ] with time zone timetz 一天中的时间，包括时区 timestamp [ (p) ] [ without time zone ] 日期和时间（无时区） timestamp [ (p) ] with time zone timestampz 日期和时间，包括时区 tsquery 文本搜索查询 tsvector 文本搜索文档 txid_snapshot 用户级别事务ID快照 uuid 通用唯一标识码 除了XML的数据类型，MemFireDB尚不支持外，兼容PostgreSQL的其他所有数据类型；</description>
    </item>
    <item>
      <title>SQL语法</title>
      <link>http://localhost:1313/docs/db/guides/sql-grammar/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/guides/sql-grammar/</guid>
      <description>MemFireDB 结构化查询语言（MSQL）是符合ANSI标准的结构化查询语言。兼容PostgreSQL 11.2版本。MemFireDB复用了PostgresSQL的原生查询层。MemFire支持所有的传统关系模型功能，例如引用完整性（例如外键）、JOIN、分布式事务、部分索引、触发器和存储过程。&#xA;MSQL的主要组件包括数据定义语言（DDL）、数据操作语言（DML）和数据控制语言（DCL）。这些组件由多个元素构成，包括数据类型、数据库对象、名称和限定符、表达式和注释。此外MSQL还提供了其他用途的组件，例如系统控制、事务控制和性能调试。&#xA;声明 描述 ABORT 回滚事务 ALTER DATABASE 更改数据库定义 ALTER DEFAULT PRIVILEGES 定义默认访问权限 ALTER DOMAIN 变更网域 ALTER GROUP 变更群组 ALTER POLICY 更改行级安全策略 ALTER ROLE 改变角色 ALTER SEQUENCE 更改序列定义 ALTER TABLE 变更表定义 ALTER USER 更改用户（角色） BEGIN 开始交易 COMMENT 在数据库对象上添加注释 COMMIT 提交交易 COPY 在表和文件之间复制数据 CREATE AGGREGATE 创建一个新的聚合 CREATE CAST 建立新的类型转换 CREATE DATABASE 创建一个新的数据库 CREATE DOMAIN 创建一个新域 CREATE EXTENSION 加载扩展 CREATE FUNCTION 创建一个新功能 CREATE INDEX 创建一个新索引 CREATE GROUP 创建一个新组（角色） CREATE OPERATOR 创建一个新的运算符 CREATE OPERATOR CLASS 创建一个新的运算符类 CREATE POLICY 创建一个新的行级安全策略 CREATE PROCEDURE 创建一个新程序 CREATE ROLE 创建一个新角色（用户或组） CREATE RULE 创建一个新规则 CREATE USER 创建一个新用户（角色） CREATE SCHEMA 创建一个新的架构（命名空间） CREATE SEQUENCE 创建一个新的序列生成器 CREATE TABLE 创建一个新表 CREATE TABLE AS 创建一个新表 CREATE TRIGGER 创建一个新触发器 CREATE TYPE 建立新类型 CREATE VIEW 创建一个新的视图 DEALLOCATE 取消分配准备好的语句 DELETE 从表中删除行 DO 执行一个匿名代码块 DROP AGGREGATE 删除汇总 DROP CAST 删除类型转换 DROP DATABASE 从系统中删除数据库 DROP DOMAIN 删除网域 DROP EXTENSION 删除扩展 DROP FUNCTION 删除功能 DROP GROUP 删除组（角色） DROP OPERATOR 删除运算符 DROP OPERATOR CLASS 删除操作员类别 DROP OWNED 删除角色拥有的对象 DROP POLICY 删除行级安全策略 DROP PROCEDURE 删除程序 DROP ROLE 删除角色（用户或组） DROP RULE 删除规则 DROP SEQUENCE 删除序列发生器 DROP TABLE 从数据库中删除表 DROP TRIGGER 删除触发器 DROP TYPE 删除用户定义的类型 DROP USER 删除用户（角色） END 提交事务 EXECUTE 执行准备好的语句 EXPLAIN 显示语句的执行计划 INSERT 在表格中插入行 LOCK 锁定 PREPARE 准备一份声明 REASSIGN OWNED 重新分配拥有的对象 RESET 将参数重置为出厂设置 REVOKE 删除访问权限 ROLLBACK 回滚事务 SELECT 从表中选择行 SET 设置系统，会话或事务参数 SET CONSTRAINTS 设置当前交易的约束 SET ROLE 设定角色 SET SESSION AUTHORIZATION 设置会话授权 SET TRANSACTION 设置事务行为 SHOW 显示系统，会话或事务参数的值 SHOW TRANSACTION 显示交易的属性 TRUNCATE 清除表格中的所有行 UPDATE 更新表中的行 数据定义语言（DDL） linkDDL语句通过CREATE、ALTER和DROP命令来定义数据库中的结构、更改定义以及删除定义。 声明 描述 ALTER DATABASE 更改数据库定义 ALTER SEQUENCE 更改序列发生器的定义 ALTER TABLE 更改表定义 CREATE AGGREGATE 创建一个新的聚集函数 CREATE CAST 创建新的类型转换 CREATE DATABASE 创建一个新的数据库 CREATE EXTENSION 加载扩展 CREATE FUNCTION 创建一个新功能 CREATE INDEX 创建一个新索引 CREATE OPERATOR 创建一个新的运算符 CREATE OPERATOR CLASS 创建一个新的运算符类 CREATE PROCEDURE 创建一个新程序 CREATE RULE 创建一条新规则 CREATE SCHEMA 创建一个新的架构（命名空间） CREATE SEQUENCE 创建一个新的序列生成器 CREATE TABLE 创建一个新表 CREATE TABLE AS 创建一个新表 CREATE TRIGGER 创建一个新触发器 CREATE TYPE 创建一种新的类型 CREATE VIEW 创建一个新的视图 DROP AGGREGATE 删除汇总 DROP CAST 删除类型转换 DROP DATABASE 从系统中删除数据库 DROP EXTENSION 删除扩展 DROP FUNCTION 删除功能 DROP OPERATOR 删除运算符 DROP OPERATOR CLASS 删除运算符类 DROP PROCEDURE 删除一个过程 DROP RULE 删除程序 DROP SEQUENCE 删除序列发​​生器 DROP TABLE 从数据库中删除表 DROP TYPE 删除用户定义的类型 DROP TRIGGER 删除触发器 TRUNCATE 清空一个表或者一组表 数据操作语言（DML） linkDML语句修改数据库的内容。 声明 描述 DELETE 从表中删除行 INSERT 向表插入行 SELECT 从表中选择行 UPDATE 更新表中的行 数据控制语言（DCL） linkDCL语句可以保护并防止数据库损坏。 声明 描述 ALTER DEFAULT PRIVILEGES 定义默认访问权限 ALTER GROUP 变更群组 ALTER POLICY 更改行级安全策略 ALTER ROLE 更改角色（用户或组） ALTER USER 更改用户 CREATE GROUP 创建一个新组（角色） CREATE POLICY 创建一个新的行级安全策略 CREATE ROLE 创建一个新角色（用户或组） CREATE USER 创建一个新用户（角色） DROP GROUP 移除群组 DROP POLICY 删除行级安全策略 DROP ROLE 删除角色（用户或组） DROP OWNED 删除拥有的对象 DROP USER 删除用户 GRANT 授予权限 REASSIGN OWNED 重新分配拥有对象 REVOKE 撤销权限 SET ROLE 设定角色 SET SESSION AUTHORIZATION 设置会话授权 事务控制语言（TCL） linkTCL语句管理数据库上的事务。 声明 描述 ABORT 回滚事务 BEGIN 开始事务 COMMIT 提交事务 END 提交事务 ROLLBACK 回滚事务 SET CONSTRAINTS 设置当前事务的约束 SET TRANSACTION 设置事务行为 SHOW TRANSACTION 显示事务的属性 会话和系统控制 link&#xD;声明 描述 RESET 将参数重置为出厂设置 SET 设置系统，会话或事务参数 SHOW 显示系统，会话或事务参数的值 性能控制 link&#xD;声明 描述 DEALLOCATE 取消分配准备好的语句 EXECUTE 执行准备好的语句 EXPLAIN 解释陈述的执行计划 PREPARE 准备一份声明 其他声明 link&#xD;声明 描述 COPY 在表和文件之间复制数据 DO 执行一个匿名代码块 ABORT link概要</description>
    </item>
    <item>
      <title>函数与操作</title>
      <link>http://localhost:1313/docs/db/guides/functions-and-operations/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/db/guides/functions-and-operations/</guid>
      <description>逻辑操作符 link常用的逻辑操作符有： AND OR NOT SQL使用三值的逻辑系统，包括真、假和null，null表示“未知”。观察下面的真值表： a b a AND b a OR b TRUE TRUE TRUE TRUE TRUE FALSE FALSE TRUE TRUE NULL NULL TRUE FALSE FALSE FALSE FALSE FALSE NULL FALSE NULL NULL NULL NULL NULL a NOT a TRUE FALSE FALSE TRUE NULL NULL 操作符AND和OR是可交换的，也就是说，你可以交换左右操作数而不影响结果。&#xA;比较函数与操作符 link比较操作符可以用于所有可以比较的数据类型。所有比较操作符都是双目操作符，它们返回boolean类型；类似于1 &amp;lt; 2 &amp;lt; 3的表达式是非法的（因为没有&amp;lt;操作符可以比较一个布尔值和3）。&#xA;常见的比较操作符都可用，如表所示。&#xA;表.比较操作符 操作符 描述 &amp;lt; 小于 &amp;gt; 大于 &amp;lt;= 小于等于 &amp;gt;= 大于等于 = 等于 &amp;lt;&amp;gt; or !</description>
    </item>
    <item>
      <title>实名认证</title>
      <link>http://localhost:1313/docs/real-name-authentication/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/real-name-authentication/</guid>
      <description>MemFire Cloud实名认证目前仅支持个人实名认证操作，接下来会详细介绍如何进行实名认证。&#xA;如果你想参与MemFire Cloud官网个人运营活动，或想将MemFire Cloud账号及云资源归属于您个人名下，则需要您进行个人实名认证。&#xA;操作场景 link本文将指导您通过采用身份证正、反面照片+手持身份证照片进行实名认证操作。&#xA;操作前提 link已注册MemFire Cloud账号。&#xA;操作步骤 link 登录MemFire Cloud平台，进入个人中心-&amp;gt;实名认证页面。&#xA;点击开始个人认证，进入实名认证详情页面。&#xA;上传身份证正反面照片、手持身份证照片、并完善个人信息，核对姓名、身份证号。&#xA;上传清晰且包含完整边框，无遮挡、涂抹的证件照片 必须本人手持身份证 人脸、身份证上信息需清晰可见 格式支持JPG、PNG、JPEG格式，大小不超过1M 阅读《实名认证服务协议》，勾选您已阅读并同意该协议，点击提交，则提交个人实名认证申请。 完成个人实名认证申请操作后，平台预计在1~3个工作日完成个人实名认证审核工作。 特别说明：&#xA;针对个人实名认证，同一个身份信息（身份证号码）默认支持实名认证2个MemFire Cloud账号。 个人实名认证适用于年满18周岁的用户。 目前不支持港澳台个人用户进行实名认证操作。 不支持15位号码的一代身份证认证。 </description>
    </item>
    <item>
      <title>常见问题解答（FAQ）</title>
      <link>http://localhost:1313/docs/frequently-asked-questions/</link>
      <pubDate>Wed, 13 Dec 2023 17:39:49 +0800</pubDate>
      <guid>http://localhost:1313/docs/frequently-asked-questions/</guid>
      <description>产品FAQ link1、什么是MemFireDB Cloud？&#xA;MemFire Cloud是基于MemFireDB打造的数据库云服务，依托于MemFireDB的云原生和线性扩展能力，为互联网用户提供一站式数据库自助服务，实现按需使用，随用随取，最大化的节约成本、提高效率、减少维护。&#xA;2、MemFireDB Cloud支持哪些客户端？&#xA;MemFire Cloud支持所有MemFireDB兼容的客户端: 运行环境 客户端名称 下载地址 linux客户端 psql 命令：yum -y install postgresql11 windows客户端 dbeaver 、pgadmin 地址：https://dbeaver.io/files/7.1.0/dbeaver-ce-7.1.0-win32.win32.x86_64.zip mac客户端 dbeaver 地址：https://dbeaver.io/files/7.1.0/dbeaver-ce-7.1.0-macosx.cocoa.x86_64.tar.gz 3、MemFire Cloud是基于分布式数据库打造的吗？&#xA;是的，MemFire Cloud是基于分布式数据库MemFireDB打造的；&#xA;MemFireDB是基于 Raft一致性协议的分布式存储集群，可在线动态扩容存储和计算资源，扩容时不会影响业务的正常运行。&#xA;4、MemFire Cloud兼容哪个PostgreSQL版本?&#xA;MemFire Cloud支持符合ANSI标准的结构化查询语言。兼容PostgreSQL 11.2版本。&#xA;MemFireDB复用了PostgreSQL的原生查询层。MemFireDB支持所有的传统关系模型功能，例如引用完整性（例如外键）、JOIN、分布式事务、部分索引、触发器和存储过程。&#xA;5、MemFire Cloud支持哪些编程语言？&#xA;MemFire Cloud 支持python、Java、go等编程语言，具体编程样例可以参考：https://gitee.com/memfiredb&#xA;6、MemFireDB与MemFire Cloud有什么区别？&#xA;MemFireDB是敏博科技推出的一款高性能、分布式关系型数据库，支持分布式事务，在线平滑弹性伸缩，服务能力线性扩展，跨数据中心部署等能力，可以较好地兼容PostgreSQL的SQL访问形式。&#xA;MemFire Cloud是面向公有云的数据库即服务产品，提供自助服务，便捷的管理服务，满足中小企业开发人员对数据库的使用需求； 名称 MemFireDB MemFire Cloud 定义 分布式关系数据库 面向公有云的数据库即服务产品 DBaaS 部署方式 私有云（X86服务器、虚拟机） 公有云（阿里云） 关系 基础组件，数据库内核 MemFireDB作为内核 维护成本 硬件、DBA 无 售卖方式 “软件+售后服务” 租赁，”资源的使用权+SLA“ 迭代方式 主动升级 自动升级 面向客户 政府、企业等客户 互联网+中小企业客户 应用场景 高性能业务、金融业务 小程序、简单应用 7、MemFire Cloud 提供哪些机制来保障安全性？</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/docs/db/example/development-example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/db/example/development-example/</guid>
      <description>云数据库使用样例 linkMemFire Cloud 提供Python、Java、spring、golang、nodejs等各种开发示例，讲述如何编译执行程序，帮助用户如何采用多种语言来使用连接使用云数据库。&#xA;python示例&#xD;Java示例&#xD;Golang示例&#xD;Spring示例&#xD;Node示例&#xD;C++示例&#xD;C#示例 </description>
    </item>
  </channel>
</rss>
